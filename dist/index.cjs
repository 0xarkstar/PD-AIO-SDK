"use strict";
var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __esm = (fn, res) => function __init() {
  return fn && (res = (0, fn[__getOwnPropNames(fn)[0]])(fn = 0)), res;
};
var __commonJS = (cb, mod) => function __require() {
  return mod || (0, cb[__getOwnPropNames(cb)[0]])((mod = { exports: {} }).exports, mod), mod.exports;
};
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
  // If the importer is in node compatibility mode or this is not an ESM
  // file that has been converted to a CommonJS file using a Babel-
  // compatible transform (i.e. "__esModule" has not been set), then set
  // "default" to the CommonJS "module.exports" for node compatibility.
  isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
  mod
));
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// node_modules/eventemitter3/index.js
var require_eventemitter3 = __commonJS({
  "node_modules/eventemitter3/index.js"(exports2, module2) {
    "use strict";
    var has = Object.prototype.hasOwnProperty;
    var prefix = "~";
    function Events() {
    }
    if (Object.create) {
      Events.prototype = /* @__PURE__ */ Object.create(null);
      if (!new Events().__proto__) prefix = false;
    }
    function EE(fn, context, once) {
      this.fn = fn;
      this.context = context;
      this.once = once || false;
    }
    function addListener(emitter, event, fn, context, once) {
      if (typeof fn !== "function") {
        throw new TypeError("The listener must be a function");
      }
      var listener = new EE(fn, context || emitter, once), evt = prefix ? prefix + event : event;
      if (!emitter._events[evt]) emitter._events[evt] = listener, emitter._eventsCount++;
      else if (!emitter._events[evt].fn) emitter._events[evt].push(listener);
      else emitter._events[evt] = [emitter._events[evt], listener];
      return emitter;
    }
    function clearEvent(emitter, evt) {
      if (--emitter._eventsCount === 0) emitter._events = new Events();
      else delete emitter._events[evt];
    }
    function EventEmitter2() {
      this._events = new Events();
      this._eventsCount = 0;
    }
    EventEmitter2.prototype.eventNames = function eventNames() {
      var names = [], events, name;
      if (this._eventsCount === 0) return names;
      for (name in events = this._events) {
        if (has.call(events, name)) names.push(prefix ? name.slice(1) : name);
      }
      if (Object.getOwnPropertySymbols) {
        return names.concat(Object.getOwnPropertySymbols(events));
      }
      return names;
    };
    EventEmitter2.prototype.listeners = function listeners(event) {
      var evt = prefix ? prefix + event : event, handlers = this._events[evt];
      if (!handlers) return [];
      if (handlers.fn) return [handlers.fn];
      for (var i = 0, l = handlers.length, ee = new Array(l); i < l; i++) {
        ee[i] = handlers[i].fn;
      }
      return ee;
    };
    EventEmitter2.prototype.listenerCount = function listenerCount(event) {
      var evt = prefix ? prefix + event : event, listeners = this._events[evt];
      if (!listeners) return 0;
      if (listeners.fn) return 1;
      return listeners.length;
    };
    EventEmitter2.prototype.emit = function emit(event, a1, a2, a3, a4, a5) {
      var evt = prefix ? prefix + event : event;
      if (!this._events[evt]) return false;
      var listeners = this._events[evt], len = arguments.length, args, i;
      if (listeners.fn) {
        if (listeners.once) this.removeListener(event, listeners.fn, void 0, true);
        switch (len) {
          case 1:
            return listeners.fn.call(listeners.context), true;
          case 2:
            return listeners.fn.call(listeners.context, a1), true;
          case 3:
            return listeners.fn.call(listeners.context, a1, a2), true;
          case 4:
            return listeners.fn.call(listeners.context, a1, a2, a3), true;
          case 5:
            return listeners.fn.call(listeners.context, a1, a2, a3, a4), true;
          case 6:
            return listeners.fn.call(listeners.context, a1, a2, a3, a4, a5), true;
        }
        for (i = 1, args = new Array(len - 1); i < len; i++) {
          args[i - 1] = arguments[i];
        }
        listeners.fn.apply(listeners.context, args);
      } else {
        var length = listeners.length, j;
        for (i = 0; i < length; i++) {
          if (listeners[i].once) this.removeListener(event, listeners[i].fn, void 0, true);
          switch (len) {
            case 1:
              listeners[i].fn.call(listeners[i].context);
              break;
            case 2:
              listeners[i].fn.call(listeners[i].context, a1);
              break;
            case 3:
              listeners[i].fn.call(listeners[i].context, a1, a2);
              break;
            case 4:
              listeners[i].fn.call(listeners[i].context, a1, a2, a3);
              break;
            default:
              if (!args) for (j = 1, args = new Array(len - 1); j < len; j++) {
                args[j - 1] = arguments[j];
              }
              listeners[i].fn.apply(listeners[i].context, args);
          }
        }
      }
      return true;
    };
    EventEmitter2.prototype.on = function on(event, fn, context) {
      return addListener(this, event, fn, context, false);
    };
    EventEmitter2.prototype.once = function once(event, fn, context) {
      return addListener(this, event, fn, context, true);
    };
    EventEmitter2.prototype.removeListener = function removeListener(event, fn, context, once) {
      var evt = prefix ? prefix + event : event;
      if (!this._events[evt]) return this;
      if (!fn) {
        clearEvent(this, evt);
        return this;
      }
      var listeners = this._events[evt];
      if (listeners.fn) {
        if (listeners.fn === fn && (!once || listeners.once) && (!context || listeners.context === context)) {
          clearEvent(this, evt);
        }
      } else {
        for (var i = 0, events = [], length = listeners.length; i < length; i++) {
          if (listeners[i].fn !== fn || once && !listeners[i].once || context && listeners[i].context !== context) {
            events.push(listeners[i]);
          }
        }
        if (events.length) this._events[evt] = events.length === 1 ? events[0] : events;
        else clearEvent(this, evt);
      }
      return this;
    };
    EventEmitter2.prototype.removeAllListeners = function removeAllListeners(event) {
      var evt;
      if (event) {
        evt = prefix ? prefix + event : event;
        if (this._events[evt]) clearEvent(this, evt);
      } else {
        this._events = new Events();
        this._eventsCount = 0;
      }
      return this;
    };
    EventEmitter2.prototype.off = EventEmitter2.prototype.removeListener;
    EventEmitter2.prototype.addListener = EventEmitter2.prototype.on;
    EventEmitter2.prefixed = prefix;
    EventEmitter2.EventEmitter = EventEmitter2;
    if ("undefined" !== typeof module2) {
      module2.exports = EventEmitter2;
    }
  }
});

// node_modules/js-sha3/src/sha3.js
var require_sha3 = __commonJS({
  "node_modules/js-sha3/src/sha3.js"(exports2, module2) {
    (function() {
      "use strict";
      var INPUT_ERROR = "input is invalid type";
      var FINALIZE_ERROR = "finalize already called";
      var WINDOW = typeof window === "object";
      var root = WINDOW ? window : {};
      if (root.JS_SHA3_NO_WINDOW) {
        WINDOW = false;
      }
      var WEB_WORKER = !WINDOW && typeof self === "object";
      var NODE_JS = !root.JS_SHA3_NO_NODE_JS && typeof process === "object" && process.versions && process.versions.node;
      if (NODE_JS) {
        root = global;
      } else if (WEB_WORKER) {
        root = self;
      }
      var COMMON_JS = !root.JS_SHA3_NO_COMMON_JS && typeof module2 === "object" && module2.exports;
      var AMD = typeof define === "function" && define.amd;
      var ARRAY_BUFFER = !root.JS_SHA3_NO_ARRAY_BUFFER && typeof ArrayBuffer !== "undefined";
      var HEX_CHARS = "0123456789abcdef".split("");
      var SHAKE_PADDING = [31, 7936, 2031616, 520093696];
      var CSHAKE_PADDING = [4, 1024, 262144, 67108864];
      var KECCAK_PADDING = [1, 256, 65536, 16777216];
      var PADDING = [6, 1536, 393216, 100663296];
      var SHIFT = [0, 8, 16, 24];
      var RC = [
        1,
        0,
        32898,
        0,
        32906,
        2147483648,
        2147516416,
        2147483648,
        32907,
        0,
        2147483649,
        0,
        2147516545,
        2147483648,
        32777,
        2147483648,
        138,
        0,
        136,
        0,
        2147516425,
        0,
        2147483658,
        0,
        2147516555,
        0,
        139,
        2147483648,
        32905,
        2147483648,
        32771,
        2147483648,
        32770,
        2147483648,
        128,
        2147483648,
        32778,
        0,
        2147483658,
        2147483648,
        2147516545,
        2147483648,
        32896,
        2147483648,
        2147483649,
        0,
        2147516424,
        2147483648
      ];
      var BITS = [224, 256, 384, 512];
      var SHAKE_BITS = [128, 256];
      var OUTPUT_TYPES = ["hex", "buffer", "arrayBuffer", "array", "digest"];
      var CSHAKE_BYTEPAD = {
        "128": 168,
        "256": 136
      };
      var isArray = root.JS_SHA3_NO_NODE_JS || !Array.isArray ? function(obj) {
        return Object.prototype.toString.call(obj) === "[object Array]";
      } : Array.isArray;
      var isView = ARRAY_BUFFER && (root.JS_SHA3_NO_ARRAY_BUFFER_IS_VIEW || !ArrayBuffer.isView) ? function(obj) {
        return typeof obj === "object" && obj.buffer && obj.buffer.constructor === ArrayBuffer;
      } : ArrayBuffer.isView;
      var formatMessage = function(message) {
        var type = typeof message;
        if (type === "string") {
          return [message, true];
        }
        if (type !== "object" || message === null) {
          throw new Error(INPUT_ERROR);
        }
        if (ARRAY_BUFFER && message.constructor === ArrayBuffer) {
          return [new Uint8Array(message), false];
        }
        if (!isArray(message) && !isView(message)) {
          throw new Error(INPUT_ERROR);
        }
        return [message, false];
      };
      var empty = function(message) {
        return formatMessage(message)[0].length === 0;
      };
      var cloneArray = function(array) {
        var newArray = [];
        for (var i2 = 0; i2 < array.length; ++i2) {
          newArray[i2] = array[i2];
        }
        return newArray;
      };
      var createOutputMethod = function(bits2, padding, outputType) {
        return function(message) {
          return new Keccak(bits2, padding, bits2).update(message)[outputType]();
        };
      };
      var createShakeOutputMethod = function(bits2, padding, outputType) {
        return function(message, outputBits) {
          return new Keccak(bits2, padding, outputBits).update(message)[outputType]();
        };
      };
      var createCshakeOutputMethod = function(bits2, padding, outputType) {
        return function(message, outputBits, n, s) {
          return methods["cshake" + bits2].update(message, outputBits, n, s)[outputType]();
        };
      };
      var createKmacOutputMethod = function(bits2, padding, outputType) {
        return function(key, message, outputBits, s) {
          return methods["kmac" + bits2].update(key, message, outputBits, s)[outputType]();
        };
      };
      var createOutputMethods = function(method, createMethod2, bits2, padding) {
        for (var i2 = 0; i2 < OUTPUT_TYPES.length; ++i2) {
          var type = OUTPUT_TYPES[i2];
          method[type] = createMethod2(bits2, padding, type);
        }
        return method;
      };
      var createMethod = function(bits2, padding) {
        var method = createOutputMethod(bits2, padding, "hex");
        method.create = function() {
          return new Keccak(bits2, padding, bits2);
        };
        method.update = function(message) {
          return method.create().update(message);
        };
        return createOutputMethods(method, createOutputMethod, bits2, padding);
      };
      var createShakeMethod = function(bits2, padding) {
        var method = createShakeOutputMethod(bits2, padding, "hex");
        method.create = function(outputBits) {
          return new Keccak(bits2, padding, outputBits);
        };
        method.update = function(message, outputBits) {
          return method.create(outputBits).update(message);
        };
        return createOutputMethods(method, createShakeOutputMethod, bits2, padding);
      };
      var createCshakeMethod = function(bits2, padding) {
        var w = CSHAKE_BYTEPAD[bits2];
        var method = createCshakeOutputMethod(bits2, padding, "hex");
        method.create = function(outputBits, n, s) {
          if (empty(n) && empty(s)) {
            return methods["shake" + bits2].create(outputBits);
          } else {
            return new Keccak(bits2, padding, outputBits).bytepad([n, s], w);
          }
        };
        method.update = function(message, outputBits, n, s) {
          return method.create(outputBits, n, s).update(message);
        };
        return createOutputMethods(method, createCshakeOutputMethod, bits2, padding);
      };
      var createKmacMethod = function(bits2, padding) {
        var w = CSHAKE_BYTEPAD[bits2];
        var method = createKmacOutputMethod(bits2, padding, "hex");
        method.create = function(key, outputBits, s) {
          return new Kmac(bits2, padding, outputBits).bytepad(["KMAC", s], w).bytepad([key], w);
        };
        method.update = function(key, message, outputBits, s) {
          return method.create(key, outputBits, s).update(message);
        };
        return createOutputMethods(method, createKmacOutputMethod, bits2, padding);
      };
      var algorithms = [
        { name: "keccak", padding: KECCAK_PADDING, bits: BITS, createMethod },
        { name: "sha3", padding: PADDING, bits: BITS, createMethod },
        { name: "shake", padding: SHAKE_PADDING, bits: SHAKE_BITS, createMethod: createShakeMethod },
        { name: "cshake", padding: CSHAKE_PADDING, bits: SHAKE_BITS, createMethod: createCshakeMethod },
        { name: "kmac", padding: CSHAKE_PADDING, bits: SHAKE_BITS, createMethod: createKmacMethod }
      ];
      var methods = {}, methodNames = [];
      for (var i = 0; i < algorithms.length; ++i) {
        var algorithm = algorithms[i];
        var bits = algorithm.bits;
        for (var j = 0; j < bits.length; ++j) {
          var methodName = algorithm.name + "_" + bits[j];
          methodNames.push(methodName);
          methods[methodName] = algorithm.createMethod(bits[j], algorithm.padding);
          if (algorithm.name !== "sha3") {
            var newMethodName = algorithm.name + bits[j];
            methodNames.push(newMethodName);
            methods[newMethodName] = methods[methodName];
          }
        }
      }
      function Keccak(bits2, padding, outputBits) {
        this.blocks = [];
        this.s = [];
        this.padding = padding;
        this.outputBits = outputBits;
        this.reset = true;
        this.finalized = false;
        this.block = 0;
        this.start = 0;
        this.blockCount = 1600 - (bits2 << 1) >> 5;
        this.byteCount = this.blockCount << 2;
        this.outputBlocks = outputBits >> 5;
        this.extraBytes = (outputBits & 31) >> 3;
        for (var i2 = 0; i2 < 50; ++i2) {
          this.s[i2] = 0;
        }
      }
      Keccak.prototype.update = function(message) {
        if (this.finalized) {
          throw new Error(FINALIZE_ERROR);
        }
        var result = formatMessage(message);
        message = result[0];
        var isString = result[1];
        var blocks = this.blocks, byteCount = this.byteCount, length = message.length, blockCount = this.blockCount, index = 0, s = this.s, i2, code;
        while (index < length) {
          if (this.reset) {
            this.reset = false;
            blocks[0] = this.block;
            for (i2 = 1; i2 < blockCount + 1; ++i2) {
              blocks[i2] = 0;
            }
          }
          if (isString) {
            for (i2 = this.start; index < length && i2 < byteCount; ++index) {
              code = message.charCodeAt(index);
              if (code < 128) {
                blocks[i2 >> 2] |= code << SHIFT[i2++ & 3];
              } else if (code < 2048) {
                blocks[i2 >> 2] |= (192 | code >> 6) << SHIFT[i2++ & 3];
                blocks[i2 >> 2] |= (128 | code & 63) << SHIFT[i2++ & 3];
              } else if (code < 55296 || code >= 57344) {
                blocks[i2 >> 2] |= (224 | code >> 12) << SHIFT[i2++ & 3];
                blocks[i2 >> 2] |= (128 | code >> 6 & 63) << SHIFT[i2++ & 3];
                blocks[i2 >> 2] |= (128 | code & 63) << SHIFT[i2++ & 3];
              } else {
                code = 65536 + ((code & 1023) << 10 | message.charCodeAt(++index) & 1023);
                blocks[i2 >> 2] |= (240 | code >> 18) << SHIFT[i2++ & 3];
                blocks[i2 >> 2] |= (128 | code >> 12 & 63) << SHIFT[i2++ & 3];
                blocks[i2 >> 2] |= (128 | code >> 6 & 63) << SHIFT[i2++ & 3];
                blocks[i2 >> 2] |= (128 | code & 63) << SHIFT[i2++ & 3];
              }
            }
          } else {
            for (i2 = this.start; index < length && i2 < byteCount; ++index) {
              blocks[i2 >> 2] |= message[index] << SHIFT[i2++ & 3];
            }
          }
          this.lastByteIndex = i2;
          if (i2 >= byteCount) {
            this.start = i2 - byteCount;
            this.block = blocks[blockCount];
            for (i2 = 0; i2 < blockCount; ++i2) {
              s[i2] ^= blocks[i2];
            }
            f(s);
            this.reset = true;
          } else {
            this.start = i2;
          }
        }
        return this;
      };
      Keccak.prototype.encode = function(x, right) {
        var o = x & 255, n = 1;
        var bytes = [o];
        x = x >> 8;
        o = x & 255;
        while (o > 0) {
          bytes.unshift(o);
          x = x >> 8;
          o = x & 255;
          ++n;
        }
        if (right) {
          bytes.push(n);
        } else {
          bytes.unshift(n);
        }
        this.update(bytes);
        return bytes.length;
      };
      Keccak.prototype.encodeString = function(str) {
        var result = formatMessage(str);
        str = result[0];
        var isString = result[1];
        var bytes = 0, length = str.length;
        if (isString) {
          for (var i2 = 0; i2 < str.length; ++i2) {
            var code = str.charCodeAt(i2);
            if (code < 128) {
              bytes += 1;
            } else if (code < 2048) {
              bytes += 2;
            } else if (code < 55296 || code >= 57344) {
              bytes += 3;
            } else {
              code = 65536 + ((code & 1023) << 10 | str.charCodeAt(++i2) & 1023);
              bytes += 4;
            }
          }
        } else {
          bytes = length;
        }
        bytes += this.encode(bytes * 8);
        this.update(str);
        return bytes;
      };
      Keccak.prototype.bytepad = function(strs, w) {
        var bytes = this.encode(w);
        for (var i2 = 0; i2 < strs.length; ++i2) {
          bytes += this.encodeString(strs[i2]);
        }
        var paddingBytes = (w - bytes % w) % w;
        var zeros = [];
        zeros.length = paddingBytes;
        this.update(zeros);
        return this;
      };
      Keccak.prototype.finalize = function() {
        if (this.finalized) {
          return;
        }
        this.finalized = true;
        var blocks = this.blocks, i2 = this.lastByteIndex, blockCount = this.blockCount, s = this.s;
        blocks[i2 >> 2] |= this.padding[i2 & 3];
        if (this.lastByteIndex === this.byteCount) {
          blocks[0] = blocks[blockCount];
          for (i2 = 1; i2 < blockCount + 1; ++i2) {
            blocks[i2] = 0;
          }
        }
        blocks[blockCount - 1] |= 2147483648;
        for (i2 = 0; i2 < blockCount; ++i2) {
          s[i2] ^= blocks[i2];
        }
        f(s);
      };
      Keccak.prototype.toString = Keccak.prototype.hex = function() {
        this.finalize();
        var blockCount = this.blockCount, s = this.s, outputBlocks = this.outputBlocks, extraBytes = this.extraBytes, i2 = 0, j2 = 0;
        var hex = "", block;
        while (j2 < outputBlocks) {
          for (i2 = 0; i2 < blockCount && j2 < outputBlocks; ++i2, ++j2) {
            block = s[i2];
            hex += HEX_CHARS[block >> 4 & 15] + HEX_CHARS[block & 15] + HEX_CHARS[block >> 12 & 15] + HEX_CHARS[block >> 8 & 15] + HEX_CHARS[block >> 20 & 15] + HEX_CHARS[block >> 16 & 15] + HEX_CHARS[block >> 28 & 15] + HEX_CHARS[block >> 24 & 15];
          }
          if (j2 % blockCount === 0) {
            s = cloneArray(s);
            f(s);
            i2 = 0;
          }
        }
        if (extraBytes) {
          block = s[i2];
          hex += HEX_CHARS[block >> 4 & 15] + HEX_CHARS[block & 15];
          if (extraBytes > 1) {
            hex += HEX_CHARS[block >> 12 & 15] + HEX_CHARS[block >> 8 & 15];
          }
          if (extraBytes > 2) {
            hex += HEX_CHARS[block >> 20 & 15] + HEX_CHARS[block >> 16 & 15];
          }
        }
        return hex;
      };
      Keccak.prototype.arrayBuffer = function() {
        this.finalize();
        var blockCount = this.blockCount, s = this.s, outputBlocks = this.outputBlocks, extraBytes = this.extraBytes, i2 = 0, j2 = 0;
        var bytes = this.outputBits >> 3;
        var buffer;
        if (extraBytes) {
          buffer = new ArrayBuffer(outputBlocks + 1 << 2);
        } else {
          buffer = new ArrayBuffer(bytes);
        }
        var array = new Uint32Array(buffer);
        while (j2 < outputBlocks) {
          for (i2 = 0; i2 < blockCount && j2 < outputBlocks; ++i2, ++j2) {
            array[j2] = s[i2];
          }
          if (j2 % blockCount === 0) {
            s = cloneArray(s);
            f(s);
          }
        }
        if (extraBytes) {
          array[j2] = s[i2];
          buffer = buffer.slice(0, bytes);
        }
        return buffer;
      };
      Keccak.prototype.buffer = Keccak.prototype.arrayBuffer;
      Keccak.prototype.digest = Keccak.prototype.array = function() {
        this.finalize();
        var blockCount = this.blockCount, s = this.s, outputBlocks = this.outputBlocks, extraBytes = this.extraBytes, i2 = 0, j2 = 0;
        var array = [], offset, block;
        while (j2 < outputBlocks) {
          for (i2 = 0; i2 < blockCount && j2 < outputBlocks; ++i2, ++j2) {
            offset = j2 << 2;
            block = s[i2];
            array[offset] = block & 255;
            array[offset + 1] = block >> 8 & 255;
            array[offset + 2] = block >> 16 & 255;
            array[offset + 3] = block >> 24 & 255;
          }
          if (j2 % blockCount === 0) {
            s = cloneArray(s);
            f(s);
          }
        }
        if (extraBytes) {
          offset = j2 << 2;
          block = s[i2];
          array[offset] = block & 255;
          if (extraBytes > 1) {
            array[offset + 1] = block >> 8 & 255;
          }
          if (extraBytes > 2) {
            array[offset + 2] = block >> 16 & 255;
          }
        }
        return array;
      };
      function Kmac(bits2, padding, outputBits) {
        Keccak.call(this, bits2, padding, outputBits);
      }
      Kmac.prototype = new Keccak();
      Kmac.prototype.finalize = function() {
        this.encode(this.outputBits, true);
        return Keccak.prototype.finalize.call(this);
      };
      var f = function(s) {
        var h2, l, n, c0, c1, c2, c3, c4, c5, c6, c7, c8, c9, b0, b1, b2, b3, b4, b5, b6, b7, b8, b9, b10, b11, b12, b13, b14, b15, b16, b17, b18, b19, b20, b21, b22, b23, b24, b25, b26, b27, b28, b29, b30, b31, b32, b33, b34, b35, b36, b37, b38, b39, b40, b41, b42, b43, b44, b45, b46, b47, b48, b49;
        for (n = 0; n < 48; n += 2) {
          c0 = s[0] ^ s[10] ^ s[20] ^ s[30] ^ s[40];
          c1 = s[1] ^ s[11] ^ s[21] ^ s[31] ^ s[41];
          c2 = s[2] ^ s[12] ^ s[22] ^ s[32] ^ s[42];
          c3 = s[3] ^ s[13] ^ s[23] ^ s[33] ^ s[43];
          c4 = s[4] ^ s[14] ^ s[24] ^ s[34] ^ s[44];
          c5 = s[5] ^ s[15] ^ s[25] ^ s[35] ^ s[45];
          c6 = s[6] ^ s[16] ^ s[26] ^ s[36] ^ s[46];
          c7 = s[7] ^ s[17] ^ s[27] ^ s[37] ^ s[47];
          c8 = s[8] ^ s[18] ^ s[28] ^ s[38] ^ s[48];
          c9 = s[9] ^ s[19] ^ s[29] ^ s[39] ^ s[49];
          h2 = c8 ^ (c2 << 1 | c3 >>> 31);
          l = c9 ^ (c3 << 1 | c2 >>> 31);
          s[0] ^= h2;
          s[1] ^= l;
          s[10] ^= h2;
          s[11] ^= l;
          s[20] ^= h2;
          s[21] ^= l;
          s[30] ^= h2;
          s[31] ^= l;
          s[40] ^= h2;
          s[41] ^= l;
          h2 = c0 ^ (c4 << 1 | c5 >>> 31);
          l = c1 ^ (c5 << 1 | c4 >>> 31);
          s[2] ^= h2;
          s[3] ^= l;
          s[12] ^= h2;
          s[13] ^= l;
          s[22] ^= h2;
          s[23] ^= l;
          s[32] ^= h2;
          s[33] ^= l;
          s[42] ^= h2;
          s[43] ^= l;
          h2 = c2 ^ (c6 << 1 | c7 >>> 31);
          l = c3 ^ (c7 << 1 | c6 >>> 31);
          s[4] ^= h2;
          s[5] ^= l;
          s[14] ^= h2;
          s[15] ^= l;
          s[24] ^= h2;
          s[25] ^= l;
          s[34] ^= h2;
          s[35] ^= l;
          s[44] ^= h2;
          s[45] ^= l;
          h2 = c4 ^ (c8 << 1 | c9 >>> 31);
          l = c5 ^ (c9 << 1 | c8 >>> 31);
          s[6] ^= h2;
          s[7] ^= l;
          s[16] ^= h2;
          s[17] ^= l;
          s[26] ^= h2;
          s[27] ^= l;
          s[36] ^= h2;
          s[37] ^= l;
          s[46] ^= h2;
          s[47] ^= l;
          h2 = c6 ^ (c0 << 1 | c1 >>> 31);
          l = c7 ^ (c1 << 1 | c0 >>> 31);
          s[8] ^= h2;
          s[9] ^= l;
          s[18] ^= h2;
          s[19] ^= l;
          s[28] ^= h2;
          s[29] ^= l;
          s[38] ^= h2;
          s[39] ^= l;
          s[48] ^= h2;
          s[49] ^= l;
          b0 = s[0];
          b1 = s[1];
          b32 = s[11] << 4 | s[10] >>> 28;
          b33 = s[10] << 4 | s[11] >>> 28;
          b14 = s[20] << 3 | s[21] >>> 29;
          b15 = s[21] << 3 | s[20] >>> 29;
          b46 = s[31] << 9 | s[30] >>> 23;
          b47 = s[30] << 9 | s[31] >>> 23;
          b28 = s[40] << 18 | s[41] >>> 14;
          b29 = s[41] << 18 | s[40] >>> 14;
          b20 = s[2] << 1 | s[3] >>> 31;
          b21 = s[3] << 1 | s[2] >>> 31;
          b2 = s[13] << 12 | s[12] >>> 20;
          b3 = s[12] << 12 | s[13] >>> 20;
          b34 = s[22] << 10 | s[23] >>> 22;
          b35 = s[23] << 10 | s[22] >>> 22;
          b16 = s[33] << 13 | s[32] >>> 19;
          b17 = s[32] << 13 | s[33] >>> 19;
          b48 = s[42] << 2 | s[43] >>> 30;
          b49 = s[43] << 2 | s[42] >>> 30;
          b40 = s[5] << 30 | s[4] >>> 2;
          b41 = s[4] << 30 | s[5] >>> 2;
          b22 = s[14] << 6 | s[15] >>> 26;
          b23 = s[15] << 6 | s[14] >>> 26;
          b4 = s[25] << 11 | s[24] >>> 21;
          b5 = s[24] << 11 | s[25] >>> 21;
          b36 = s[34] << 15 | s[35] >>> 17;
          b37 = s[35] << 15 | s[34] >>> 17;
          b18 = s[45] << 29 | s[44] >>> 3;
          b19 = s[44] << 29 | s[45] >>> 3;
          b10 = s[6] << 28 | s[7] >>> 4;
          b11 = s[7] << 28 | s[6] >>> 4;
          b42 = s[17] << 23 | s[16] >>> 9;
          b43 = s[16] << 23 | s[17] >>> 9;
          b24 = s[26] << 25 | s[27] >>> 7;
          b25 = s[27] << 25 | s[26] >>> 7;
          b6 = s[36] << 21 | s[37] >>> 11;
          b7 = s[37] << 21 | s[36] >>> 11;
          b38 = s[47] << 24 | s[46] >>> 8;
          b39 = s[46] << 24 | s[47] >>> 8;
          b30 = s[8] << 27 | s[9] >>> 5;
          b31 = s[9] << 27 | s[8] >>> 5;
          b12 = s[18] << 20 | s[19] >>> 12;
          b13 = s[19] << 20 | s[18] >>> 12;
          b44 = s[29] << 7 | s[28] >>> 25;
          b45 = s[28] << 7 | s[29] >>> 25;
          b26 = s[38] << 8 | s[39] >>> 24;
          b27 = s[39] << 8 | s[38] >>> 24;
          b8 = s[48] << 14 | s[49] >>> 18;
          b9 = s[49] << 14 | s[48] >>> 18;
          s[0] = b0 ^ ~b2 & b4;
          s[1] = b1 ^ ~b3 & b5;
          s[10] = b10 ^ ~b12 & b14;
          s[11] = b11 ^ ~b13 & b15;
          s[20] = b20 ^ ~b22 & b24;
          s[21] = b21 ^ ~b23 & b25;
          s[30] = b30 ^ ~b32 & b34;
          s[31] = b31 ^ ~b33 & b35;
          s[40] = b40 ^ ~b42 & b44;
          s[41] = b41 ^ ~b43 & b45;
          s[2] = b2 ^ ~b4 & b6;
          s[3] = b3 ^ ~b5 & b7;
          s[12] = b12 ^ ~b14 & b16;
          s[13] = b13 ^ ~b15 & b17;
          s[22] = b22 ^ ~b24 & b26;
          s[23] = b23 ^ ~b25 & b27;
          s[32] = b32 ^ ~b34 & b36;
          s[33] = b33 ^ ~b35 & b37;
          s[42] = b42 ^ ~b44 & b46;
          s[43] = b43 ^ ~b45 & b47;
          s[4] = b4 ^ ~b6 & b8;
          s[5] = b5 ^ ~b7 & b9;
          s[14] = b14 ^ ~b16 & b18;
          s[15] = b15 ^ ~b17 & b19;
          s[24] = b24 ^ ~b26 & b28;
          s[25] = b25 ^ ~b27 & b29;
          s[34] = b34 ^ ~b36 & b38;
          s[35] = b35 ^ ~b37 & b39;
          s[44] = b44 ^ ~b46 & b48;
          s[45] = b45 ^ ~b47 & b49;
          s[6] = b6 ^ ~b8 & b0;
          s[7] = b7 ^ ~b9 & b1;
          s[16] = b16 ^ ~b18 & b10;
          s[17] = b17 ^ ~b19 & b11;
          s[26] = b26 ^ ~b28 & b20;
          s[27] = b27 ^ ~b29 & b21;
          s[36] = b36 ^ ~b38 & b30;
          s[37] = b37 ^ ~b39 & b31;
          s[46] = b46 ^ ~b48 & b40;
          s[47] = b47 ^ ~b49 & b41;
          s[8] = b8 ^ ~b0 & b2;
          s[9] = b9 ^ ~b1 & b3;
          s[18] = b18 ^ ~b10 & b12;
          s[19] = b19 ^ ~b11 & b13;
          s[28] = b28 ^ ~b20 & b22;
          s[29] = b29 ^ ~b21 & b23;
          s[38] = b38 ^ ~b30 & b32;
          s[39] = b39 ^ ~b31 & b33;
          s[48] = b48 ^ ~b40 & b42;
          s[49] = b49 ^ ~b41 & b43;
          s[0] ^= RC[n];
          s[1] ^= RC[n + 1];
        }
      };
      if (COMMON_JS) {
        module2.exports = methods;
      } else {
        for (i = 0; i < methodNames.length; ++i) {
          root[methodNames[i]] = methods[methodNames[i]];
        }
        if (AMD) {
          define(function() {
            return methods;
          });
        }
      }
    })();
  }
});

// node_modules/@noble/ed25519/index.js
var ed25519_exports = {};
__export(ed25519_exports, {
  Point: () => Point,
  etc: () => etc,
  getPublicKey: () => getPublicKey,
  getPublicKeyAsync: () => getPublicKeyAsync,
  hash: () => hash2,
  hashes: () => hashes,
  keygen: () => keygen,
  keygenAsync: () => keygenAsync,
  sign: () => sign,
  signAsync: () => signAsync,
  utils: () => utils,
  verify: () => verify,
  verifyAsync: () => verifyAsync
});
var ed25519_CURVE, P, N, Gx, Gy, _a, _d, h, L, L2, captureTrace, err, isBig, isStr, isBytes, abytes, u8n, u8fr, padh, bytesToHex2, C, _ch, hexToBytes2, cr, subtle, concatBytes, randomBytes, big, assertRange, M, modN, invert, callHash, hash2, apoint, B256, Point, G, I, numTo32bLE, bytesToNumLE, pow2, pow_2_252_3, RM1, uvRatio, modL_LE, sha512a, sha512s, hash2extK, getExtendedPublicKeyAsync, getExtendedPublicKey, getPublicKeyAsync, getPublicKey, hashFinishA, hashFinishS, _sign, signAsync, sign, defaultVerifyOpts, _verify, verifyAsync, verify, etc, hashes, randomSecretKey, keygen, keygenAsync, utils, W, scalarBits, pwindows, pwindowSize, precompute, Gpows, ctneg, wNAF;
var init_ed25519 = __esm({
  "node_modules/@noble/ed25519/index.js"() {
    ed25519_CURVE = {
      p: 0x7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffedn,
      n: 0x1000000000000000000000000000000014def9dea2f79cd65812631a5cf5d3edn,
      h: 8n,
      a: 0x7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffecn,
      d: 0x52036cee2b6ffe738cc740797779e89800700a4d4141d8ab75eb4dca135978a3n,
      Gx: 0x216936d3cd6e53fec0a4e231fdd6dc5c692cc7609525a7b2c9562d608f25d51an,
      Gy: 0x6666666666666666666666666666666666666666666666666666666666666658n
    };
    ({ p: P, n: N, Gx, Gy, a: _a, d: _d, h } = ed25519_CURVE);
    L = 32;
    L2 = 64;
    captureTrace = (...args) => {
      if ("captureStackTrace" in Error && typeof Error.captureStackTrace === "function") {
        Error.captureStackTrace(...args);
      }
    };
    err = (message = "") => {
      const e = new Error(message);
      captureTrace(e, err);
      throw e;
    };
    isBig = (n) => typeof n === "bigint";
    isStr = (s) => typeof s === "string";
    isBytes = (a) => a instanceof Uint8Array || ArrayBuffer.isView(a) && a.constructor.name === "Uint8Array";
    abytes = (value, length, title = "") => {
      const bytes = isBytes(value);
      const len = value?.length;
      const needsLen = length !== void 0;
      if (!bytes || needsLen && len !== length) {
        const prefix = title && `"${title}" `;
        const ofLen = needsLen ? ` of length ${length}` : "";
        const got = bytes ? `length=${len}` : `type=${typeof value}`;
        err(prefix + "expected Uint8Array" + ofLen + ", got " + got);
      }
      return value;
    };
    u8n = (len) => new Uint8Array(len);
    u8fr = (buf) => Uint8Array.from(buf);
    padh = (n, pad) => n.toString(16).padStart(pad, "0");
    bytesToHex2 = (b) => Array.from(abytes(b)).map((e) => padh(e, 2)).join("");
    C = { _0: 48, _9: 57, A: 65, F: 70, a: 97, f: 102 };
    _ch = (ch) => {
      if (ch >= C._0 && ch <= C._9)
        return ch - C._0;
      if (ch >= C.A && ch <= C.F)
        return ch - (C.A - 10);
      if (ch >= C.a && ch <= C.f)
        return ch - (C.a - 10);
      return;
    };
    hexToBytes2 = (hex) => {
      const e = "hex invalid";
      if (!isStr(hex))
        return err(e);
      const hl = hex.length;
      const al = hl / 2;
      if (hl % 2)
        return err(e);
      const array = u8n(al);
      for (let ai = 0, hi = 0; ai < al; ai++, hi += 2) {
        const n1 = _ch(hex.charCodeAt(hi));
        const n2 = _ch(hex.charCodeAt(hi + 1));
        if (n1 === void 0 || n2 === void 0)
          return err(e);
        array[ai] = n1 * 16 + n2;
      }
      return array;
    };
    cr = () => globalThis?.crypto;
    subtle = () => cr()?.subtle ?? err("crypto.subtle must be defined, consider polyfill");
    concatBytes = (...arrs) => {
      const r = u8n(arrs.reduce((sum, a) => sum + abytes(a).length, 0));
      let pad = 0;
      arrs.forEach((a) => {
        r.set(a, pad);
        pad += a.length;
      });
      return r;
    };
    randomBytes = (len = L) => {
      const c = cr();
      return c.getRandomValues(u8n(len));
    };
    big = BigInt;
    assertRange = (n, min, max, msg = "bad number: out of range") => isBig(n) && min <= n && n < max ? n : err(msg);
    M = (a, b = P) => {
      const r = a % b;
      return r >= 0n ? r : b + r;
    };
    modN = (a) => M(a, N);
    invert = (num, md) => {
      if (num === 0n || md <= 0n)
        err("no inverse n=" + num + " mod=" + md);
      let a = M(num, md), b = md, x = 0n, y = 1n, u = 1n, v = 0n;
      while (a !== 0n) {
        const q = b / a, r = b % a;
        const m = x - u * q, n = y - v * q;
        b = a, a = r, x = u, y = v, u = m, v = n;
      }
      return b === 1n ? M(x, md) : err("no inverse");
    };
    callHash = (name) => {
      const fn = hashes[name];
      if (typeof fn !== "function")
        err("hashes." + name + " not set");
      return fn;
    };
    hash2 = (msg) => callHash("sha512")(msg);
    apoint = (p) => p instanceof Point ? p : err("Point expected");
    B256 = 2n ** 256n;
    Point = class _Point {
      static BASE;
      static ZERO;
      X;
      Y;
      Z;
      T;
      constructor(X, Y, Z, T) {
        const max = B256;
        this.X = assertRange(X, 0n, max);
        this.Y = assertRange(Y, 0n, max);
        this.Z = assertRange(Z, 1n, max);
        this.T = assertRange(T, 0n, max);
        Object.freeze(this);
      }
      static CURVE() {
        return ed25519_CURVE;
      }
      static fromAffine(p) {
        return new _Point(p.x, p.y, 1n, M(p.x * p.y));
      }
      /** RFC8032 5.1.3: Uint8Array to Point. */
      static fromBytes(hex, zip215 = false) {
        const d = _d;
        const normed = u8fr(abytes(hex, L));
        const lastByte = hex[31];
        normed[31] = lastByte & ~128;
        const y = bytesToNumLE(normed);
        const max = zip215 ? B256 : P;
        assertRange(y, 0n, max);
        const y2 = M(y * y);
        const u = M(y2 - 1n);
        const v = M(d * y2 + 1n);
        let { isValid: isValid2, value: x } = uvRatio(u, v);
        if (!isValid2)
          err("bad point: y not sqrt");
        const isXOdd = (x & 1n) === 1n;
        const isLastByteOdd = (lastByte & 128) !== 0;
        if (!zip215 && x === 0n && isLastByteOdd)
          err("bad point: x==0, isLastByteOdd");
        if (isLastByteOdd !== isXOdd)
          x = M(-x);
        return new _Point(x, y, 1n, M(x * y));
      }
      static fromHex(hex, zip215) {
        return _Point.fromBytes(hexToBytes2(hex), zip215);
      }
      get x() {
        return this.toAffine().x;
      }
      get y() {
        return this.toAffine().y;
      }
      /** Checks if the point is valid and on-curve. */
      assertValidity() {
        const a = _a;
        const d = _d;
        const p = this;
        if (p.is0())
          return err("bad point: ZERO");
        const { X, Y, Z, T } = p;
        const X2 = M(X * X);
        const Y2 = M(Y * Y);
        const Z2 = M(Z * Z);
        const Z4 = M(Z2 * Z2);
        const aX2 = M(X2 * a);
        const left = M(Z2 * M(aX2 + Y2));
        const right = M(Z4 + M(d * M(X2 * Y2)));
        if (left !== right)
          return err("bad point: equation left != right (1)");
        const XY = M(X * Y);
        const ZT = M(Z * T);
        if (XY !== ZT)
          return err("bad point: equation left != right (2)");
        return this;
      }
      /** Equality check: compare points P&Q. */
      equals(other) {
        const { X: X1, Y: Y1, Z: Z1 } = this;
        const { X: X2, Y: Y2, Z: Z2 } = apoint(other);
        const X1Z2 = M(X1 * Z2);
        const X2Z1 = M(X2 * Z1);
        const Y1Z2 = M(Y1 * Z2);
        const Y2Z1 = M(Y2 * Z1);
        return X1Z2 === X2Z1 && Y1Z2 === Y2Z1;
      }
      is0() {
        return this.equals(I);
      }
      /** Flip point over y coordinate. */
      negate() {
        return new _Point(M(-this.X), this.Y, this.Z, M(-this.T));
      }
      /** Point doubling. Complete formula. Cost: `4M + 4S + 1*a + 6add + 1*2`. */
      double() {
        const { X: X1, Y: Y1, Z: Z1 } = this;
        const a = _a;
        const A = M(X1 * X1);
        const B = M(Y1 * Y1);
        const C2 = M(2n * M(Z1 * Z1));
        const D = M(a * A);
        const x1y1 = X1 + Y1;
        const E = M(M(x1y1 * x1y1) - A - B);
        const G2 = D + B;
        const F = G2 - C2;
        const H = D - B;
        const X3 = M(E * F);
        const Y3 = M(G2 * H);
        const T3 = M(E * H);
        const Z3 = M(F * G2);
        return new _Point(X3, Y3, Z3, T3);
      }
      /** Point addition. Complete formula. Cost: `8M + 1*k + 8add + 1*2`. */
      add(other) {
        const { X: X1, Y: Y1, Z: Z1, T: T1 } = this;
        const { X: X2, Y: Y2, Z: Z2, T: T2 } = apoint(other);
        const a = _a;
        const d = _d;
        const A = M(X1 * X2);
        const B = M(Y1 * Y2);
        const C2 = M(T1 * d * T2);
        const D = M(Z1 * Z2);
        const E = M((X1 + Y1) * (X2 + Y2) - A - B);
        const F = M(D - C2);
        const G2 = M(D + C2);
        const H = M(B - a * A);
        const X3 = M(E * F);
        const Y3 = M(G2 * H);
        const T3 = M(E * H);
        const Z3 = M(F * G2);
        return new _Point(X3, Y3, Z3, T3);
      }
      subtract(other) {
        return this.add(apoint(other).negate());
      }
      /**
       * Point-by-scalar multiplication. Scalar must be in range 1 <= n < CURVE.n.
       * Uses {@link wNAF} for base point.
       * Uses fake point to mitigate side-channel leakage.
       * @param n scalar by which point is multiplied
       * @param safe safe mode guards against timing attacks; unsafe mode is faster
       */
      multiply(n, safe = true) {
        if (!safe && (n === 0n || this.is0()))
          return I;
        assertRange(n, 1n, N);
        if (n === 1n)
          return this;
        if (this.equals(G))
          return wNAF(n).p;
        let p = I;
        let f = G;
        for (let d = this; n > 0n; d = d.double(), n >>= 1n) {
          if (n & 1n)
            p = p.add(d);
          else if (safe)
            f = f.add(d);
        }
        return p;
      }
      multiplyUnsafe(scalar) {
        return this.multiply(scalar, false);
      }
      /** Convert point to 2d xy affine point. (X, Y, Z) âˆ‹ (x=X/Z, y=Y/Z) */
      toAffine() {
        const { X, Y, Z } = this;
        if (this.equals(I))
          return { x: 0n, y: 1n };
        const iz = invert(Z, P);
        if (M(Z * iz) !== 1n)
          err("invalid inverse");
        const x = M(X * iz);
        const y = M(Y * iz);
        return { x, y };
      }
      toBytes() {
        const { x, y } = this.assertValidity().toAffine();
        const b = numTo32bLE(y);
        b[31] |= x & 1n ? 128 : 0;
        return b;
      }
      toHex() {
        return bytesToHex2(this.toBytes());
      }
      clearCofactor() {
        return this.multiply(big(h), false);
      }
      isSmallOrder() {
        return this.clearCofactor().is0();
      }
      isTorsionFree() {
        let p = this.multiply(N / 2n, false).double();
        if (N % 2n)
          p = p.add(this);
        return p.is0();
      }
    };
    G = new Point(Gx, Gy, 1n, M(Gx * Gy));
    I = new Point(0n, 1n, 1n, 0n);
    Point.BASE = G;
    Point.ZERO = I;
    numTo32bLE = (num) => hexToBytes2(padh(assertRange(num, 0n, B256), L2)).reverse();
    bytesToNumLE = (b) => big("0x" + bytesToHex2(u8fr(abytes(b)).reverse()));
    pow2 = (x, power) => {
      let r = x;
      while (power-- > 0n) {
        r *= r;
        r %= P;
      }
      return r;
    };
    pow_2_252_3 = (x) => {
      const x2 = x * x % P;
      const b2 = x2 * x % P;
      const b4 = pow2(b2, 2n) * b2 % P;
      const b5 = pow2(b4, 1n) * x % P;
      const b10 = pow2(b5, 5n) * b5 % P;
      const b20 = pow2(b10, 10n) * b10 % P;
      const b40 = pow2(b20, 20n) * b20 % P;
      const b80 = pow2(b40, 40n) * b40 % P;
      const b160 = pow2(b80, 80n) * b80 % P;
      const b240 = pow2(b160, 80n) * b80 % P;
      const b250 = pow2(b240, 10n) * b10 % P;
      const pow_p_5_8 = pow2(b250, 2n) * x % P;
      return { pow_p_5_8, b2 };
    };
    RM1 = 0x2b8324804fc1df0b2b4d00993dfbd7a72f431806ad2fe478c4ee1b274a0ea0b0n;
    uvRatio = (u, v) => {
      const v3 = M(v * v * v);
      const v7 = M(v3 * v3 * v);
      const pow = pow_2_252_3(u * v7).pow_p_5_8;
      let x = M(u * v3 * pow);
      const vx2 = M(v * x * x);
      const root1 = x;
      const root2 = M(x * RM1);
      const useRoot1 = vx2 === u;
      const useRoot2 = vx2 === M(-u);
      const noRoot = vx2 === M(-u * RM1);
      if (useRoot1)
        x = root1;
      if (useRoot2 || noRoot)
        x = root2;
      if ((M(x) & 1n) === 1n)
        x = M(-x);
      return { isValid: useRoot1 || useRoot2, value: x };
    };
    modL_LE = (hash3) => modN(bytesToNumLE(hash3));
    sha512a = (...m) => hashes.sha512Async(concatBytes(...m));
    sha512s = (...m) => callHash("sha512")(concatBytes(...m));
    hash2extK = (hashed) => {
      const head = hashed.slice(0, L);
      head[0] &= 248;
      head[31] &= 127;
      head[31] |= 64;
      const prefix = hashed.slice(L, L2);
      const scalar = modL_LE(head);
      const point = G.multiply(scalar);
      const pointBytes = point.toBytes();
      return { head, prefix, scalar, point, pointBytes };
    };
    getExtendedPublicKeyAsync = (secretKey) => sha512a(abytes(secretKey, L)).then(hash2extK);
    getExtendedPublicKey = (secretKey) => hash2extK(sha512s(abytes(secretKey, L)));
    getPublicKeyAsync = (secretKey) => getExtendedPublicKeyAsync(secretKey).then((p) => p.pointBytes);
    getPublicKey = (priv) => getExtendedPublicKey(priv).pointBytes;
    hashFinishA = (res) => sha512a(res.hashable).then(res.finish);
    hashFinishS = (res) => res.finish(sha512s(res.hashable));
    _sign = (e, rBytes, msg) => {
      const { pointBytes: P2, scalar: s } = e;
      const r = modL_LE(rBytes);
      const R = G.multiply(r).toBytes();
      const hashable = concatBytes(R, P2, msg);
      const finish = (hashed) => {
        const S = modN(r + modL_LE(hashed) * s);
        return abytes(concatBytes(R, numTo32bLE(S)), L2);
      };
      return { hashable, finish };
    };
    signAsync = async (message, secretKey) => {
      const m = abytes(message);
      const e = await getExtendedPublicKeyAsync(secretKey);
      const rBytes = await sha512a(e.prefix, m);
      return hashFinishA(_sign(e, rBytes, m));
    };
    sign = (message, secretKey) => {
      const m = abytes(message);
      const e = getExtendedPublicKey(secretKey);
      const rBytes = sha512s(e.prefix, m);
      return hashFinishS(_sign(e, rBytes, m));
    };
    defaultVerifyOpts = { zip215: true };
    _verify = (sig, msg, pub, opts = defaultVerifyOpts) => {
      sig = abytes(sig, L2);
      msg = abytes(msg);
      pub = abytes(pub, L);
      const { zip215 } = opts;
      let A;
      let R;
      let s;
      let SB;
      let hashable = Uint8Array.of();
      try {
        A = Point.fromBytes(pub, zip215);
        R = Point.fromBytes(sig.slice(0, L), zip215);
        s = bytesToNumLE(sig.slice(L, L2));
        SB = G.multiply(s, false);
        hashable = concatBytes(R.toBytes(), A.toBytes(), msg);
      } catch (error) {
      }
      const finish = (hashed) => {
        if (SB == null)
          return false;
        if (!zip215 && A.isSmallOrder())
          return false;
        const k = modL_LE(hashed);
        const RkA = R.add(A.multiply(k, false));
        return RkA.add(SB.negate()).clearCofactor().is0();
      };
      return { hashable, finish };
    };
    verifyAsync = async (signature, message, publicKey, opts = defaultVerifyOpts) => hashFinishA(_verify(signature, message, publicKey, opts));
    verify = (signature, message, publicKey, opts = defaultVerifyOpts) => hashFinishS(_verify(signature, message, publicKey, opts));
    etc = {
      bytesToHex: bytesToHex2,
      hexToBytes: hexToBytes2,
      concatBytes,
      mod: M,
      invert,
      randomBytes
    };
    hashes = {
      sha512Async: async (message) => {
        const s = subtle();
        const m = concatBytes(message);
        return u8n(await s.digest("SHA-512", m.buffer));
      },
      sha512: void 0
    };
    randomSecretKey = (seed = randomBytes(L)) => seed;
    keygen = (seed) => {
      const secretKey = randomSecretKey(seed);
      const publicKey = getPublicKey(secretKey);
      return { secretKey, publicKey };
    };
    keygenAsync = async (seed) => {
      const secretKey = randomSecretKey(seed);
      const publicKey = await getPublicKeyAsync(secretKey);
      return { secretKey, publicKey };
    };
    utils = {
      getExtendedPublicKeyAsync,
      getExtendedPublicKey,
      randomSecretKey
    };
    W = 8;
    scalarBits = 256;
    pwindows = Math.ceil(scalarBits / W) + 1;
    pwindowSize = 2 ** (W - 1);
    precompute = () => {
      const points = [];
      let p = G;
      let b = p;
      for (let w = 0; w < pwindows; w++) {
        b = p;
        points.push(b);
        for (let i = 1; i < pwindowSize; i++) {
          b = b.add(p);
          points.push(b);
        }
        p = b.double();
      }
      return points;
    };
    Gpows = void 0;
    ctneg = (cnd, p) => {
      const n = p.negate();
      return cnd ? n : p;
    };
    wNAF = (n) => {
      const comp = Gpows || (Gpows = precompute());
      let p = I;
      let f = G;
      const pow_2_w = 2 ** W;
      const maxNum = pow_2_w;
      const mask = big(pow_2_w - 1);
      const shiftBy = big(W);
      for (let w = 0; w < pwindows; w++) {
        let wbits = Number(n & mask);
        n >>= shiftBy;
        if (wbits > pwindowSize) {
          wbits -= maxNum;
          n += 1n;
        }
        const off = w * pwindowSize;
        const offF = off;
        const offP = off + Math.abs(wbits) - 1;
        const isEven = w % 2 !== 0;
        const isNeg = wbits < 0;
        if (wbits === 0) {
          f = f.add(ctneg(isEven, comp[offF]));
        } else {
          p = p.add(ctneg(isNeg, comp[offP]));
        }
      }
      if (n !== 0n)
        err("invalid wnaf");
      return { p, f };
    };
  }
});

// node_modules/base-x/src/cjs/index.cjs
var require_cjs = __commonJS({
  "node_modules/base-x/src/cjs/index.cjs"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    function base(ALPHABET) {
      if (ALPHABET.length >= 255) {
        throw new TypeError("Alphabet too long");
      }
      const BASE_MAP = new Uint8Array(256);
      for (let j = 0; j < BASE_MAP.length; j++) {
        BASE_MAP[j] = 255;
      }
      for (let i = 0; i < ALPHABET.length; i++) {
        const x = ALPHABET.charAt(i);
        const xc = x.charCodeAt(0);
        if (BASE_MAP[xc] !== 255) {
          throw new TypeError(x + " is ambiguous");
        }
        BASE_MAP[xc] = i;
      }
      const BASE = ALPHABET.length;
      const LEADER = ALPHABET.charAt(0);
      const FACTOR = Math.log(BASE) / Math.log(256);
      const iFACTOR = Math.log(256) / Math.log(BASE);
      function encode(source) {
        if (source instanceof Uint8Array) {
        } else if (ArrayBuffer.isView(source)) {
          source = new Uint8Array(source.buffer, source.byteOffset, source.byteLength);
        } else if (Array.isArray(source)) {
          source = Uint8Array.from(source);
        }
        if (!(source instanceof Uint8Array)) {
          throw new TypeError("Expected Uint8Array");
        }
        if (source.length === 0) {
          return "";
        }
        let zeroes = 0;
        let length = 0;
        let pbegin = 0;
        const pend = source.length;
        while (pbegin !== pend && source[pbegin] === 0) {
          pbegin++;
          zeroes++;
        }
        const size = (pend - pbegin) * iFACTOR + 1 >>> 0;
        const b58 = new Uint8Array(size);
        while (pbegin !== pend) {
          let carry = source[pbegin];
          let i = 0;
          for (let it1 = size - 1; (carry !== 0 || i < length) && it1 !== -1; it1--, i++) {
            carry += 256 * b58[it1] >>> 0;
            b58[it1] = carry % BASE >>> 0;
            carry = carry / BASE >>> 0;
          }
          if (carry !== 0) {
            throw new Error("Non-zero carry");
          }
          length = i;
          pbegin++;
        }
        let it2 = size - length;
        while (it2 !== size && b58[it2] === 0) {
          it2++;
        }
        let str = LEADER.repeat(zeroes);
        for (; it2 < size; ++it2) {
          str += ALPHABET.charAt(b58[it2]);
        }
        return str;
      }
      function decodeUnsafe(source) {
        if (typeof source !== "string") {
          throw new TypeError("Expected String");
        }
        if (source.length === 0) {
          return new Uint8Array();
        }
        let psz = 0;
        let zeroes = 0;
        let length = 0;
        while (source[psz] === LEADER) {
          zeroes++;
          psz++;
        }
        const size = (source.length - psz) * FACTOR + 1 >>> 0;
        const b256 = new Uint8Array(size);
        while (psz < source.length) {
          const charCode = source.charCodeAt(psz);
          if (charCode > 255) {
            return;
          }
          let carry = BASE_MAP[charCode];
          if (carry === 255) {
            return;
          }
          let i = 0;
          for (let it3 = size - 1; (carry !== 0 || i < length) && it3 !== -1; it3--, i++) {
            carry += BASE * b256[it3] >>> 0;
            b256[it3] = carry % 256 >>> 0;
            carry = carry / 256 >>> 0;
          }
          if (carry !== 0) {
            throw new Error("Non-zero carry");
          }
          length = i;
          psz++;
        }
        let it4 = size - length;
        while (it4 !== size && b256[it4] === 0) {
          it4++;
        }
        const vch = new Uint8Array(zeroes + (size - it4));
        let j = zeroes;
        while (it4 !== size) {
          vch[j++] = b256[it4++];
        }
        return vch;
      }
      function decode(string) {
        const buffer = decodeUnsafe(string);
        if (buffer) {
          return buffer;
        }
        throw new Error("Non-base" + BASE + " character");
      }
      return {
        encode,
        decodeUnsafe,
        decode
      };
    }
    exports2.default = base;
  }
});

// node_modules/bs58/src/cjs/index.cjs
var require_cjs2 = __commonJS({
  "node_modules/bs58/src/cjs/index.cjs"(exports2) {
    "use strict";
    var __importDefault = exports2 && exports2.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    var base_x_1 = __importDefault(require_cjs());
    var ALPHABET = "123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz";
    exports2.default = (0, base_x_1.default)(ALPHABET);
  }
});

// src/index.ts
var index_exports = {};
__export(index_exports, {
  BackpackAdapter: () => BackpackAdapter,
  BalanceSchema: () => BalanceSchema,
  BaseAdapter: () => BaseAdapter,
  Bulkhead: () => Bulkhead,
  CircuitBreaker: () => CircuitBreaker,
  ConfigurationError: () => ConfigurationError,
  DriftAdapter: () => DriftAdapter,
  DriftAuth: () => DriftAuth,
  DriftNormalizer: () => DriftNormalizer,
  DydxAdapter: () => DydxAdapter,
  DydxAuth: () => DydxAuth,
  DydxNormalizer: () => DydxNormalizer,
  EdgeXAdapter: () => EdgeXAdapter,
  ExchangeUnavailableError: () => ExchangeUnavailableError,
  ExpiredAuthError: () => ExpiredAuthError,
  ExtendedAdapter: () => ExtendedAdapter,
  FundingRateSchema: () => FundingRateSchema,
  GRVTAdapter: () => GRVTAdapter,
  GRVTAuth: () => GRVTAuth,
  GmxAdapter: () => GmxAdapter,
  GmxNormalizer: () => GmxNormalizer,
  HyperliquidAdapter: () => HyperliquidAdapter,
  HyperliquidAuth: () => HyperliquidAuth,
  InsufficientMarginError: () => InsufficientMarginError,
  InsufficientPermissionsError: () => InsufficientPermissionsError,
  InvalidOrderError: () => InvalidOrderError,
  InvalidSignatureError: () => InvalidSignatureError,
  JupiterAdapter: () => JupiterAdapter,
  JupiterAuth: () => JupiterAuth,
  JupiterNormalizer: () => JupiterNormalizer,
  LighterAdapter: () => LighterAdapter,
  LiquidationError: () => LiquidationError,
  LogLevel: () => LogLevel,
  Logger: () => Logger,
  MARGIN_MODES: () => MARGIN_MODES,
  MarketSchema: () => MarketSchema,
  MetricsServer: () => MetricsServer,
  NadoAdapter: () => NadoAdapter,
  ORDER_SIDES: () => ORDER_SIDES,
  ORDER_STATUSES: () => ORDER_STATUSES,
  ORDER_TYPES: () => ORDER_TYPES,
  OrderBookSchema: () => OrderBookSchema,
  OrderNotFoundError: () => OrderNotFoundError,
  OrderRequestSchema: () => OrderRequestSchema,
  OrderSchema: () => OrderSchema,
  POSITION_SIDES: () => POSITION_SIDES,
  ParadexAdapter: () => ParadexAdapter,
  ParadexAuth: () => ParadexAuth,
  PerpDEXError: () => PerpDEXError,
  PositionNotFoundError: () => PositionNotFoundError,
  PositionSchema: () => PositionSchema,
  PrometheusMetrics: () => PrometheusMetrics,
  RateLimitError: () => RateLimitError,
  RateLimiter: () => RateLimiter,
  Resilient: () => Resilient,
  RetryStats: () => RetryStats,
  SlippageExceededError: () => SlippageExceededError,
  TIME_IN_FORCE: () => TIME_IN_FORCE,
  TickerSchema: () => TickerSchema,
  TradeSchema: () => TradeSchema,
  TransactionFailedError: () => TransactionFailedError,
  VERSION: () => VERSION,
  VariationalAdapter: () => VariationalAdapter,
  WebSocketClient: () => WebSocketClient,
  WebSocketDisconnectedError: () => WebSocketDisconnectedError,
  WebSocketManager: () => WebSocketManager,
  allocBuffer: () => allocBuffer,
  buffersEqual: () => buffersEqual,
  buildSymbol: () => buildSymbol,
  bytesToHex: () => bytesToHex,
  calculateAverageEntryPrice: () => calculateAverageEntryPrice,
  calculateBreakEvenPrice: () => calculateBreakEvenPrice,
  calculateEffectiveLeverage: () => calculateEffectiveLeverage,
  calculateFundingPayment: () => calculateFundingPayment2,
  calculateLiquidationPrice: () => calculateLiquidationPrice3,
  calculateMarginRatio: () => calculateMarginRatio,
  calculateMarkToMarket: () => calculateMarkToMarket,
  calculateMaxPositionSize: () => calculateMaxPositionSize,
  calculatePositionValue: () => calculatePositionValue,
  calculateROE: () => calculateROE,
  calculateRequiredMargin: () => calculateRequiredMargin,
  calculateUnrealizedPnl: () => calculateUnrealizedPnl,
  compareSymbols: () => compareSymbols,
  concatBuffers: () => concatBuffers,
  copyBuffer: () => copyBuffer,
  createChildLogger: () => createChildLogger,
  createExchange: () => createExchange,
  createHmacSha256: () => createHmacSha256,
  createRequestContext: () => createRequestContext,
  createResilientExecutor: () => createResilientExecutor,
  createSha256Hash: () => createSha256Hash,
  createSha256HashBuffer: () => createSha256HashBuffer,
  createSha3Hash: () => createSha3Hash,
  createSha3HashBuffer: () => createSha3HashBuffer,
  createSymbol: () => createSymbol,
  createValidator: () => createValidator,
  determineHealthStatus: () => determineHealthStatus,
  filterByBase: () => filterByBase,
  filterByQuote: () => filterByQuote,
  formatLogEntry: () => formatLogEntry,
  fromBuffer: () => fromBuffer,
  generateCorrelationId: () => generateCorrelationId,
  getBaseCurrency: () => getBaseCurrency,
  getConfigErrorMessage: () => getConfigErrorMessage,
  getMetrics: () => getMetrics,
  getQuoteCurrency: () => getQuoteCurrency,
  getRequiredEnvVars: () => getRequiredEnvVars,
  getSettleCurrency: () => getSettleCurrency,
  getSupportedExchanges: () => getSupportedExchanges,
  groupByBase: () => groupByBase,
  hasEnvironmentSupport: () => hasEnvironmentSupport,
  hexToBytes: () => hexToBytes,
  initializeMetrics: () => initializeMetrics,
  isAuthError: () => isAuthError,
  isCriticallyUnhealthy: () => isCriticallyUnhealthy,
  isExchangeSupported: () => isExchangeSupported,
  isHealthy: () => isHealthy,
  isMetricsInitialized: () => isMetricsInitialized,
  isPerpDEXError: () => isPerpDEXError,
  isPerpetual: () => isPerpetual,
  isRateLimitError: () => isRateLimitError,
  isValidApiKey: () => isValidApiKey,
  isValidPrivateKey: () => isValidPrivateKey,
  isValidSymbol: () => isValidSymbol,
  maskSensitive: () => maskSensitive,
  normalizeSymbol: () => normalizeSymbol,
  parseSymbol: () => parseSymbol,
  readBigUInt64BE: () => readBigUInt64BE,
  readBigUInt64LE: () => readBigUInt64LE,
  sliceBuffer: () => sliceBuffer,
  startMetricsServer: () => startMetricsServer,
  toBuffer: () => toBuffer,
  validate: () => validate,
  validateArray: () => validateArray,
  validateArraySimple: () => validateArray,
  validateConfig: () => validateConfig,
  validateData: () => validateData,
  validateMarketParams: () => validateMarketParams,
  validateMultipleConfigs: () => validateMultipleConfigs,
  validateOrderBookParams: () => validateOrderBookParams,
  validateOrderRequest: () => validateOrderRequest,
  validateResponse: () => validateResponse,
  validateSafe: () => validateSafe,
  validateTradeParams: () => validateTradeParams,
  withCache: () => withCache,
  withLinearRetry: () => withLinearRetry,
  withResilience: () => withResilience,
  withRetry: () => withRetry,
  withRetryStats: () => withRetryStats,
  withRetryWrapper: () => withRetryWrapper,
  withTimeout: () => withTimeout,
  writeBigUInt64BE: () => writeBigUInt64BE,
  writeBigUInt64LE: () => writeBigUInt64LE
});
module.exports = __toCommonJS(index_exports);

// src/core/logger.ts
var LogLevel = /* @__PURE__ */ ((LogLevel2) => {
  LogLevel2["DEBUG"] = "debug";
  LogLevel2["INFO"] = "info";
  LogLevel2["WARN"] = "warn";
  LogLevel2["ERROR"] = "error";
  return LogLevel2;
})(LogLevel || {});
var LOG_LEVEL_PRIORITY = {
  ["debug" /* DEBUG */]: 0,
  ["info" /* INFO */]: 1,
  ["warn" /* WARN */]: 2,
  ["error" /* ERROR */]: 3
};
function generateCorrelationId() {
  const timestamp = Date.now().toString(36);
  const random = Math.random().toString(36).substring(2, 10);
  return `${timestamp}-${random}`;
}
function createRequestContext(adapter, method, metadata) {
  return {
    correlationId: generateCorrelationId(),
    adapter,
    method,
    timestamp: Date.now(),
    metadata
  };
}
var Logger = class _Logger {
  context;
  level;
  enabled;
  output;
  maskSensitiveData;
  correlationId;
  constructor(context, config = {}) {
    this.context = context;
    this.level = config.level ?? "info" /* INFO */;
    this.enabled = config.enabled ?? true;
    this.output = config.output ?? this.defaultOutput;
    this.maskSensitiveData = config.maskSensitiveData ?? true;
    this.correlationId = config.correlationId;
  }
  /**
   * Log a debug message
   */
  debug(message, meta) {
    this.log("debug" /* DEBUG */, message, meta);
  }
  /**
   * Log an info message
   */
  info(message, meta) {
    this.log("info" /* INFO */, message, meta);
  }
  /**
   * Log a warning message
   */
  warn(message, meta) {
    this.log("warn" /* WARN */, message, meta);
  }
  /**
   * Log an error message
   *
   * @param message - Error message
   * @param error - Optional error object
   * @param meta - Optional metadata
   */
  error(message, error, meta) {
    const errorMeta = error ? { error: this.serializeError(error) } : {};
    this.log("error" /* ERROR */, message, { ...meta, ...errorMeta });
  }
  /**
   * Set the minimum log level
   */
  setLevel(level) {
    this.level = level;
  }
  /**
   * Enable or disable logging
   */
  setEnabled(enabled) {
    this.enabled = enabled;
  }
  /**
   * Set correlation ID for request tracing
   */
  setCorrelationId(correlationId) {
    this.correlationId = correlationId;
  }
  /**
   * Get current correlation ID
   */
  getCorrelationId() {
    return this.correlationId;
  }
  /**
   * Create a child logger with a specific correlation ID
   */
  withCorrelationId(correlationId) {
    return new _Logger(this.context, {
      level: this.level,
      enabled: this.enabled,
      output: this.output,
      maskSensitiveData: this.maskSensitiveData,
      correlationId
    });
  }
  /**
   * Internal log method
   */
  log(level, message, meta) {
    if (!this.enabled) return;
    if (LOG_LEVEL_PRIORITY[level] < LOG_LEVEL_PRIORITY[this.level]) {
      return;
    }
    const entry = {
      timestamp: (/* @__PURE__ */ new Date()).toISOString(),
      level,
      context: this.context,
      message
    };
    if (this.correlationId) {
      entry.correlationId = this.correlationId;
    }
    if (meta && Object.keys(meta).length > 0) {
      entry.meta = this.maskSensitiveData ? this.maskSensitive(meta) : meta;
    }
    this.output(entry);
  }
  /**
   * Default log output (JSON to console)
   */
  defaultOutput(entry) {
    console.log(JSON.stringify(entry));
  }
  /**
   * Serialize error object for logging
   */
  serializeError(error) {
    return {
      name: error.name,
      message: error.message,
      stack: error.stack,
      code: error.code
    };
  }
  /**
   * Mask sensitive data in metadata
   */
  maskSensitive(data) {
    const masked = {};
    const sensitiveKeys = [
      "privatekey",
      "apikey",
      "apisecret",
      "password",
      "secret",
      "token",
      "auth",
      "authorization",
      "signature"
    ];
    for (const key of Object.keys(data)) {
      const value = data[key];
      const lowerKey = key.toLowerCase();
      const isSensitive = sensitiveKeys.some((sensitive) => lowerKey.includes(sensitive));
      if (isSensitive && typeof value === "string") {
        masked[key] = value.length > 4 ? "***" + value.slice(-4) : "***";
      } else if (isSensitive) {
        masked[key] = "***";
      } else if (typeof value === "object" && value !== null && !Array.isArray(value)) {
        masked[key] = this.maskSensitive(value);
      } else {
        masked[key] = value;
      }
    }
    return masked;
  }
};
function createChildLogger(parent, childContext) {
  const fullContext = `${parent.context}:${childContext}`;
  return new Logger(fullContext, {
    level: parent.level,
    enabled: parent.enabled,
    output: parent.output,
    maskSensitiveData: parent.maskSensitiveData,
    correlationId: parent.correlationId
  });
}
function formatLogEntry(entry) {
  const parts = [
    `[${entry.timestamp}]`,
    entry.level.toUpperCase(),
    `[${entry.context}]`
  ];
  if (entry.correlationId) {
    parts.push(`[${entry.correlationId}]`);
  }
  parts.push(entry.message);
  if (entry.meta) {
    parts.push(JSON.stringify(entry.meta));
  }
  if (entry.error) {
    parts.push(`Error: ${entry.error.message}`);
    if (entry.error.stack) {
      parts.push(`
Stack: ${entry.error.stack}`);
    }
  }
  return parts.join(" ");
}

// src/adapters/hyperliquid/HyperliquidAdapter.ts
var import_ethers2 = require("ethers");

// src/core/RateLimiter.ts
var RateLimiter = class {
  maxTokens;
  windowMs;
  refillRate;
  weights;
  bucket;
  queue = [];
  processingQueue = false;
  destroyed = false;
  pendingTimers = /* @__PURE__ */ new Set();
  constructor(config) {
    this.maxTokens = config.maxTokens;
    this.windowMs = config.windowMs;
    this.refillRate = config.refillRate ?? config.maxTokens;
    this.weights = config.weights ?? {};
    this.bucket = {
      tokens: this.maxTokens,
      lastRefill: Date.now()
    };
  }
  /**
   * Acquire tokens for an operation
   *
   * @param endpoint - Endpoint identifier (for weighted rate limiting)
   * @param weight - Custom weight (overrides endpoint weight)
   * @returns Promise that resolves when tokens are available
   * @throws {RateLimitError} If rate limit exceeded
   */
  async acquire(endpoint, weight) {
    const requestWeight = weight ?? (endpoint ? this.weights[endpoint] ?? 1 : 1);
    return new Promise((resolve, reject) => {
      this.queue.push({
        weight: requestWeight,
        resolve,
        reject
      });
      void this.processQueue();
    });
  }
  /**
   * Try to acquire tokens without waiting
   *
   * @param endpoint - Endpoint identifier
   * @param weight - Custom weight
   * @returns true if tokens acquired, false otherwise
   */
  tryAcquire(endpoint, weight) {
    const requestWeight = weight ?? (endpoint ? this.weights[endpoint] ?? 1 : 1);
    this.refillBucket();
    if (this.bucket.tokens >= requestWeight) {
      this.bucket.tokens -= requestWeight;
      return true;
    }
    return false;
  }
  /**
   * Get current available tokens
   */
  getAvailableTokens() {
    this.refillBucket();
    return this.bucket.tokens;
  }
  /**
   * Get time until next token refill (ms)
   */
  getTimeUntilRefill() {
    const elapsed = Date.now() - this.bucket.lastRefill;
    const remaining = this.windowMs - elapsed;
    return Math.max(0, remaining);
  }
  /**
   * Reset rate limiter
   */
  reset() {
    this.bucket = {
      tokens: this.maxTokens,
      lastRefill: Date.now()
    };
    this.queue.length = 0;
  }
  /**
   * Process queued requests
   */
  async processQueue() {
    if (this.processingQueue || this.destroyed) {
      return;
    }
    this.processingQueue = true;
    while (this.queue.length > 0 && !this.destroyed) {
      this.refillBucket();
      const request = this.queue[0];
      if (!request) break;
      if (this.bucket.tokens >= request.weight) {
        this.bucket.tokens -= request.weight;
        this.queue.shift();
        request.resolve();
      } else {
        const waitTime = this.getTimeUntilRefill();
        if (waitTime > 0) {
          await this.sleep(Math.min(waitTime, 100));
        } else {
          this.refillBucket();
        }
      }
    }
    this.processingQueue = false;
  }
  /**
   * Refill token bucket based on elapsed time
   */
  refillBucket() {
    const now = Date.now();
    const elapsed = now - this.bucket.lastRefill;
    if (elapsed >= this.windowMs) {
      const fullWindows = Math.floor(elapsed / this.windowMs);
      this.bucket.tokens = Math.min(
        this.maxTokens,
        this.bucket.tokens + fullWindows * this.refillRate
      );
      this.bucket.lastRefill = now - elapsed % this.windowMs;
    }
  }
  /**
   * Sleep helper with timer tracking for cleanup
   */
  sleep(ms) {
    return new Promise((resolve) => {
      const timer = setTimeout(() => {
        this.pendingTimers.delete(timer);
        resolve();
      }, ms);
      if (timer.unref) {
        timer.unref();
      }
      this.pendingTimers.add(timer);
    });
  }
  /**
   * Destroy rate limiter and cancel pending operations
   */
  destroy() {
    this.destroyed = true;
    for (const timer of this.pendingTimers) {
      clearTimeout(timer);
    }
    this.pendingTimers.clear();
    const queuedRequests = [...this.queue];
    this.queue.length = 0;
    for (const request of queuedRequests) {
      request.reject(new Error("RateLimiter destroyed"));
    }
    this.processingQueue = false;
  }
  /**
   * Get rate limiter statistics
   */
  getStats() {
    return {
      availableTokens: this.getAvailableTokens(),
      maxTokens: this.maxTokens,
      queueLength: this.queue.length,
      timeUntilRefill: this.getTimeUntilRefill()
    };
  }
};

// src/types/errors.ts
var PerpDEXError = class _PerpDEXError extends Error {
  constructor(message, code, exchange, originalError) {
    super(message);
    this.code = code;
    this.exchange = exchange;
    this.originalError = originalError;
    this.name = "PerpDEXError";
    Object.setPrototypeOf(this, _PerpDEXError.prototype);
  }
  /** Correlation ID for request tracing */
  correlationId;
  /**
   * Set correlation ID for this error
   */
  withCorrelationId(correlationId) {
    this.correlationId = correlationId;
    return this;
  }
  toJSON() {
    return {
      name: this.name,
      message: this.message,
      code: this.code,
      exchange: this.exchange,
      correlationId: this.correlationId,
      originalError: this.originalError
    };
  }
};
var NotSupportedError = class _NotSupportedError extends PerpDEXError {
  constructor(message, code, exchange, originalError) {
    super(message, code, exchange, originalError);
    this.name = "NotSupportedError";
    Object.setPrototypeOf(this, _NotSupportedError.prototype);
  }
};
var InsufficientMarginError = class _InsufficientMarginError extends PerpDEXError {
  constructor(message, code, exchange, originalError) {
    super(message, code, exchange, originalError);
    this.name = "InsufficientMarginError";
    Object.setPrototypeOf(this, _InsufficientMarginError.prototype);
  }
};
var OrderNotFoundError = class _OrderNotFoundError extends PerpDEXError {
  constructor(message, code, exchange, originalError) {
    super(message, code, exchange, originalError);
    this.name = "OrderNotFoundError";
    Object.setPrototypeOf(this, _OrderNotFoundError.prototype);
  }
};
var InvalidOrderError = class _InvalidOrderError extends PerpDEXError {
  constructor(message, code, exchange, originalError) {
    super(message, code, exchange, originalError);
    this.name = "InvalidOrderError";
    Object.setPrototypeOf(this, _InvalidOrderError.prototype);
  }
};
var PositionNotFoundError = class _PositionNotFoundError extends PerpDEXError {
  constructor(message, code, exchange, originalError) {
    super(message, code, exchange, originalError);
    this.name = "PositionNotFoundError";
    Object.setPrototypeOf(this, _PositionNotFoundError.prototype);
  }
};
var NetworkError = class _NetworkError extends PerpDEXError {
  constructor(message, code, exchange, originalError) {
    super(message, code, exchange, originalError);
    this.name = "NetworkError";
    Object.setPrototypeOf(this, _NetworkError.prototype);
  }
};
var RateLimitError = class _RateLimitError extends PerpDEXError {
  constructor(message, code, exchange, retryAfter, originalError) {
    super(message, code, exchange, originalError);
    this.retryAfter = retryAfter;
    this.name = "RateLimitError";
    Object.setPrototypeOf(this, _RateLimitError.prototype);
  }
};
var ExchangeUnavailableError = class _ExchangeUnavailableError extends PerpDEXError {
  constructor(message, code, exchange, originalError) {
    super(message, code, exchange, originalError);
    this.name = "ExchangeUnavailableError";
    Object.setPrototypeOf(this, _ExchangeUnavailableError.prototype);
  }
};
var WebSocketDisconnectedError = class _WebSocketDisconnectedError extends PerpDEXError {
  constructor(message, code, exchange, originalError) {
    super(message, code, exchange, originalError);
    this.name = "WebSocketDisconnectedError";
    Object.setPrototypeOf(this, _WebSocketDisconnectedError.prototype);
  }
};
var InvalidSignatureError = class _InvalidSignatureError extends PerpDEXError {
  constructor(message, code, exchange, originalError) {
    super(message, code, exchange, originalError);
    this.name = "InvalidSignatureError";
    Object.setPrototypeOf(this, _InvalidSignatureError.prototype);
  }
};
var ExpiredAuthError = class _ExpiredAuthError extends PerpDEXError {
  constructor(message, code, exchange, originalError) {
    super(message, code, exchange, originalError);
    this.name = "ExpiredAuthError";
    Object.setPrototypeOf(this, _ExpiredAuthError.prototype);
  }
};
var InsufficientPermissionsError = class _InsufficientPermissionsError extends PerpDEXError {
  constructor(message, code, exchange, originalError) {
    super(message, code, exchange, originalError);
    this.name = "InsufficientPermissionsError";
    Object.setPrototypeOf(this, _InsufficientPermissionsError.prototype);
  }
};
var InvalidSymbolError = class _InvalidSymbolError extends PerpDEXError {
  constructor(message, code, exchange, originalError) {
    super(message, code, exchange, originalError);
    this.name = "InvalidSymbolError";
    Object.setPrototypeOf(this, _InvalidSymbolError.prototype);
  }
};
var InsufficientBalanceError = class _InsufficientBalanceError extends PerpDEXError {
  constructor(message, code, exchange, required, available, originalError) {
    super(message, code, exchange, originalError);
    this.required = required;
    this.available = available;
    this.name = "InsufficientBalanceError";
    Object.setPrototypeOf(this, _InsufficientBalanceError.prototype);
  }
};
var TransactionFailedError = class _TransactionFailedError extends PerpDEXError {
  constructor(message, code, exchange, txHash, originalError) {
    super(message, code, exchange, originalError);
    this.txHash = txHash;
    this.name = "TransactionFailedError";
    Object.setPrototypeOf(this, _TransactionFailedError.prototype);
  }
};
var SlippageExceededError = class _SlippageExceededError extends PerpDEXError {
  constructor(message, code, exchange, expectedPrice, actualPrice, originalError) {
    super(message, code, exchange, originalError);
    this.expectedPrice = expectedPrice;
    this.actualPrice = actualPrice;
    this.name = "SlippageExceededError";
    Object.setPrototypeOf(this, _SlippageExceededError.prototype);
  }
};
var LiquidationError = class _LiquidationError extends PerpDEXError {
  constructor(message, code, exchange, originalError) {
    super(message, code, exchange, originalError);
    this.name = "LiquidationError";
    Object.setPrototypeOf(this, _LiquidationError.prototype);
  }
};
function isPerpDEXError(error) {
  return error instanceof PerpDEXError;
}
function isRateLimitError(error) {
  return error instanceof RateLimitError;
}
function isAuthError(error) {
  return error instanceof InvalidSignatureError || error instanceof ExpiredAuthError || error instanceof InsufficientPermissionsError;
}

// node_modules/eventemitter3/index.mjs
var import_index = __toESM(require_eventemitter3(), 1);

// src/websocket/WebSocketClient.ts
var isBrowser = typeof window !== "undefined" && typeof window.WebSocket !== "undefined";
var WS = null;
async function loadWsModule() {
  if (typeof require === "function") {
    try {
      return require("ws");
    } catch {
    }
  }
  const { createRequire } = await import("module");
  const { pathToFileURL } = await import("url");
  const baseUrl = typeof __filename !== "undefined" ? pathToFileURL(__filename).href : pathToFileURL(process.cwd() + "/index.js").href;
  const esmRequire = createRequire(baseUrl);
  return esmRequire("ws");
}
async function getWebSocketClass() {
  if (WS) {
    return WS;
  }
  if (isBrowser) {
    WS = window.WebSocket;
  } else {
    WS = await loadWsModule();
  }
  return WS;
}
var DEFAULT_RECONNECT_CONFIG = {
  enabled: true,
  maxAttempts: 10,
  initialDelay: 500,
  maxDelay: 3e4,
  multiplier: 2,
  jitter: 0.1
};
var DEFAULT_HEARTBEAT_CONFIG = {
  enabled: true,
  interval: 3e4,
  timeout: 5e3,
  pingMessage: JSON.stringify({ type: "ping" })
};
var WebSocketClient = class extends import_index.default {
  ws = null;
  state = "disconnected";
  reconnectAttempts = 0;
  reconnectTimer = null;
  heartbeatTimer = null;
  heartbeatTimeoutTimer = null;
  connectTimestamp = 0;
  messagesSent = 0;
  messagesReceived = 0;
  shouldReconnect = true;
  url;
  reconnectConfig;
  heartbeatConfig;
  constructor(config) {
    super();
    this.url = config.url;
    this.reconnectConfig = { ...DEFAULT_RECONNECT_CONFIG, ...config.reconnect };
    this.heartbeatConfig = { ...DEFAULT_HEARTBEAT_CONFIG, ...config.heartbeat };
    if (config.onMessage) {
      this.on("message", config.onMessage);
    }
    if (config.onStateChange) {
      this.on("stateChange", config.onStateChange);
    }
    if (config.onError) {
      this.on("error", config.onError);
    }
  }
  /**
   * Get current connection state
   */
  getState() {
    return this.state;
  }
  /**
   * Check if connected
   * Note: WebSocket.OPEN = 1 is a constant across all implementations
   */
  isConnected() {
    return this.state === "connected" && this.ws?.readyState === 1;
  }
  /**
   * Get connection metrics
   */
  getMetrics() {
    return {
      messagesReceived: this.messagesReceived,
      messagesSent: this.messagesSent,
      reconnectAttempts: this.reconnectAttempts,
      state: this.state,
      uptime: this.connectTimestamp > 0 ? Date.now() - this.connectTimestamp : 0,
      activeSubscriptions: 0
      // Will be tracked by WebSocketManager
    };
  }
  /**
   * Connect to WebSocket server
   */
  async connect() {
    if (this.state === "connecting" || this.state === "connected") {
      return;
    }
    this.shouldReconnect = true;
    await this.createConnection();
  }
  /**
   * Disconnect from WebSocket server
   */
  async disconnect() {
    this.shouldReconnect = false;
    this.clearReconnectTimer();
    this.stopHeartbeat();
    if (this.ws) {
      this.setState("disconnecting");
      this.ws.close();
      this.ws = null;
    }
    this.setState("disconnected");
  }
  /**
   * Send message through WebSocket
   */
  send(data) {
    if (!this.isConnected()) {
      throw new Error("WebSocket is not connected");
    }
    const message = typeof data === "string" ? data : JSON.stringify(data);
    this.ws.send(message);
    this.messagesSent++;
  }
  /**
   * Create WebSocket connection
   * Supports both Node.js (ws package) and browser (native WebSocket)
   */
  async createConnection() {
    const WebSocketClass = await getWebSocketClass();
    return new Promise((resolve, reject) => {
      try {
        this.setState("connecting");
        this.ws = new WebSocketClass(this.url);
        if (isBrowser) {
          const browserWs = this.ws;
          browserWs.onopen = () => {
            this.handleOpen();
            resolve();
          };
          browserWs.onmessage = (event) => {
            this.handleMessage(event.data);
          };
          browserWs.onclose = () => {
            this.handleClose();
          };
          browserWs.onerror = () => {
            const error = new Error("WebSocket error");
            this.handleError(error);
            reject(error);
          };
        } else {
          const ws = this.ws;
          ws.on("open", () => {
            this.handleOpen();
            resolve();
          });
          ws.on("message", (data) => {
            this.handleMessage(data);
          });
          ws.on("close", () => {
            this.handleClose();
          });
          ws.on("error", (error) => {
            this.handleError(error);
            reject(error);
          });
          ws.on("pong", () => {
            this.handlePong();
          });
        }
      } catch (error) {
        this.handleError(error instanceof Error ? error : new Error(String(error)));
        reject(error);
      }
    });
  }
  /**
   * Handle connection open
   */
  handleOpen() {
    this.setState("connected");
    this.connectTimestamp = Date.now();
    if (this.reconnectAttempts > 0) {
      this.emit("reconnected");
    }
    this.reconnectAttempts = 0;
    this.emit("open");
    this.startHeartbeat();
  }
  /**
   * Handle incoming message
   * Supports both Node.js Buffer and browser string/ArrayBuffer
   */
  handleMessage(data) {
    try {
      this.messagesReceived++;
      let message;
      if (typeof data === "string") {
        message = data;
      } else if (data instanceof ArrayBuffer) {
        message = new TextDecoder().decode(data);
      } else if (typeof Buffer !== "undefined" && Buffer.isBuffer(data)) {
        message = data.toString();
      } else {
        message = String(data);
      }
      try {
        const parsed = JSON.parse(message);
        this.emit("message", parsed);
      } catch {
        this.emit("message", message);
      }
    } catch (error) {
      this.emit("error", new Error(`Failed to handle message: ${error}`));
    }
  }
  /**
   * Handle connection close
   */
  handleClose() {
    this.stopHeartbeat();
    this.emit("close");
    if (this.shouldReconnect && this.reconnectConfig.enabled) {
      this.scheduleReconnect();
    } else {
      this.setState("disconnected");
    }
  }
  /**
   * Handle connection error
   */
  handleError(error) {
    this.emit("error", error);
  }
  /**
   * Handle pong response (heartbeat)
   */
  handlePong() {
    if (this.heartbeatTimeoutTimer) {
      clearTimeout(this.heartbeatTimeoutTimer);
      this.heartbeatTimeoutTimer = null;
    }
  }
  /**
   * Schedule reconnection attempt
   */
  scheduleReconnect() {
    this.reconnectAttempts++;
    if (this.reconnectConfig.maxAttempts > 0 && this.reconnectAttempts > this.reconnectConfig.maxAttempts) {
      this.emit("maxRetriesExceeded");
      this.setState("disconnected");
      this.shouldReconnect = false;
      return;
    }
    const delay = this.calculateReconnectDelay();
    this.emit("reconnecting", this.reconnectAttempts);
    this.reconnectTimer = setTimeout(() => {
      this.createConnection().catch((error) => {
        this.emit("error", error instanceof Error ? error : new Error(String(error)));
        if (this.shouldReconnect && this.reconnectConfig.enabled) {
          this.scheduleReconnect();
        }
      });
    }, delay);
  }
  /**
   * Calculate reconnect delay with exponential backoff and jitter
   */
  calculateReconnectDelay() {
    const { initialDelay, maxDelay, multiplier, jitter } = this.reconnectConfig;
    const exponentialDelay = Math.min(
      initialDelay * Math.pow(multiplier, this.reconnectAttempts - 1),
      maxDelay
    );
    const jitterAmount = exponentialDelay * jitter * (Math.random() - 0.5);
    return Math.max(0, exponentialDelay + jitterAmount);
  }
  /**
   * Start heartbeat/ping mechanism
   * In browsers, we rely on application-level ping messages since
   * the WebSocket API doesn't expose ping/pong frames.
   */
  startHeartbeat() {
    if (!this.heartbeatConfig.enabled) {
      return;
    }
    this.stopHeartbeat();
    this.heartbeatTimer = setInterval(() => {
      if (this.isConnected()) {
        try {
          if (this.heartbeatConfig.pingMessage) {
            this.send(this.heartbeatConfig.pingMessage);
          } else if (!isBrowser) {
            this.sendPing();
          }
          if (this.heartbeatConfig.pingMessage || !isBrowser) {
            this.heartbeatTimeoutTimer = setTimeout(() => {
              this.emit("error", new Error("Heartbeat timeout - no pong received"));
              this.terminateConnection();
            }, this.heartbeatConfig.timeout);
          }
        } catch (error) {
          this.emit("error", new Error(`Heartbeat failed: ${error}`));
        }
      }
    }, this.heartbeatConfig.interval);
  }
  /**
   * Send WebSocket ping frame (Node.js only)
   */
  sendPing() {
    if (this.ws && "ping" in this.ws && typeof this.ws.ping === "function") {
      this.ws.ping();
    }
  }
  /**
   * Forcefully terminate the connection
   * Uses terminate() on Node.js, close() on browsers
   */
  terminateConnection() {
    if (this.ws) {
      if ("terminate" in this.ws && typeof this.ws.terminate === "function") {
        this.ws.terminate();
      } else {
        this.ws.close();
      }
    }
  }
  /**
   * Stop heartbeat mechanism
   */
  stopHeartbeat() {
    if (this.heartbeatTimer) {
      clearInterval(this.heartbeatTimer);
      this.heartbeatTimer = null;
    }
    if (this.heartbeatTimeoutTimer) {
      clearTimeout(this.heartbeatTimeoutTimer);
      this.heartbeatTimeoutTimer = null;
    }
  }
  /**
   * Clear reconnect timer
   */
  clearReconnectTimer() {
    if (this.reconnectTimer) {
      clearTimeout(this.reconnectTimer);
      this.reconnectTimer = null;
    }
  }
  /**
   * Update connection state
   */
  setState(newState) {
    if (this.state !== newState) {
      this.state = newState;
      this.emit("stateChange", newState);
    }
  }
};

// src/websocket/WebSocketManager.ts
var MAX_QUEUE_SIZE = 1e3;
var WebSocketManager = class extends import_index.default {
  constructor(config) {
    super();
    this.config = config;
  }
  client = null;
  subscriptions = /* @__PURE__ */ new Map();
  messageQueue = [];
  isResubscribing = false;
  droppedMessageCount = 0;
  /**
   * Get the number of messages dropped due to queue overflow
   */
  getDroppedMessageCount() {
    return this.droppedMessageCount;
  }
  /**
   * Reset the dropped message counter
   */
  resetDroppedMessageCount() {
    this.droppedMessageCount = 0;
  }
  /**
   * Initialize connection
   */
  async connect() {
    if (this.client) {
      return;
    }
    this.client = new WebSocketClient({
      ...this.config,
      onMessage: (data) => this.handleMessage(data),
      onError: (error) => this.emit("error", error)
    });
    this.client.on("reconnected", () => {
      void this.resubscribeAll();
    });
    await this.client.connect();
  }
  /**
   * Disconnect and cleanup
   */
  async disconnect() {
    if (!this.client) {
      return;
    }
    this.subscriptions.clear();
    this.messageQueue = [];
    await this.client.disconnect();
    this.client = null;
  }
  /**
   * Check if connected
   */
  isConnected() {
    return this.client?.isConnected() ?? false;
  }
  /**
   * Subscribe to a channel
   *
   * @param channel - Channel identifier
   * @param subscriptionMessage - Subscription message to send
   * @param handler - Message handler for this subscription
   * @returns Subscription ID
   */
  async subscribe(channel, subscriptionMessage, handler) {
    if (!this.client) {
      throw new WebSocketDisconnectedError(
        "WebSocket not initialized",
        "WS_NOT_INITIALIZED",
        "unknown"
      );
    }
    const subscriptionId = `${channel}_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;
    const subscription = {
      id: subscriptionId,
      channel,
      handler,
      active: true,
      timestamp: Date.now(),
      params: subscriptionMessage
    };
    this.subscriptions.set(subscriptionId, subscription);
    if (this.isConnected()) {
      try {
        this.client.send(subscriptionMessage);
        this.emit("subscribed", subscription);
      } catch (error) {
        this.subscriptions.delete(subscriptionId);
        throw new WebSocketDisconnectedError(
          `Failed to subscribe to ${channel}`,
          "SUBSCRIPTION_FAILED",
          "unknown",
          error
        );
      }
    } else {
      this.messageQueue.push({ channel, data: subscriptionMessage });
    }
    return subscriptionId;
  }
  /**
   * Unsubscribe from a channel
   *
   * @param subscriptionId - Subscription ID to remove
   * @param unsubscribeMessage - Optional unsubscribe message
   */
  async unsubscribe(subscriptionId, unsubscribeMessage) {
    const subscription = this.subscriptions.get(subscriptionId);
    if (!subscription) {
      return;
    }
    subscription.active = false;
    if (unsubscribeMessage && this.isConnected() && this.client) {
      try {
        this.client.send(unsubscribeMessage);
      } catch (error) {
        this.emit("error", new Error(`Failed to unsubscribe: ${error}`));
      }
    }
    this.subscriptions.delete(subscriptionId);
    this.emit("unsubscribed", subscriptionId);
  }
  /**
   * Unsubscribe from all subscriptions
   */
  async unsubscribeAll() {
    const subscriptionIds = Array.from(this.subscriptions.keys());
    for (const id of subscriptionIds) {
      await this.unsubscribe(id);
    }
  }
  /**
   * Get active subscription count
   */
  getSubscriptionCount() {
    return Array.from(this.subscriptions.values()).filter((sub) => sub.active).length;
  }
  /**
   * Create async generator for subscribing to a channel
   *
   * @param channel - Channel identifier
   * @param subscriptionMessage - Subscription message to send
   * @param unsubscribeMessage - Optional unsubscribe message
   * @returns Async generator yielding channel messages
   */
  async *watch(channel, subscriptionMessage, unsubscribeMessage) {
    const messageQueue = [];
    let resolveNext = null;
    let subscriptionId = null;
    let localDroppedCount = 0;
    subscriptionId = await this.subscribe(channel, subscriptionMessage, (data) => {
      const typedData = data;
      if (resolveNext) {
        resolveNext(typedData);
        resolveNext = null;
      } else {
        if (messageQueue.length >= MAX_QUEUE_SIZE) {
          messageQueue.shift();
          localDroppedCount++;
          this.droppedMessageCount++;
          this.emit("queueOverflow", channel, localDroppedCount);
        }
        messageQueue.push(typedData);
      }
    });
    try {
      while (true) {
        if (messageQueue.length > 0) {
          yield messageQueue.shift();
        } else {
          yield await new Promise((resolve) => {
            resolveNext = resolve;
          });
        }
      }
    } finally {
      if (subscriptionId) {
        await this.unsubscribe(subscriptionId, unsubscribeMessage);
      }
    }
  }
  /**
   * Handle incoming WebSocket message
   */
  handleMessage(data) {
    try {
      const message = this.parseMessage(data);
      for (const subscription of this.subscriptions.values()) {
        if (subscription.active && this.messageMatchesSubscription(message, subscription)) {
          try {
            subscription.handler(message.data);
          } catch (error) {
            this.emit("error", new Error(`Subscription handler error: ${error}`));
          }
        }
      }
      if (message.channel) {
        this.emit("message", message.channel, message.data);
      }
    } catch (error) {
      this.emit("error", new Error(`Failed to handle message: ${error}`));
    }
  }
  /**
   * Parse incoming message into structured format
   */
  parseMessage(data) {
    const parsed = typeof data === "string" ? JSON.parse(data) : data;
    return {
      type: parsed.type ?? "unknown",
      channel: parsed.channel,
      data: parsed,
      timestamp: Date.now(),
      sequenceId: parsed.sequenceId
    };
  }
  /**
   * Check if message matches subscription
   */
  messageMatchesSubscription(message, subscription) {
    return message.channel === subscription.channel;
  }
  /**
   * Resubscribe to all active subscriptions
   */
  async resubscribeAll() {
    if (this.isResubscribing || !this.isConnected() || !this.client) {
      return;
    }
    this.isResubscribing = true;
    try {
      for (const { data } of this.messageQueue) {
        try {
          this.client.send(data);
        } catch (error) {
          this.emit("error", new Error(`Failed to send queued message: ${error}`));
        }
      }
      this.messageQueue = [];
      for (const subscription of this.subscriptions.values()) {
        if (subscription.active && subscription.params) {
          try {
            this.client.send(subscription.params);
          } catch (error) {
            this.emit(
              "error",
              new Error(`Failed to resubscribe to ${subscription.channel}: ${error}`)
            );
          }
        }
      }
      this.emit("reconnected");
    } finally {
      this.isResubscribing = false;
    }
  }
};

// src/types/health.ts
function determineHealthStatus(apiReachable, wsConnected, authValid) {
  if (!apiReachable) {
    return "unhealthy";
  }
  if (authValid === false) {
    return "degraded";
  }
  if (wsConnected === false) {
    return "degraded";
  }
  return "healthy";
}
function isHealthy(status) {
  return status === "healthy" || status === "degraded";
}
function isCriticallyUnhealthy(result) {
  return result.status === "unhealthy" || !result.api.reachable;
}

// src/types/metrics.ts
function createMetricsSnapshot(metrics) {
  const { totalRequests, successfulRequests, failedRequests, rateLimitHits, averageLatency, endpointStats, startedAt } = metrics;
  const successRate = totalRequests > 0 ? successfulRequests / totalRequests : 0;
  const errorRate = totalRequests > 0 ? failedRequests / totalRequests : 0;
  const endpoints = Array.from(endpointStats.values()).map((stats) => ({
    endpoint: stats.endpoint,
    count: stats.count,
    averageLatency: stats.count > 0 ? stats.totalLatency / stats.count : 0,
    errorRate: stats.count > 0 ? stats.errors / stats.count : 0
  }));
  endpoints.sort((a, b) => b.count - a.count);
  return {
    totalRequests,
    successfulRequests,
    failedRequests,
    rateLimitHits,
    averageLatency,
    successRate,
    errorRate,
    endpoints,
    collectionDuration: Date.now() - startedAt,
    timestamp: Date.now()
  };
}

// src/core/CircuitBreaker.ts
var DEFAULT_CONFIG = {
  failureThreshold: 5,
  successThreshold: 2,
  timeWindow: 6e4,
  // 1 minute
  resetTimeout: 3e4,
  // 30 seconds
  minimumRequestVolume: 10,
  errorThresholdPercentage: 0.5
  // 50%
};
var CircuitBreaker = class extends import_index.default {
  state = "CLOSED";
  failureCount = 0;
  successCount = 0;
  totalRequests = 0;
  lastStateChangeTime = Date.now();
  resetTimer = null;
  requestTimestamps = [];
  config;
  constructor(config = {}) {
    super();
    this.config = { ...DEFAULT_CONFIG, ...config };
  }
  /**
   * Execute a function with circuit breaker protection
   */
  async execute(fn) {
    if (!this.canExecute()) {
      this.recordRejection();
      throw new CircuitBreakerError(
        "Circuit breaker is OPEN",
        "CIRCUIT_OPEN",
        this.state
      );
    }
    try {
      const result = await fn();
      this.recordSuccess();
      return result;
    } catch (error) {
      this.recordFailure(error);
      throw error;
    }
  }
  /**
   * Check if circuit allows request execution
   */
  canExecute() {
    if (this.state === "CLOSED") {
      return true;
    }
    if (this.state === "OPEN") {
      const now = Date.now();
      if (now - this.lastStateChangeTime >= this.config.resetTimeout) {
        this.transitionToHalfOpen();
        return true;
      }
      return false;
    }
    return true;
  }
  /**
   * Record successful execution
   */
  recordSuccess() {
    this.totalRequests++;
    this.successCount++;
    this.cleanupOldTimestamps();
    this.requestTimestamps.push(Date.now());
    this.emit("success");
    if (this.state === "HALF_OPEN") {
      if (this.successCount >= this.config.successThreshold) {
        this.transitionToClosed();
      }
    } else if (this.state === "CLOSED") {
      this.failureCount = 0;
    }
  }
  /**
   * Record failed execution
   */
  recordFailure(error) {
    this.totalRequests++;
    this.failureCount++;
    this.cleanupOldTimestamps();
    this.requestTimestamps.push(Date.now());
    this.emit("failure", error);
    if (this.state === "HALF_OPEN") {
      this.transitionToOpen();
    } else if (this.state === "CLOSED") {
      this.checkThresholds();
    }
  }
  /**
   * Record rejected request
   */
  recordRejection() {
    this.emit("reject");
  }
  /**
   * Check if failure thresholds are exceeded
   */
  checkThresholds() {
    const recentRequests = this.getRecentRequestCount();
    if (recentRequests < this.config.minimumRequestVolume) {
      return;
    }
    if (this.failureCount >= this.config.failureThreshold) {
      this.transitionToOpen();
      return;
    }
    const errorRate = this.calculateErrorRate();
    if (errorRate >= this.config.errorThresholdPercentage) {
      this.transitionToOpen();
    }
  }
  /**
   * Calculate current error rate
   */
  calculateErrorRate() {
    const recentRequests = this.getRecentRequestCount();
    if (recentRequests === 0) {
      return 0;
    }
    return this.failureCount / recentRequests;
  }
  /**
   * Get count of recent requests within time window
   */
  getRecentRequestCount() {
    this.cleanupOldTimestamps();
    return this.requestTimestamps.length;
  }
  /**
   * Remove timestamps outside the time window
   */
  cleanupOldTimestamps() {
    const cutoff = Date.now() - this.config.timeWindow;
    this.requestTimestamps = this.requestTimestamps.filter((ts) => ts >= cutoff);
  }
  /**
   * Transition to OPEN state
   */
  transitionToOpen() {
    const oldState = this.state;
    this.state = "OPEN";
    this.lastStateChangeTime = Date.now();
    this.successCount = 0;
    this.scheduleReset();
    this.emit("stateChange", oldState, "OPEN");
    this.emit("open");
  }
  /**
   * Transition to HALF_OPEN state
   */
  transitionToHalfOpen() {
    const oldState = this.state;
    this.state = "HALF_OPEN";
    this.lastStateChangeTime = Date.now();
    this.successCount = 0;
    this.failureCount = 0;
    this.clearResetTimer();
    this.emit("stateChange", oldState, "HALF_OPEN");
    this.emit("halfOpen");
  }
  /**
   * Transition to CLOSED state
   */
  transitionToClosed() {
    const oldState = this.state;
    this.state = "CLOSED";
    this.lastStateChangeTime = Date.now();
    this.successCount = 0;
    this.failureCount = 0;
    this.requestTimestamps = [];
    this.clearResetTimer();
    this.emit("stateChange", oldState, "CLOSED");
    this.emit("close");
  }
  /**
   * Schedule automatic reset attempt
   */
  scheduleReset() {
    this.clearResetTimer();
    this.resetTimer = setTimeout(() => {
      if (this.state === "OPEN") {
        this.transitionToHalfOpen();
      }
    }, this.config.resetTimeout);
  }
  /**
   * Clear reset timer
   */
  clearResetTimer() {
    if (this.resetTimer) {
      clearTimeout(this.resetTimer);
      this.resetTimer = null;
    }
  }
  /**
   * Get current state
   */
  getState() {
    return this.state;
  }
  /**
   * Get current metrics
   */
  getMetrics() {
    this.getRecentRequestCount();
    const recentFailures = this.failureCount;
    const recentSuccesses = this.successCount;
    return {
      state: this.state,
      totalRequests: this.totalRequests,
      successfulRequests: recentSuccesses,
      failedRequests: recentFailures,
      rejectedRequests: 0,
      // Could track separately if needed
      errorRate: this.calculateErrorRate(),
      lastStateChange: this.lastStateChangeTime,
      consecutiveSuccesses: this.state === "HALF_OPEN" ? this.successCount : 0,
      consecutiveFailures: this.state === "CLOSED" ? this.failureCount : 0
    };
  }
  /**
   * Reset circuit breaker to initial state
   */
  reset() {
    this.transitionToClosed();
  }
  /**
   * Force circuit to OPEN state
   */
  forceOpen() {
    this.transitionToOpen();
  }
  /**
   * Force circuit to CLOSED state
   */
  forceClosed() {
    this.transitionToClosed();
  }
  /**
   * Cleanup resources
   */
  destroy() {
    this.clearResetTimer();
    this.removeAllListeners();
  }
};
var CircuitBreakerError = class extends Error {
  constructor(message, code, state) {
    super(message);
    this.code = code;
    this.state = state;
    this.name = "CircuitBreakerError";
  }
};

// src/monitoring/prometheus.ts
var import_prom_client = require("prom-client");
var PrometheusMetrics = class {
  registry;
  prefix;
  // Request metrics
  requestCounter;
  requestDuration;
  requestErrorCounter;
  // Circuit breaker metrics
  circuitBreakerStateGauge;
  circuitBreakerTransitionCounter;
  circuitBreakerFailureCounter;
  circuitBreakerSuccessCounter;
  // WebSocket metrics
  wsConnectionGauge;
  wsMessageCounter;
  wsReconnectCounter;
  wsErrorCounter;
  // Order metrics
  orderCounter;
  orderLatency;
  orderRejectionCounter;
  // Market data metrics
  marketDataLatency;
  marketDataUpdateCounter;
  // Retry metrics
  retryCounter;
  retryAttemptsHistogram;
  // Cache metrics
  cacheHitCounter;
  cacheMissCounter;
  constructor(config = {}) {
    this.prefix = config.metricPrefix || "perpdex_";
    this.registry = config.registry || new import_prom_client.Registry();
    if (config.defaultLabels) {
      this.registry.setDefaultLabels(config.defaultLabels);
    }
    if (config.enableDefaultMetrics !== false) {
      (0, import_prom_client.collectDefaultMetrics)({ register: this.registry });
    }
    this.requestCounter = new import_prom_client.Counter({
      name: `${this.prefix}requests_total`,
      help: "Total number of requests made to exchanges",
      labelNames: ["exchange", "operation", "status"],
      registers: [this.registry]
    });
    this.requestDuration = new import_prom_client.Histogram({
      name: `${this.prefix}request_duration_ms`,
      help: "Request duration in milliseconds",
      labelNames: ["exchange", "operation", "status"],
      buckets: [10, 50, 100, 200, 500, 1e3, 2e3, 5e3, 1e4],
      registers: [this.registry]
    });
    this.requestErrorCounter = new import_prom_client.Counter({
      name: `${this.prefix}request_errors_total`,
      help: "Total number of request errors",
      labelNames: ["exchange", "operation", "error_type"],
      registers: [this.registry]
    });
    this.circuitBreakerStateGauge = new import_prom_client.Gauge({
      name: `${this.prefix}circuit_breaker_state`,
      help: "Circuit breaker state (0=CLOSED, 1=OPEN, 2=HALF_OPEN)",
      labelNames: ["exchange"],
      registers: [this.registry]
    });
    this.circuitBreakerTransitionCounter = new import_prom_client.Counter({
      name: `${this.prefix}circuit_breaker_transitions_total`,
      help: "Total number of circuit breaker state transitions",
      labelNames: ["exchange", "from_state", "to_state"],
      registers: [this.registry]
    });
    this.circuitBreakerFailureCounter = new import_prom_client.Counter({
      name: `${this.prefix}circuit_breaker_failures_total`,
      help: "Total number of circuit breaker failures",
      labelNames: ["exchange"],
      registers: [this.registry]
    });
    this.circuitBreakerSuccessCounter = new import_prom_client.Counter({
      name: `${this.prefix}circuit_breaker_successes_total`,
      help: "Total number of circuit breaker successes",
      labelNames: ["exchange"],
      registers: [this.registry]
    });
    this.wsConnectionGauge = new import_prom_client.Gauge({
      name: `${this.prefix}websocket_connections`,
      help: "Number of active WebSocket connections",
      labelNames: ["exchange"],
      registers: [this.registry]
    });
    this.wsMessageCounter = new import_prom_client.Counter({
      name: `${this.prefix}websocket_messages_total`,
      help: "Total number of WebSocket messages",
      labelNames: ["exchange", "type"],
      registers: [this.registry]
    });
    this.wsReconnectCounter = new import_prom_client.Counter({
      name: `${this.prefix}websocket_reconnects_total`,
      help: "Total number of WebSocket reconnections",
      labelNames: ["exchange"],
      registers: [this.registry]
    });
    this.wsErrorCounter = new import_prom_client.Counter({
      name: `${this.prefix}websocket_errors_total`,
      help: "Total number of WebSocket errors",
      labelNames: ["exchange", "error_type"],
      registers: [this.registry]
    });
    this.orderCounter = new import_prom_client.Counter({
      name: `${this.prefix}orders_total`,
      help: "Total number of orders placed",
      labelNames: ["exchange", "side", "type", "status"],
      registers: [this.registry]
    });
    this.orderLatency = new import_prom_client.Histogram({
      name: `${this.prefix}order_latency_ms`,
      help: "Order placement latency in milliseconds",
      labelNames: ["exchange", "side", "type"],
      buckets: [10, 25, 50, 100, 200, 500, 1e3, 2e3],
      registers: [this.registry]
    });
    this.orderRejectionCounter = new import_prom_client.Counter({
      name: `${this.prefix}order_rejections_total`,
      help: "Total number of order rejections",
      labelNames: ["exchange", "reason"],
      registers: [this.registry]
    });
    this.marketDataLatency = new import_prom_client.Histogram({
      name: `${this.prefix}market_data_latency_ms`,
      help: "Market data update latency in milliseconds",
      labelNames: ["exchange", "type"],
      buckets: [1, 5, 10, 25, 50, 100, 200, 500],
      registers: [this.registry]
    });
    this.marketDataUpdateCounter = new import_prom_client.Counter({
      name: `${this.prefix}market_data_updates_total`,
      help: "Total number of market data updates",
      labelNames: ["exchange", "type"],
      registers: [this.registry]
    });
    this.retryCounter = new import_prom_client.Counter({
      name: `${this.prefix}retries_total`,
      help: "Total number of retries",
      labelNames: ["exchange", "operation", "success"],
      registers: [this.registry]
    });
    this.retryAttemptsHistogram = new import_prom_client.Histogram({
      name: `${this.prefix}retry_attempts`,
      help: "Number of retry attempts before success/failure",
      labelNames: ["exchange", "operation"],
      buckets: [1, 2, 3, 4, 5, 10],
      registers: [this.registry]
    });
    this.cacheHitCounter = new import_prom_client.Counter({
      name: `${this.prefix}cache_hits_total`,
      help: "Total number of cache hits",
      labelNames: ["cache_name"],
      registers: [this.registry]
    });
    this.cacheMissCounter = new import_prom_client.Counter({
      name: `${this.prefix}cache_misses_total`,
      help: "Total number of cache misses",
      labelNames: ["cache_name"],
      registers: [this.registry]
    });
  }
  /**
   * Record a request
   */
  recordRequest(exchange, operation, status, durationMs) {
    this.requestCounter.inc({ exchange, operation, status });
    this.requestDuration.observe({ exchange, operation, status }, durationMs);
  }
  /**
   * Record a request error
   */
  recordRequestError(exchange, operation, errorType) {
    this.requestErrorCounter.inc({ exchange, operation, error_type: errorType });
  }
  /**
   * Update circuit breaker state
   */
  updateCircuitBreakerState(exchange, state) {
    const stateValue = state === "CLOSED" ? 0 : state === "OPEN" ? 1 : 2;
    this.circuitBreakerStateGauge.set({ exchange }, stateValue);
  }
  /**
   * Record circuit breaker state transition
   */
  recordCircuitBreakerTransition(exchange, fromState, toState) {
    this.circuitBreakerTransitionCounter.inc({ exchange, from_state: fromState, to_state: toState });
  }
  /**
   * Record circuit breaker failure
   */
  recordCircuitBreakerFailure(exchange) {
    this.circuitBreakerFailureCounter.inc({ exchange });
  }
  /**
   * Record circuit breaker success
   */
  recordCircuitBreakerSuccess(exchange) {
    this.circuitBreakerSuccessCounter.inc({ exchange });
  }
  /**
   * Update WebSocket connection count
   */
  setWebSocketConnections(exchange, count) {
    this.wsConnectionGauge.set({ exchange }, count);
  }
  /**
   * Record WebSocket message
   */
  recordWebSocketMessage(exchange, type) {
    this.wsMessageCounter.inc({ exchange, type });
  }
  /**
   * Record WebSocket reconnection
   */
  recordWebSocketReconnect(exchange) {
    this.wsReconnectCounter.inc({ exchange });
  }
  /**
   * Record WebSocket error
   */
  recordWebSocketError(exchange, errorType) {
    this.wsErrorCounter.inc({ exchange, error_type: errorType });
  }
  /**
   * Record order
   */
  recordOrder(exchange, side, type, status, latencyMs) {
    this.orderCounter.inc({ exchange, side, type, status });
    if (latencyMs !== void 0 && status === "placed") {
      this.orderLatency.observe({ exchange, side, type }, latencyMs);
    }
  }
  /**
   * Record order rejection
   */
  recordOrderRejection(exchange, reason) {
    this.orderRejectionCounter.inc({ exchange, reason });
  }
  /**
   * Record market data update
   */
  recordMarketDataUpdate(exchange, type, latencyMs) {
    this.marketDataUpdateCounter.inc({ exchange, type });
    this.marketDataLatency.observe({ exchange, type }, latencyMs);
  }
  /**
   * Record retry
   */
  recordRetry(exchange, operation, attempts, success) {
    this.retryCounter.inc({ exchange, operation, success: success ? "true" : "false" });
    this.retryAttemptsHistogram.observe({ exchange, operation }, attempts);
  }
  /**
   * Record cache hit
   */
  recordCacheHit(cacheName) {
    this.cacheHitCounter.inc({ cache_name: cacheName });
  }
  /**
   * Record cache miss
   */
  recordCacheMiss(cacheName) {
    this.cacheMissCounter.inc({ cache_name: cacheName });
  }
  /**
   * Get metrics in Prometheus text format
   */
  async getMetrics() {
    return this.registry.metrics();
  }
  /**
   * Get metrics as JSON
   */
  async getMetricsAsJSON() {
    return this.registry.getMetricsAsJSON();
  }
  /**
   * Get content type for metrics endpoint
   */
  getContentType() {
    return this.registry.contentType;
  }
  /**
   * Reset all metrics (useful for testing)
   */
  resetMetrics() {
    this.registry.resetMetrics();
  }
  /**
   * Clear all metrics (removes them from registry)
   */
  clearMetrics() {
    this.registry.clear();
  }
  /**
   * Get the registry instance
   */
  getRegistry() {
    return this.registry;
  }
};
var globalMetrics = null;
function initializeMetrics(config) {
  globalMetrics = new PrometheusMetrics(config);
  return globalMetrics;
}
function getMetrics() {
  if (!globalMetrics) {
    throw new Error("Metrics not initialized. Call initializeMetrics() first.");
  }
  return globalMetrics;
}
function isMetricsInitialized() {
  return globalMetrics !== null;
}

// node_modules/zod/v3/external.js
var external_exports = {};
__export(external_exports, {
  BRAND: () => BRAND,
  DIRTY: () => DIRTY,
  EMPTY_PATH: () => EMPTY_PATH,
  INVALID: () => INVALID,
  NEVER: () => NEVER,
  OK: () => OK,
  ParseStatus: () => ParseStatus,
  Schema: () => ZodType,
  ZodAny: () => ZodAny,
  ZodArray: () => ZodArray,
  ZodBigInt: () => ZodBigInt,
  ZodBoolean: () => ZodBoolean,
  ZodBranded: () => ZodBranded,
  ZodCatch: () => ZodCatch,
  ZodDate: () => ZodDate,
  ZodDefault: () => ZodDefault,
  ZodDiscriminatedUnion: () => ZodDiscriminatedUnion,
  ZodEffects: () => ZodEffects,
  ZodEnum: () => ZodEnum,
  ZodError: () => ZodError,
  ZodFirstPartyTypeKind: () => ZodFirstPartyTypeKind,
  ZodFunction: () => ZodFunction,
  ZodIntersection: () => ZodIntersection,
  ZodIssueCode: () => ZodIssueCode,
  ZodLazy: () => ZodLazy,
  ZodLiteral: () => ZodLiteral,
  ZodMap: () => ZodMap,
  ZodNaN: () => ZodNaN,
  ZodNativeEnum: () => ZodNativeEnum,
  ZodNever: () => ZodNever,
  ZodNull: () => ZodNull,
  ZodNullable: () => ZodNullable,
  ZodNumber: () => ZodNumber,
  ZodObject: () => ZodObject,
  ZodOptional: () => ZodOptional,
  ZodParsedType: () => ZodParsedType,
  ZodPipeline: () => ZodPipeline,
  ZodPromise: () => ZodPromise,
  ZodReadonly: () => ZodReadonly,
  ZodRecord: () => ZodRecord,
  ZodSchema: () => ZodType,
  ZodSet: () => ZodSet,
  ZodString: () => ZodString,
  ZodSymbol: () => ZodSymbol,
  ZodTransformer: () => ZodEffects,
  ZodTuple: () => ZodTuple,
  ZodType: () => ZodType,
  ZodUndefined: () => ZodUndefined,
  ZodUnion: () => ZodUnion,
  ZodUnknown: () => ZodUnknown,
  ZodVoid: () => ZodVoid,
  addIssueToContext: () => addIssueToContext,
  any: () => anyType,
  array: () => arrayType,
  bigint: () => bigIntType,
  boolean: () => booleanType,
  coerce: () => coerce,
  custom: () => custom,
  date: () => dateType,
  datetimeRegex: () => datetimeRegex,
  defaultErrorMap: () => en_default,
  discriminatedUnion: () => discriminatedUnionType,
  effect: () => effectsType,
  enum: () => enumType,
  function: () => functionType,
  getErrorMap: () => getErrorMap,
  getParsedType: () => getParsedType,
  instanceof: () => instanceOfType,
  intersection: () => intersectionType,
  isAborted: () => isAborted,
  isAsync: () => isAsync,
  isDirty: () => isDirty,
  isValid: () => isValid,
  late: () => late,
  lazy: () => lazyType,
  literal: () => literalType,
  makeIssue: () => makeIssue,
  map: () => mapType,
  nan: () => nanType,
  nativeEnum: () => nativeEnumType,
  never: () => neverType,
  null: () => nullType,
  nullable: () => nullableType,
  number: () => numberType,
  object: () => objectType,
  objectUtil: () => objectUtil,
  oboolean: () => oboolean,
  onumber: () => onumber,
  optional: () => optionalType,
  ostring: () => ostring,
  pipeline: () => pipelineType,
  preprocess: () => preprocessType,
  promise: () => promiseType,
  quotelessJson: () => quotelessJson,
  record: () => recordType,
  set: () => setType,
  setErrorMap: () => setErrorMap,
  strictObject: () => strictObjectType,
  string: () => stringType,
  symbol: () => symbolType,
  transformer: () => effectsType,
  tuple: () => tupleType,
  undefined: () => undefinedType,
  union: () => unionType,
  unknown: () => unknownType,
  util: () => util,
  void: () => voidType
});

// node_modules/zod/v3/helpers/util.js
var util;
(function(util2) {
  util2.assertEqual = (_) => {
  };
  function assertIs(_arg) {
  }
  util2.assertIs = assertIs;
  function assertNever(_x) {
    throw new Error();
  }
  util2.assertNever = assertNever;
  util2.arrayToEnum = (items) => {
    const obj = {};
    for (const item of items) {
      obj[item] = item;
    }
    return obj;
  };
  util2.getValidEnumValues = (obj) => {
    const validKeys = util2.objectKeys(obj).filter((k) => typeof obj[obj[k]] !== "number");
    const filtered = {};
    for (const k of validKeys) {
      filtered[k] = obj[k];
    }
    return util2.objectValues(filtered);
  };
  util2.objectValues = (obj) => {
    return util2.objectKeys(obj).map(function(e) {
      return obj[e];
    });
  };
  util2.objectKeys = typeof Object.keys === "function" ? (obj) => Object.keys(obj) : (object) => {
    const keys = [];
    for (const key in object) {
      if (Object.prototype.hasOwnProperty.call(object, key)) {
        keys.push(key);
      }
    }
    return keys;
  };
  util2.find = (arr, checker) => {
    for (const item of arr) {
      if (checker(item))
        return item;
    }
    return void 0;
  };
  util2.isInteger = typeof Number.isInteger === "function" ? (val) => Number.isInteger(val) : (val) => typeof val === "number" && Number.isFinite(val) && Math.floor(val) === val;
  function joinValues(array, separator = " | ") {
    return array.map((val) => typeof val === "string" ? `'${val}'` : val).join(separator);
  }
  util2.joinValues = joinValues;
  util2.jsonStringifyReplacer = (_, value) => {
    if (typeof value === "bigint") {
      return value.toString();
    }
    return value;
  };
})(util || (util = {}));
var objectUtil;
(function(objectUtil2) {
  objectUtil2.mergeShapes = (first, second) => {
    return {
      ...first,
      ...second
      // second overwrites first
    };
  };
})(objectUtil || (objectUtil = {}));
var ZodParsedType = util.arrayToEnum([
  "string",
  "nan",
  "number",
  "integer",
  "float",
  "boolean",
  "date",
  "bigint",
  "symbol",
  "function",
  "undefined",
  "null",
  "array",
  "object",
  "unknown",
  "promise",
  "void",
  "never",
  "map",
  "set"
]);
var getParsedType = (data) => {
  const t = typeof data;
  switch (t) {
    case "undefined":
      return ZodParsedType.undefined;
    case "string":
      return ZodParsedType.string;
    case "number":
      return Number.isNaN(data) ? ZodParsedType.nan : ZodParsedType.number;
    case "boolean":
      return ZodParsedType.boolean;
    case "function":
      return ZodParsedType.function;
    case "bigint":
      return ZodParsedType.bigint;
    case "symbol":
      return ZodParsedType.symbol;
    case "object":
      if (Array.isArray(data)) {
        return ZodParsedType.array;
      }
      if (data === null) {
        return ZodParsedType.null;
      }
      if (data.then && typeof data.then === "function" && data.catch && typeof data.catch === "function") {
        return ZodParsedType.promise;
      }
      if (typeof Map !== "undefined" && data instanceof Map) {
        return ZodParsedType.map;
      }
      if (typeof Set !== "undefined" && data instanceof Set) {
        return ZodParsedType.set;
      }
      if (typeof Date !== "undefined" && data instanceof Date) {
        return ZodParsedType.date;
      }
      return ZodParsedType.object;
    default:
      return ZodParsedType.unknown;
  }
};

// node_modules/zod/v3/ZodError.js
var ZodIssueCode = util.arrayToEnum([
  "invalid_type",
  "invalid_literal",
  "custom",
  "invalid_union",
  "invalid_union_discriminator",
  "invalid_enum_value",
  "unrecognized_keys",
  "invalid_arguments",
  "invalid_return_type",
  "invalid_date",
  "invalid_string",
  "too_small",
  "too_big",
  "invalid_intersection_types",
  "not_multiple_of",
  "not_finite"
]);
var quotelessJson = (obj) => {
  const json = JSON.stringify(obj, null, 2);
  return json.replace(/"([^"]+)":/g, "$1:");
};
var ZodError = class _ZodError extends Error {
  get errors() {
    return this.issues;
  }
  constructor(issues) {
    super();
    this.issues = [];
    this.addIssue = (sub) => {
      this.issues = [...this.issues, sub];
    };
    this.addIssues = (subs = []) => {
      this.issues = [...this.issues, ...subs];
    };
    const actualProto = new.target.prototype;
    if (Object.setPrototypeOf) {
      Object.setPrototypeOf(this, actualProto);
    } else {
      this.__proto__ = actualProto;
    }
    this.name = "ZodError";
    this.issues = issues;
  }
  format(_mapper) {
    const mapper = _mapper || function(issue) {
      return issue.message;
    };
    const fieldErrors = { _errors: [] };
    const processError = (error) => {
      for (const issue of error.issues) {
        if (issue.code === "invalid_union") {
          issue.unionErrors.map(processError);
        } else if (issue.code === "invalid_return_type") {
          processError(issue.returnTypeError);
        } else if (issue.code === "invalid_arguments") {
          processError(issue.argumentsError);
        } else if (issue.path.length === 0) {
          fieldErrors._errors.push(mapper(issue));
        } else {
          let curr = fieldErrors;
          let i = 0;
          while (i < issue.path.length) {
            const el = issue.path[i];
            const terminal = i === issue.path.length - 1;
            if (!terminal) {
              curr[el] = curr[el] || { _errors: [] };
            } else {
              curr[el] = curr[el] || { _errors: [] };
              curr[el]._errors.push(mapper(issue));
            }
            curr = curr[el];
            i++;
          }
        }
      }
    };
    processError(this);
    return fieldErrors;
  }
  static assert(value) {
    if (!(value instanceof _ZodError)) {
      throw new Error(`Not a ZodError: ${value}`);
    }
  }
  toString() {
    return this.message;
  }
  get message() {
    return JSON.stringify(this.issues, util.jsonStringifyReplacer, 2);
  }
  get isEmpty() {
    return this.issues.length === 0;
  }
  flatten(mapper = (issue) => issue.message) {
    const fieldErrors = {};
    const formErrors = [];
    for (const sub of this.issues) {
      if (sub.path.length > 0) {
        const firstEl = sub.path[0];
        fieldErrors[firstEl] = fieldErrors[firstEl] || [];
        fieldErrors[firstEl].push(mapper(sub));
      } else {
        formErrors.push(mapper(sub));
      }
    }
    return { formErrors, fieldErrors };
  }
  get formErrors() {
    return this.flatten();
  }
};
ZodError.create = (issues) => {
  const error = new ZodError(issues);
  return error;
};

// node_modules/zod/v3/locales/en.js
var errorMap = (issue, _ctx) => {
  let message;
  switch (issue.code) {
    case ZodIssueCode.invalid_type:
      if (issue.received === ZodParsedType.undefined) {
        message = "Required";
      } else {
        message = `Expected ${issue.expected}, received ${issue.received}`;
      }
      break;
    case ZodIssueCode.invalid_literal:
      message = `Invalid literal value, expected ${JSON.stringify(issue.expected, util.jsonStringifyReplacer)}`;
      break;
    case ZodIssueCode.unrecognized_keys:
      message = `Unrecognized key(s) in object: ${util.joinValues(issue.keys, ", ")}`;
      break;
    case ZodIssueCode.invalid_union:
      message = `Invalid input`;
      break;
    case ZodIssueCode.invalid_union_discriminator:
      message = `Invalid discriminator value. Expected ${util.joinValues(issue.options)}`;
      break;
    case ZodIssueCode.invalid_enum_value:
      message = `Invalid enum value. Expected ${util.joinValues(issue.options)}, received '${issue.received}'`;
      break;
    case ZodIssueCode.invalid_arguments:
      message = `Invalid function arguments`;
      break;
    case ZodIssueCode.invalid_return_type:
      message = `Invalid function return type`;
      break;
    case ZodIssueCode.invalid_date:
      message = `Invalid date`;
      break;
    case ZodIssueCode.invalid_string:
      if (typeof issue.validation === "object") {
        if ("includes" in issue.validation) {
          message = `Invalid input: must include "${issue.validation.includes}"`;
          if (typeof issue.validation.position === "number") {
            message = `${message} at one or more positions greater than or equal to ${issue.validation.position}`;
          }
        } else if ("startsWith" in issue.validation) {
          message = `Invalid input: must start with "${issue.validation.startsWith}"`;
        } else if ("endsWith" in issue.validation) {
          message = `Invalid input: must end with "${issue.validation.endsWith}"`;
        } else {
          util.assertNever(issue.validation);
        }
      } else if (issue.validation !== "regex") {
        message = `Invalid ${issue.validation}`;
      } else {
        message = "Invalid";
      }
      break;
    case ZodIssueCode.too_small:
      if (issue.type === "array")
        message = `Array must contain ${issue.exact ? "exactly" : issue.inclusive ? `at least` : `more than`} ${issue.minimum} element(s)`;
      else if (issue.type === "string")
        message = `String must contain ${issue.exact ? "exactly" : issue.inclusive ? `at least` : `over`} ${issue.minimum} character(s)`;
      else if (issue.type === "number")
        message = `Number must be ${issue.exact ? `exactly equal to ` : issue.inclusive ? `greater than or equal to ` : `greater than `}${issue.minimum}`;
      else if (issue.type === "bigint")
        message = `Number must be ${issue.exact ? `exactly equal to ` : issue.inclusive ? `greater than or equal to ` : `greater than `}${issue.minimum}`;
      else if (issue.type === "date")
        message = `Date must be ${issue.exact ? `exactly equal to ` : issue.inclusive ? `greater than or equal to ` : `greater than `}${new Date(Number(issue.minimum))}`;
      else
        message = "Invalid input";
      break;
    case ZodIssueCode.too_big:
      if (issue.type === "array")
        message = `Array must contain ${issue.exact ? `exactly` : issue.inclusive ? `at most` : `less than`} ${issue.maximum} element(s)`;
      else if (issue.type === "string")
        message = `String must contain ${issue.exact ? `exactly` : issue.inclusive ? `at most` : `under`} ${issue.maximum} character(s)`;
      else if (issue.type === "number")
        message = `Number must be ${issue.exact ? `exactly` : issue.inclusive ? `less than or equal to` : `less than`} ${issue.maximum}`;
      else if (issue.type === "bigint")
        message = `BigInt must be ${issue.exact ? `exactly` : issue.inclusive ? `less than or equal to` : `less than`} ${issue.maximum}`;
      else if (issue.type === "date")
        message = `Date must be ${issue.exact ? `exactly` : issue.inclusive ? `smaller than or equal to` : `smaller than`} ${new Date(Number(issue.maximum))}`;
      else
        message = "Invalid input";
      break;
    case ZodIssueCode.custom:
      message = `Invalid input`;
      break;
    case ZodIssueCode.invalid_intersection_types:
      message = `Intersection results could not be merged`;
      break;
    case ZodIssueCode.not_multiple_of:
      message = `Number must be a multiple of ${issue.multipleOf}`;
      break;
    case ZodIssueCode.not_finite:
      message = "Number must be finite";
      break;
    default:
      message = _ctx.defaultError;
      util.assertNever(issue);
  }
  return { message };
};
var en_default = errorMap;

// node_modules/zod/v3/errors.js
var overrideErrorMap = en_default;
function setErrorMap(map) {
  overrideErrorMap = map;
}
function getErrorMap() {
  return overrideErrorMap;
}

// node_modules/zod/v3/helpers/parseUtil.js
var makeIssue = (params) => {
  const { data, path, errorMaps, issueData } = params;
  const fullPath = [...path, ...issueData.path || []];
  const fullIssue = {
    ...issueData,
    path: fullPath
  };
  if (issueData.message !== void 0) {
    return {
      ...issueData,
      path: fullPath,
      message: issueData.message
    };
  }
  let errorMessage = "";
  const maps = errorMaps.filter((m) => !!m).slice().reverse();
  for (const map of maps) {
    errorMessage = map(fullIssue, { data, defaultError: errorMessage }).message;
  }
  return {
    ...issueData,
    path: fullPath,
    message: errorMessage
  };
};
var EMPTY_PATH = [];
function addIssueToContext(ctx, issueData) {
  const overrideMap = getErrorMap();
  const issue = makeIssue({
    issueData,
    data: ctx.data,
    path: ctx.path,
    errorMaps: [
      ctx.common.contextualErrorMap,
      // contextual error map is first priority
      ctx.schemaErrorMap,
      // then schema-bound map if available
      overrideMap,
      // then global override map
      overrideMap === en_default ? void 0 : en_default
      // then global default map
    ].filter((x) => !!x)
  });
  ctx.common.issues.push(issue);
}
var ParseStatus = class _ParseStatus {
  constructor() {
    this.value = "valid";
  }
  dirty() {
    if (this.value === "valid")
      this.value = "dirty";
  }
  abort() {
    if (this.value !== "aborted")
      this.value = "aborted";
  }
  static mergeArray(status, results) {
    const arrayValue = [];
    for (const s of results) {
      if (s.status === "aborted")
        return INVALID;
      if (s.status === "dirty")
        status.dirty();
      arrayValue.push(s.value);
    }
    return { status: status.value, value: arrayValue };
  }
  static async mergeObjectAsync(status, pairs) {
    const syncPairs = [];
    for (const pair of pairs) {
      const key = await pair.key;
      const value = await pair.value;
      syncPairs.push({
        key,
        value
      });
    }
    return _ParseStatus.mergeObjectSync(status, syncPairs);
  }
  static mergeObjectSync(status, pairs) {
    const finalObject = {};
    for (const pair of pairs) {
      const { key, value } = pair;
      if (key.status === "aborted")
        return INVALID;
      if (value.status === "aborted")
        return INVALID;
      if (key.status === "dirty")
        status.dirty();
      if (value.status === "dirty")
        status.dirty();
      if (key.value !== "__proto__" && (typeof value.value !== "undefined" || pair.alwaysSet)) {
        finalObject[key.value] = value.value;
      }
    }
    return { status: status.value, value: finalObject };
  }
};
var INVALID = Object.freeze({
  status: "aborted"
});
var DIRTY = (value) => ({ status: "dirty", value });
var OK = (value) => ({ status: "valid", value });
var isAborted = (x) => x.status === "aborted";
var isDirty = (x) => x.status === "dirty";
var isValid = (x) => x.status === "valid";
var isAsync = (x) => typeof Promise !== "undefined" && x instanceof Promise;

// node_modules/zod/v3/helpers/errorUtil.js
var errorUtil;
(function(errorUtil2) {
  errorUtil2.errToObj = (message) => typeof message === "string" ? { message } : message || {};
  errorUtil2.toString = (message) => typeof message === "string" ? message : message?.message;
})(errorUtil || (errorUtil = {}));

// node_modules/zod/v3/types.js
var ParseInputLazyPath = class {
  constructor(parent, value, path, key) {
    this._cachedPath = [];
    this.parent = parent;
    this.data = value;
    this._path = path;
    this._key = key;
  }
  get path() {
    if (!this._cachedPath.length) {
      if (Array.isArray(this._key)) {
        this._cachedPath.push(...this._path, ...this._key);
      } else {
        this._cachedPath.push(...this._path, this._key);
      }
    }
    return this._cachedPath;
  }
};
var handleResult = (ctx, result) => {
  if (isValid(result)) {
    return { success: true, data: result.value };
  } else {
    if (!ctx.common.issues.length) {
      throw new Error("Validation failed but no issues detected.");
    }
    return {
      success: false,
      get error() {
        if (this._error)
          return this._error;
        const error = new ZodError(ctx.common.issues);
        this._error = error;
        return this._error;
      }
    };
  }
};
function processCreateParams(params) {
  if (!params)
    return {};
  const { errorMap: errorMap2, invalid_type_error, required_error, description } = params;
  if (errorMap2 && (invalid_type_error || required_error)) {
    throw new Error(`Can't use "invalid_type_error" or "required_error" in conjunction with custom error map.`);
  }
  if (errorMap2)
    return { errorMap: errorMap2, description };
  const customMap = (iss, ctx) => {
    const { message } = params;
    if (iss.code === "invalid_enum_value") {
      return { message: message ?? ctx.defaultError };
    }
    if (typeof ctx.data === "undefined") {
      return { message: message ?? required_error ?? ctx.defaultError };
    }
    if (iss.code !== "invalid_type")
      return { message: ctx.defaultError };
    return { message: message ?? invalid_type_error ?? ctx.defaultError };
  };
  return { errorMap: customMap, description };
}
var ZodType = class {
  get description() {
    return this._def.description;
  }
  _getType(input) {
    return getParsedType(input.data);
  }
  _getOrReturnCtx(input, ctx) {
    return ctx || {
      common: input.parent.common,
      data: input.data,
      parsedType: getParsedType(input.data),
      schemaErrorMap: this._def.errorMap,
      path: input.path,
      parent: input.parent
    };
  }
  _processInputParams(input) {
    return {
      status: new ParseStatus(),
      ctx: {
        common: input.parent.common,
        data: input.data,
        parsedType: getParsedType(input.data),
        schemaErrorMap: this._def.errorMap,
        path: input.path,
        parent: input.parent
      }
    };
  }
  _parseSync(input) {
    const result = this._parse(input);
    if (isAsync(result)) {
      throw new Error("Synchronous parse encountered promise.");
    }
    return result;
  }
  _parseAsync(input) {
    const result = this._parse(input);
    return Promise.resolve(result);
  }
  parse(data, params) {
    const result = this.safeParse(data, params);
    if (result.success)
      return result.data;
    throw result.error;
  }
  safeParse(data, params) {
    const ctx = {
      common: {
        issues: [],
        async: params?.async ?? false,
        contextualErrorMap: params?.errorMap
      },
      path: params?.path || [],
      schemaErrorMap: this._def.errorMap,
      parent: null,
      data,
      parsedType: getParsedType(data)
    };
    const result = this._parseSync({ data, path: ctx.path, parent: ctx });
    return handleResult(ctx, result);
  }
  "~validate"(data) {
    const ctx = {
      common: {
        issues: [],
        async: !!this["~standard"].async
      },
      path: [],
      schemaErrorMap: this._def.errorMap,
      parent: null,
      data,
      parsedType: getParsedType(data)
    };
    if (!this["~standard"].async) {
      try {
        const result = this._parseSync({ data, path: [], parent: ctx });
        return isValid(result) ? {
          value: result.value
        } : {
          issues: ctx.common.issues
        };
      } catch (err2) {
        if (err2?.message?.toLowerCase()?.includes("encountered")) {
          this["~standard"].async = true;
        }
        ctx.common = {
          issues: [],
          async: true
        };
      }
    }
    return this._parseAsync({ data, path: [], parent: ctx }).then((result) => isValid(result) ? {
      value: result.value
    } : {
      issues: ctx.common.issues
    });
  }
  async parseAsync(data, params) {
    const result = await this.safeParseAsync(data, params);
    if (result.success)
      return result.data;
    throw result.error;
  }
  async safeParseAsync(data, params) {
    const ctx = {
      common: {
        issues: [],
        contextualErrorMap: params?.errorMap,
        async: true
      },
      path: params?.path || [],
      schemaErrorMap: this._def.errorMap,
      parent: null,
      data,
      parsedType: getParsedType(data)
    };
    const maybeAsyncResult = this._parse({ data, path: ctx.path, parent: ctx });
    const result = await (isAsync(maybeAsyncResult) ? maybeAsyncResult : Promise.resolve(maybeAsyncResult));
    return handleResult(ctx, result);
  }
  refine(check, message) {
    const getIssueProperties = (val) => {
      if (typeof message === "string" || typeof message === "undefined") {
        return { message };
      } else if (typeof message === "function") {
        return message(val);
      } else {
        return message;
      }
    };
    return this._refinement((val, ctx) => {
      const result = check(val);
      const setError = () => ctx.addIssue({
        code: ZodIssueCode.custom,
        ...getIssueProperties(val)
      });
      if (typeof Promise !== "undefined" && result instanceof Promise) {
        return result.then((data) => {
          if (!data) {
            setError();
            return false;
          } else {
            return true;
          }
        });
      }
      if (!result) {
        setError();
        return false;
      } else {
        return true;
      }
    });
  }
  refinement(check, refinementData) {
    return this._refinement((val, ctx) => {
      if (!check(val)) {
        ctx.addIssue(typeof refinementData === "function" ? refinementData(val, ctx) : refinementData);
        return false;
      } else {
        return true;
      }
    });
  }
  _refinement(refinement) {
    return new ZodEffects({
      schema: this,
      typeName: ZodFirstPartyTypeKind.ZodEffects,
      effect: { type: "refinement", refinement }
    });
  }
  superRefine(refinement) {
    return this._refinement(refinement);
  }
  constructor(def) {
    this.spa = this.safeParseAsync;
    this._def = def;
    this.parse = this.parse.bind(this);
    this.safeParse = this.safeParse.bind(this);
    this.parseAsync = this.parseAsync.bind(this);
    this.safeParseAsync = this.safeParseAsync.bind(this);
    this.spa = this.spa.bind(this);
    this.refine = this.refine.bind(this);
    this.refinement = this.refinement.bind(this);
    this.superRefine = this.superRefine.bind(this);
    this.optional = this.optional.bind(this);
    this.nullable = this.nullable.bind(this);
    this.nullish = this.nullish.bind(this);
    this.array = this.array.bind(this);
    this.promise = this.promise.bind(this);
    this.or = this.or.bind(this);
    this.and = this.and.bind(this);
    this.transform = this.transform.bind(this);
    this.brand = this.brand.bind(this);
    this.default = this.default.bind(this);
    this.catch = this.catch.bind(this);
    this.describe = this.describe.bind(this);
    this.pipe = this.pipe.bind(this);
    this.readonly = this.readonly.bind(this);
    this.isNullable = this.isNullable.bind(this);
    this.isOptional = this.isOptional.bind(this);
    this["~standard"] = {
      version: 1,
      vendor: "zod",
      validate: (data) => this["~validate"](data)
    };
  }
  optional() {
    return ZodOptional.create(this, this._def);
  }
  nullable() {
    return ZodNullable.create(this, this._def);
  }
  nullish() {
    return this.nullable().optional();
  }
  array() {
    return ZodArray.create(this);
  }
  promise() {
    return ZodPromise.create(this, this._def);
  }
  or(option) {
    return ZodUnion.create([this, option], this._def);
  }
  and(incoming) {
    return ZodIntersection.create(this, incoming, this._def);
  }
  transform(transform) {
    return new ZodEffects({
      ...processCreateParams(this._def),
      schema: this,
      typeName: ZodFirstPartyTypeKind.ZodEffects,
      effect: { type: "transform", transform }
    });
  }
  default(def) {
    const defaultValueFunc = typeof def === "function" ? def : () => def;
    return new ZodDefault({
      ...processCreateParams(this._def),
      innerType: this,
      defaultValue: defaultValueFunc,
      typeName: ZodFirstPartyTypeKind.ZodDefault
    });
  }
  brand() {
    return new ZodBranded({
      typeName: ZodFirstPartyTypeKind.ZodBranded,
      type: this,
      ...processCreateParams(this._def)
    });
  }
  catch(def) {
    const catchValueFunc = typeof def === "function" ? def : () => def;
    return new ZodCatch({
      ...processCreateParams(this._def),
      innerType: this,
      catchValue: catchValueFunc,
      typeName: ZodFirstPartyTypeKind.ZodCatch
    });
  }
  describe(description) {
    const This = this.constructor;
    return new This({
      ...this._def,
      description
    });
  }
  pipe(target) {
    return ZodPipeline.create(this, target);
  }
  readonly() {
    return ZodReadonly.create(this);
  }
  isOptional() {
    return this.safeParse(void 0).success;
  }
  isNullable() {
    return this.safeParse(null).success;
  }
};
var cuidRegex = /^c[^\s-]{8,}$/i;
var cuid2Regex = /^[0-9a-z]+$/;
var ulidRegex = /^[0-9A-HJKMNP-TV-Z]{26}$/i;
var uuidRegex = /^[0-9a-fA-F]{8}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{12}$/i;
var nanoidRegex = /^[a-z0-9_-]{21}$/i;
var jwtRegex = /^[A-Za-z0-9-_]+\.[A-Za-z0-9-_]+\.[A-Za-z0-9-_]*$/;
var durationRegex = /^[-+]?P(?!$)(?:(?:[-+]?\d+Y)|(?:[-+]?\d+[.,]\d+Y$))?(?:(?:[-+]?\d+M)|(?:[-+]?\d+[.,]\d+M$))?(?:(?:[-+]?\d+W)|(?:[-+]?\d+[.,]\d+W$))?(?:(?:[-+]?\d+D)|(?:[-+]?\d+[.,]\d+D$))?(?:T(?=[\d+-])(?:(?:[-+]?\d+H)|(?:[-+]?\d+[.,]\d+H$))?(?:(?:[-+]?\d+M)|(?:[-+]?\d+[.,]\d+M$))?(?:[-+]?\d+(?:[.,]\d+)?S)?)??$/;
var emailRegex = /^(?!\.)(?!.*\.\.)([A-Z0-9_'+\-\.]*)[A-Z0-9_+-]@([A-Z0-9][A-Z0-9\-]*\.)+[A-Z]{2,}$/i;
var _emojiRegex = `^(\\p{Extended_Pictographic}|\\p{Emoji_Component})+$`;
var emojiRegex;
var ipv4Regex = /^(?:(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\.){3}(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])$/;
var ipv4CidrRegex = /^(?:(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\.){3}(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\/(3[0-2]|[12]?[0-9])$/;
var ipv6Regex = /^(([0-9a-fA-F]{1,4}:){7,7}[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,7}:|([0-9a-fA-F]{1,4}:){1,6}:[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,5}(:[0-9a-fA-F]{1,4}){1,2}|([0-9a-fA-F]{1,4}:){1,4}(:[0-9a-fA-F]{1,4}){1,3}|([0-9a-fA-F]{1,4}:){1,3}(:[0-9a-fA-F]{1,4}){1,4}|([0-9a-fA-F]{1,4}:){1,2}(:[0-9a-fA-F]{1,4}){1,5}|[0-9a-fA-F]{1,4}:((:[0-9a-fA-F]{1,4}){1,6})|:((:[0-9a-fA-F]{1,4}){1,7}|:)|fe80:(:[0-9a-fA-F]{0,4}){0,4}%[0-9a-zA-Z]{1,}|::(ffff(:0{1,4}){0,1}:){0,1}((25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])\.){3,3}(25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])|([0-9a-fA-F]{1,4}:){1,4}:((25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])\.){3,3}(25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9]))$/;
var ipv6CidrRegex = /^(([0-9a-fA-F]{1,4}:){7,7}[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,7}:|([0-9a-fA-F]{1,4}:){1,6}:[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,5}(:[0-9a-fA-F]{1,4}){1,2}|([0-9a-fA-F]{1,4}:){1,4}(:[0-9a-fA-F]{1,4}){1,3}|([0-9a-fA-F]{1,4}:){1,3}(:[0-9a-fA-F]{1,4}){1,4}|([0-9a-fA-F]{1,4}:){1,2}(:[0-9a-fA-F]{1,4}){1,5}|[0-9a-fA-F]{1,4}:((:[0-9a-fA-F]{1,4}){1,6})|:((:[0-9a-fA-F]{1,4}){1,7}|:)|fe80:(:[0-9a-fA-F]{0,4}){0,4}%[0-9a-zA-Z]{1,}|::(ffff(:0{1,4}){0,1}:){0,1}((25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])\.){3,3}(25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])|([0-9a-fA-F]{1,4}:){1,4}:((25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])\.){3,3}(25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9]))\/(12[0-8]|1[01][0-9]|[1-9]?[0-9])$/;
var base64Regex = /^([0-9a-zA-Z+/]{4})*(([0-9a-zA-Z+/]{2}==)|([0-9a-zA-Z+/]{3}=))?$/;
var base64urlRegex = /^([0-9a-zA-Z-_]{4})*(([0-9a-zA-Z-_]{2}(==)?)|([0-9a-zA-Z-_]{3}(=)?))?$/;
var dateRegexSource = `((\\d\\d[2468][048]|\\d\\d[13579][26]|\\d\\d0[48]|[02468][048]00|[13579][26]00)-02-29|\\d{4}-((0[13578]|1[02])-(0[1-9]|[12]\\d|3[01])|(0[469]|11)-(0[1-9]|[12]\\d|30)|(02)-(0[1-9]|1\\d|2[0-8])))`;
var dateRegex = new RegExp(`^${dateRegexSource}$`);
function timeRegexSource(args) {
  let secondsRegexSource = `[0-5]\\d`;
  if (args.precision) {
    secondsRegexSource = `${secondsRegexSource}\\.\\d{${args.precision}}`;
  } else if (args.precision == null) {
    secondsRegexSource = `${secondsRegexSource}(\\.\\d+)?`;
  }
  const secondsQuantifier = args.precision ? "+" : "?";
  return `([01]\\d|2[0-3]):[0-5]\\d(:${secondsRegexSource})${secondsQuantifier}`;
}
function timeRegex(args) {
  return new RegExp(`^${timeRegexSource(args)}$`);
}
function datetimeRegex(args) {
  let regex = `${dateRegexSource}T${timeRegexSource(args)}`;
  const opts = [];
  opts.push(args.local ? `Z?` : `Z`);
  if (args.offset)
    opts.push(`([+-]\\d{2}:?\\d{2})`);
  regex = `${regex}(${opts.join("|")})`;
  return new RegExp(`^${regex}$`);
}
function isValidIP(ip, version) {
  if ((version === "v4" || !version) && ipv4Regex.test(ip)) {
    return true;
  }
  if ((version === "v6" || !version) && ipv6Regex.test(ip)) {
    return true;
  }
  return false;
}
function isValidJWT(jwt, alg) {
  if (!jwtRegex.test(jwt))
    return false;
  try {
    const [header] = jwt.split(".");
    if (!header)
      return false;
    const base64 = header.replace(/-/g, "+").replace(/_/g, "/").padEnd(header.length + (4 - header.length % 4) % 4, "=");
    const decoded = JSON.parse(atob(base64));
    if (typeof decoded !== "object" || decoded === null)
      return false;
    if ("typ" in decoded && decoded?.typ !== "JWT")
      return false;
    if (!decoded.alg)
      return false;
    if (alg && decoded.alg !== alg)
      return false;
    return true;
  } catch {
    return false;
  }
}
function isValidCidr(ip, version) {
  if ((version === "v4" || !version) && ipv4CidrRegex.test(ip)) {
    return true;
  }
  if ((version === "v6" || !version) && ipv6CidrRegex.test(ip)) {
    return true;
  }
  return false;
}
var ZodString = class _ZodString extends ZodType {
  _parse(input) {
    if (this._def.coerce) {
      input.data = String(input.data);
    }
    const parsedType = this._getType(input);
    if (parsedType !== ZodParsedType.string) {
      const ctx2 = this._getOrReturnCtx(input);
      addIssueToContext(ctx2, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.string,
        received: ctx2.parsedType
      });
      return INVALID;
    }
    const status = new ParseStatus();
    let ctx = void 0;
    for (const check of this._def.checks) {
      if (check.kind === "min") {
        if (input.data.length < check.value) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.too_small,
            minimum: check.value,
            type: "string",
            inclusive: true,
            exact: false,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "max") {
        if (input.data.length > check.value) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.too_big,
            maximum: check.value,
            type: "string",
            inclusive: true,
            exact: false,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "length") {
        const tooBig = input.data.length > check.value;
        const tooSmall = input.data.length < check.value;
        if (tooBig || tooSmall) {
          ctx = this._getOrReturnCtx(input, ctx);
          if (tooBig) {
            addIssueToContext(ctx, {
              code: ZodIssueCode.too_big,
              maximum: check.value,
              type: "string",
              inclusive: true,
              exact: true,
              message: check.message
            });
          } else if (tooSmall) {
            addIssueToContext(ctx, {
              code: ZodIssueCode.too_small,
              minimum: check.value,
              type: "string",
              inclusive: true,
              exact: true,
              message: check.message
            });
          }
          status.dirty();
        }
      } else if (check.kind === "email") {
        if (!emailRegex.test(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            validation: "email",
            code: ZodIssueCode.invalid_string,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "emoji") {
        if (!emojiRegex) {
          emojiRegex = new RegExp(_emojiRegex, "u");
        }
        if (!emojiRegex.test(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            validation: "emoji",
            code: ZodIssueCode.invalid_string,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "uuid") {
        if (!uuidRegex.test(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            validation: "uuid",
            code: ZodIssueCode.invalid_string,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "nanoid") {
        if (!nanoidRegex.test(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            validation: "nanoid",
            code: ZodIssueCode.invalid_string,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "cuid") {
        if (!cuidRegex.test(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            validation: "cuid",
            code: ZodIssueCode.invalid_string,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "cuid2") {
        if (!cuid2Regex.test(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            validation: "cuid2",
            code: ZodIssueCode.invalid_string,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "ulid") {
        if (!ulidRegex.test(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            validation: "ulid",
            code: ZodIssueCode.invalid_string,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "url") {
        try {
          new URL(input.data);
        } catch {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            validation: "url",
            code: ZodIssueCode.invalid_string,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "regex") {
        check.regex.lastIndex = 0;
        const testResult = check.regex.test(input.data);
        if (!testResult) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            validation: "regex",
            code: ZodIssueCode.invalid_string,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "trim") {
        input.data = input.data.trim();
      } else if (check.kind === "includes") {
        if (!input.data.includes(check.value, check.position)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.invalid_string,
            validation: { includes: check.value, position: check.position },
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "toLowerCase") {
        input.data = input.data.toLowerCase();
      } else if (check.kind === "toUpperCase") {
        input.data = input.data.toUpperCase();
      } else if (check.kind === "startsWith") {
        if (!input.data.startsWith(check.value)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.invalid_string,
            validation: { startsWith: check.value },
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "endsWith") {
        if (!input.data.endsWith(check.value)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.invalid_string,
            validation: { endsWith: check.value },
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "datetime") {
        const regex = datetimeRegex(check);
        if (!regex.test(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.invalid_string,
            validation: "datetime",
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "date") {
        const regex = dateRegex;
        if (!regex.test(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.invalid_string,
            validation: "date",
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "time") {
        const regex = timeRegex(check);
        if (!regex.test(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.invalid_string,
            validation: "time",
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "duration") {
        if (!durationRegex.test(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            validation: "duration",
            code: ZodIssueCode.invalid_string,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "ip") {
        if (!isValidIP(input.data, check.version)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            validation: "ip",
            code: ZodIssueCode.invalid_string,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "jwt") {
        if (!isValidJWT(input.data, check.alg)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            validation: "jwt",
            code: ZodIssueCode.invalid_string,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "cidr") {
        if (!isValidCidr(input.data, check.version)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            validation: "cidr",
            code: ZodIssueCode.invalid_string,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "base64") {
        if (!base64Regex.test(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            validation: "base64",
            code: ZodIssueCode.invalid_string,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "base64url") {
        if (!base64urlRegex.test(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            validation: "base64url",
            code: ZodIssueCode.invalid_string,
            message: check.message
          });
          status.dirty();
        }
      } else {
        util.assertNever(check);
      }
    }
    return { status: status.value, value: input.data };
  }
  _regex(regex, validation, message) {
    return this.refinement((data) => regex.test(data), {
      validation,
      code: ZodIssueCode.invalid_string,
      ...errorUtil.errToObj(message)
    });
  }
  _addCheck(check) {
    return new _ZodString({
      ...this._def,
      checks: [...this._def.checks, check]
    });
  }
  email(message) {
    return this._addCheck({ kind: "email", ...errorUtil.errToObj(message) });
  }
  url(message) {
    return this._addCheck({ kind: "url", ...errorUtil.errToObj(message) });
  }
  emoji(message) {
    return this._addCheck({ kind: "emoji", ...errorUtil.errToObj(message) });
  }
  uuid(message) {
    return this._addCheck({ kind: "uuid", ...errorUtil.errToObj(message) });
  }
  nanoid(message) {
    return this._addCheck({ kind: "nanoid", ...errorUtil.errToObj(message) });
  }
  cuid(message) {
    return this._addCheck({ kind: "cuid", ...errorUtil.errToObj(message) });
  }
  cuid2(message) {
    return this._addCheck({ kind: "cuid2", ...errorUtil.errToObj(message) });
  }
  ulid(message) {
    return this._addCheck({ kind: "ulid", ...errorUtil.errToObj(message) });
  }
  base64(message) {
    return this._addCheck({ kind: "base64", ...errorUtil.errToObj(message) });
  }
  base64url(message) {
    return this._addCheck({
      kind: "base64url",
      ...errorUtil.errToObj(message)
    });
  }
  jwt(options) {
    return this._addCheck({ kind: "jwt", ...errorUtil.errToObj(options) });
  }
  ip(options) {
    return this._addCheck({ kind: "ip", ...errorUtil.errToObj(options) });
  }
  cidr(options) {
    return this._addCheck({ kind: "cidr", ...errorUtil.errToObj(options) });
  }
  datetime(options) {
    if (typeof options === "string") {
      return this._addCheck({
        kind: "datetime",
        precision: null,
        offset: false,
        local: false,
        message: options
      });
    }
    return this._addCheck({
      kind: "datetime",
      precision: typeof options?.precision === "undefined" ? null : options?.precision,
      offset: options?.offset ?? false,
      local: options?.local ?? false,
      ...errorUtil.errToObj(options?.message)
    });
  }
  date(message) {
    return this._addCheck({ kind: "date", message });
  }
  time(options) {
    if (typeof options === "string") {
      return this._addCheck({
        kind: "time",
        precision: null,
        message: options
      });
    }
    return this._addCheck({
      kind: "time",
      precision: typeof options?.precision === "undefined" ? null : options?.precision,
      ...errorUtil.errToObj(options?.message)
    });
  }
  duration(message) {
    return this._addCheck({ kind: "duration", ...errorUtil.errToObj(message) });
  }
  regex(regex, message) {
    return this._addCheck({
      kind: "regex",
      regex,
      ...errorUtil.errToObj(message)
    });
  }
  includes(value, options) {
    return this._addCheck({
      kind: "includes",
      value,
      position: options?.position,
      ...errorUtil.errToObj(options?.message)
    });
  }
  startsWith(value, message) {
    return this._addCheck({
      kind: "startsWith",
      value,
      ...errorUtil.errToObj(message)
    });
  }
  endsWith(value, message) {
    return this._addCheck({
      kind: "endsWith",
      value,
      ...errorUtil.errToObj(message)
    });
  }
  min(minLength, message) {
    return this._addCheck({
      kind: "min",
      value: minLength,
      ...errorUtil.errToObj(message)
    });
  }
  max(maxLength, message) {
    return this._addCheck({
      kind: "max",
      value: maxLength,
      ...errorUtil.errToObj(message)
    });
  }
  length(len, message) {
    return this._addCheck({
      kind: "length",
      value: len,
      ...errorUtil.errToObj(message)
    });
  }
  /**
   * Equivalent to `.min(1)`
   */
  nonempty(message) {
    return this.min(1, errorUtil.errToObj(message));
  }
  trim() {
    return new _ZodString({
      ...this._def,
      checks: [...this._def.checks, { kind: "trim" }]
    });
  }
  toLowerCase() {
    return new _ZodString({
      ...this._def,
      checks: [...this._def.checks, { kind: "toLowerCase" }]
    });
  }
  toUpperCase() {
    return new _ZodString({
      ...this._def,
      checks: [...this._def.checks, { kind: "toUpperCase" }]
    });
  }
  get isDatetime() {
    return !!this._def.checks.find((ch) => ch.kind === "datetime");
  }
  get isDate() {
    return !!this._def.checks.find((ch) => ch.kind === "date");
  }
  get isTime() {
    return !!this._def.checks.find((ch) => ch.kind === "time");
  }
  get isDuration() {
    return !!this._def.checks.find((ch) => ch.kind === "duration");
  }
  get isEmail() {
    return !!this._def.checks.find((ch) => ch.kind === "email");
  }
  get isURL() {
    return !!this._def.checks.find((ch) => ch.kind === "url");
  }
  get isEmoji() {
    return !!this._def.checks.find((ch) => ch.kind === "emoji");
  }
  get isUUID() {
    return !!this._def.checks.find((ch) => ch.kind === "uuid");
  }
  get isNANOID() {
    return !!this._def.checks.find((ch) => ch.kind === "nanoid");
  }
  get isCUID() {
    return !!this._def.checks.find((ch) => ch.kind === "cuid");
  }
  get isCUID2() {
    return !!this._def.checks.find((ch) => ch.kind === "cuid2");
  }
  get isULID() {
    return !!this._def.checks.find((ch) => ch.kind === "ulid");
  }
  get isIP() {
    return !!this._def.checks.find((ch) => ch.kind === "ip");
  }
  get isCIDR() {
    return !!this._def.checks.find((ch) => ch.kind === "cidr");
  }
  get isBase64() {
    return !!this._def.checks.find((ch) => ch.kind === "base64");
  }
  get isBase64url() {
    return !!this._def.checks.find((ch) => ch.kind === "base64url");
  }
  get minLength() {
    let min = null;
    for (const ch of this._def.checks) {
      if (ch.kind === "min") {
        if (min === null || ch.value > min)
          min = ch.value;
      }
    }
    return min;
  }
  get maxLength() {
    let max = null;
    for (const ch of this._def.checks) {
      if (ch.kind === "max") {
        if (max === null || ch.value < max)
          max = ch.value;
      }
    }
    return max;
  }
};
ZodString.create = (params) => {
  return new ZodString({
    checks: [],
    typeName: ZodFirstPartyTypeKind.ZodString,
    coerce: params?.coerce ?? false,
    ...processCreateParams(params)
  });
};
function floatSafeRemainder(val, step) {
  const valDecCount = (val.toString().split(".")[1] || "").length;
  const stepDecCount = (step.toString().split(".")[1] || "").length;
  const decCount = valDecCount > stepDecCount ? valDecCount : stepDecCount;
  const valInt = Number.parseInt(val.toFixed(decCount).replace(".", ""));
  const stepInt = Number.parseInt(step.toFixed(decCount).replace(".", ""));
  return valInt % stepInt / 10 ** decCount;
}
var ZodNumber = class _ZodNumber extends ZodType {
  constructor() {
    super(...arguments);
    this.min = this.gte;
    this.max = this.lte;
    this.step = this.multipleOf;
  }
  _parse(input) {
    if (this._def.coerce) {
      input.data = Number(input.data);
    }
    const parsedType = this._getType(input);
    if (parsedType !== ZodParsedType.number) {
      const ctx2 = this._getOrReturnCtx(input);
      addIssueToContext(ctx2, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.number,
        received: ctx2.parsedType
      });
      return INVALID;
    }
    let ctx = void 0;
    const status = new ParseStatus();
    for (const check of this._def.checks) {
      if (check.kind === "int") {
        if (!util.isInteger(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.invalid_type,
            expected: "integer",
            received: "float",
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "min") {
        const tooSmall = check.inclusive ? input.data < check.value : input.data <= check.value;
        if (tooSmall) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.too_small,
            minimum: check.value,
            type: "number",
            inclusive: check.inclusive,
            exact: false,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "max") {
        const tooBig = check.inclusive ? input.data > check.value : input.data >= check.value;
        if (tooBig) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.too_big,
            maximum: check.value,
            type: "number",
            inclusive: check.inclusive,
            exact: false,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "multipleOf") {
        if (floatSafeRemainder(input.data, check.value) !== 0) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.not_multiple_of,
            multipleOf: check.value,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "finite") {
        if (!Number.isFinite(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.not_finite,
            message: check.message
          });
          status.dirty();
        }
      } else {
        util.assertNever(check);
      }
    }
    return { status: status.value, value: input.data };
  }
  gte(value, message) {
    return this.setLimit("min", value, true, errorUtil.toString(message));
  }
  gt(value, message) {
    return this.setLimit("min", value, false, errorUtil.toString(message));
  }
  lte(value, message) {
    return this.setLimit("max", value, true, errorUtil.toString(message));
  }
  lt(value, message) {
    return this.setLimit("max", value, false, errorUtil.toString(message));
  }
  setLimit(kind, value, inclusive, message) {
    return new _ZodNumber({
      ...this._def,
      checks: [
        ...this._def.checks,
        {
          kind,
          value,
          inclusive,
          message: errorUtil.toString(message)
        }
      ]
    });
  }
  _addCheck(check) {
    return new _ZodNumber({
      ...this._def,
      checks: [...this._def.checks, check]
    });
  }
  int(message) {
    return this._addCheck({
      kind: "int",
      message: errorUtil.toString(message)
    });
  }
  positive(message) {
    return this._addCheck({
      kind: "min",
      value: 0,
      inclusive: false,
      message: errorUtil.toString(message)
    });
  }
  negative(message) {
    return this._addCheck({
      kind: "max",
      value: 0,
      inclusive: false,
      message: errorUtil.toString(message)
    });
  }
  nonpositive(message) {
    return this._addCheck({
      kind: "max",
      value: 0,
      inclusive: true,
      message: errorUtil.toString(message)
    });
  }
  nonnegative(message) {
    return this._addCheck({
      kind: "min",
      value: 0,
      inclusive: true,
      message: errorUtil.toString(message)
    });
  }
  multipleOf(value, message) {
    return this._addCheck({
      kind: "multipleOf",
      value,
      message: errorUtil.toString(message)
    });
  }
  finite(message) {
    return this._addCheck({
      kind: "finite",
      message: errorUtil.toString(message)
    });
  }
  safe(message) {
    return this._addCheck({
      kind: "min",
      inclusive: true,
      value: Number.MIN_SAFE_INTEGER,
      message: errorUtil.toString(message)
    })._addCheck({
      kind: "max",
      inclusive: true,
      value: Number.MAX_SAFE_INTEGER,
      message: errorUtil.toString(message)
    });
  }
  get minValue() {
    let min = null;
    for (const ch of this._def.checks) {
      if (ch.kind === "min") {
        if (min === null || ch.value > min)
          min = ch.value;
      }
    }
    return min;
  }
  get maxValue() {
    let max = null;
    for (const ch of this._def.checks) {
      if (ch.kind === "max") {
        if (max === null || ch.value < max)
          max = ch.value;
      }
    }
    return max;
  }
  get isInt() {
    return !!this._def.checks.find((ch) => ch.kind === "int" || ch.kind === "multipleOf" && util.isInteger(ch.value));
  }
  get isFinite() {
    let max = null;
    let min = null;
    for (const ch of this._def.checks) {
      if (ch.kind === "finite" || ch.kind === "int" || ch.kind === "multipleOf") {
        return true;
      } else if (ch.kind === "min") {
        if (min === null || ch.value > min)
          min = ch.value;
      } else if (ch.kind === "max") {
        if (max === null || ch.value < max)
          max = ch.value;
      }
    }
    return Number.isFinite(min) && Number.isFinite(max);
  }
};
ZodNumber.create = (params) => {
  return new ZodNumber({
    checks: [],
    typeName: ZodFirstPartyTypeKind.ZodNumber,
    coerce: params?.coerce || false,
    ...processCreateParams(params)
  });
};
var ZodBigInt = class _ZodBigInt extends ZodType {
  constructor() {
    super(...arguments);
    this.min = this.gte;
    this.max = this.lte;
  }
  _parse(input) {
    if (this._def.coerce) {
      try {
        input.data = BigInt(input.data);
      } catch {
        return this._getInvalidInput(input);
      }
    }
    const parsedType = this._getType(input);
    if (parsedType !== ZodParsedType.bigint) {
      return this._getInvalidInput(input);
    }
    let ctx = void 0;
    const status = new ParseStatus();
    for (const check of this._def.checks) {
      if (check.kind === "min") {
        const tooSmall = check.inclusive ? input.data < check.value : input.data <= check.value;
        if (tooSmall) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.too_small,
            type: "bigint",
            minimum: check.value,
            inclusive: check.inclusive,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "max") {
        const tooBig = check.inclusive ? input.data > check.value : input.data >= check.value;
        if (tooBig) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.too_big,
            type: "bigint",
            maximum: check.value,
            inclusive: check.inclusive,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "multipleOf") {
        if (input.data % check.value !== BigInt(0)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.not_multiple_of,
            multipleOf: check.value,
            message: check.message
          });
          status.dirty();
        }
      } else {
        util.assertNever(check);
      }
    }
    return { status: status.value, value: input.data };
  }
  _getInvalidInput(input) {
    const ctx = this._getOrReturnCtx(input);
    addIssueToContext(ctx, {
      code: ZodIssueCode.invalid_type,
      expected: ZodParsedType.bigint,
      received: ctx.parsedType
    });
    return INVALID;
  }
  gte(value, message) {
    return this.setLimit("min", value, true, errorUtil.toString(message));
  }
  gt(value, message) {
    return this.setLimit("min", value, false, errorUtil.toString(message));
  }
  lte(value, message) {
    return this.setLimit("max", value, true, errorUtil.toString(message));
  }
  lt(value, message) {
    return this.setLimit("max", value, false, errorUtil.toString(message));
  }
  setLimit(kind, value, inclusive, message) {
    return new _ZodBigInt({
      ...this._def,
      checks: [
        ...this._def.checks,
        {
          kind,
          value,
          inclusive,
          message: errorUtil.toString(message)
        }
      ]
    });
  }
  _addCheck(check) {
    return new _ZodBigInt({
      ...this._def,
      checks: [...this._def.checks, check]
    });
  }
  positive(message) {
    return this._addCheck({
      kind: "min",
      value: BigInt(0),
      inclusive: false,
      message: errorUtil.toString(message)
    });
  }
  negative(message) {
    return this._addCheck({
      kind: "max",
      value: BigInt(0),
      inclusive: false,
      message: errorUtil.toString(message)
    });
  }
  nonpositive(message) {
    return this._addCheck({
      kind: "max",
      value: BigInt(0),
      inclusive: true,
      message: errorUtil.toString(message)
    });
  }
  nonnegative(message) {
    return this._addCheck({
      kind: "min",
      value: BigInt(0),
      inclusive: true,
      message: errorUtil.toString(message)
    });
  }
  multipleOf(value, message) {
    return this._addCheck({
      kind: "multipleOf",
      value,
      message: errorUtil.toString(message)
    });
  }
  get minValue() {
    let min = null;
    for (const ch of this._def.checks) {
      if (ch.kind === "min") {
        if (min === null || ch.value > min)
          min = ch.value;
      }
    }
    return min;
  }
  get maxValue() {
    let max = null;
    for (const ch of this._def.checks) {
      if (ch.kind === "max") {
        if (max === null || ch.value < max)
          max = ch.value;
      }
    }
    return max;
  }
};
ZodBigInt.create = (params) => {
  return new ZodBigInt({
    checks: [],
    typeName: ZodFirstPartyTypeKind.ZodBigInt,
    coerce: params?.coerce ?? false,
    ...processCreateParams(params)
  });
};
var ZodBoolean = class extends ZodType {
  _parse(input) {
    if (this._def.coerce) {
      input.data = Boolean(input.data);
    }
    const parsedType = this._getType(input);
    if (parsedType !== ZodParsedType.boolean) {
      const ctx = this._getOrReturnCtx(input);
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.boolean,
        received: ctx.parsedType
      });
      return INVALID;
    }
    return OK(input.data);
  }
};
ZodBoolean.create = (params) => {
  return new ZodBoolean({
    typeName: ZodFirstPartyTypeKind.ZodBoolean,
    coerce: params?.coerce || false,
    ...processCreateParams(params)
  });
};
var ZodDate = class _ZodDate extends ZodType {
  _parse(input) {
    if (this._def.coerce) {
      input.data = new Date(input.data);
    }
    const parsedType = this._getType(input);
    if (parsedType !== ZodParsedType.date) {
      const ctx2 = this._getOrReturnCtx(input);
      addIssueToContext(ctx2, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.date,
        received: ctx2.parsedType
      });
      return INVALID;
    }
    if (Number.isNaN(input.data.getTime())) {
      const ctx2 = this._getOrReturnCtx(input);
      addIssueToContext(ctx2, {
        code: ZodIssueCode.invalid_date
      });
      return INVALID;
    }
    const status = new ParseStatus();
    let ctx = void 0;
    for (const check of this._def.checks) {
      if (check.kind === "min") {
        if (input.data.getTime() < check.value) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.too_small,
            message: check.message,
            inclusive: true,
            exact: false,
            minimum: check.value,
            type: "date"
          });
          status.dirty();
        }
      } else if (check.kind === "max") {
        if (input.data.getTime() > check.value) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.too_big,
            message: check.message,
            inclusive: true,
            exact: false,
            maximum: check.value,
            type: "date"
          });
          status.dirty();
        }
      } else {
        util.assertNever(check);
      }
    }
    return {
      status: status.value,
      value: new Date(input.data.getTime())
    };
  }
  _addCheck(check) {
    return new _ZodDate({
      ...this._def,
      checks: [...this._def.checks, check]
    });
  }
  min(minDate, message) {
    return this._addCheck({
      kind: "min",
      value: minDate.getTime(),
      message: errorUtil.toString(message)
    });
  }
  max(maxDate, message) {
    return this._addCheck({
      kind: "max",
      value: maxDate.getTime(),
      message: errorUtil.toString(message)
    });
  }
  get minDate() {
    let min = null;
    for (const ch of this._def.checks) {
      if (ch.kind === "min") {
        if (min === null || ch.value > min)
          min = ch.value;
      }
    }
    return min != null ? new Date(min) : null;
  }
  get maxDate() {
    let max = null;
    for (const ch of this._def.checks) {
      if (ch.kind === "max") {
        if (max === null || ch.value < max)
          max = ch.value;
      }
    }
    return max != null ? new Date(max) : null;
  }
};
ZodDate.create = (params) => {
  return new ZodDate({
    checks: [],
    coerce: params?.coerce || false,
    typeName: ZodFirstPartyTypeKind.ZodDate,
    ...processCreateParams(params)
  });
};
var ZodSymbol = class extends ZodType {
  _parse(input) {
    const parsedType = this._getType(input);
    if (parsedType !== ZodParsedType.symbol) {
      const ctx = this._getOrReturnCtx(input);
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.symbol,
        received: ctx.parsedType
      });
      return INVALID;
    }
    return OK(input.data);
  }
};
ZodSymbol.create = (params) => {
  return new ZodSymbol({
    typeName: ZodFirstPartyTypeKind.ZodSymbol,
    ...processCreateParams(params)
  });
};
var ZodUndefined = class extends ZodType {
  _parse(input) {
    const parsedType = this._getType(input);
    if (parsedType !== ZodParsedType.undefined) {
      const ctx = this._getOrReturnCtx(input);
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.undefined,
        received: ctx.parsedType
      });
      return INVALID;
    }
    return OK(input.data);
  }
};
ZodUndefined.create = (params) => {
  return new ZodUndefined({
    typeName: ZodFirstPartyTypeKind.ZodUndefined,
    ...processCreateParams(params)
  });
};
var ZodNull = class extends ZodType {
  _parse(input) {
    const parsedType = this._getType(input);
    if (parsedType !== ZodParsedType.null) {
      const ctx = this._getOrReturnCtx(input);
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.null,
        received: ctx.parsedType
      });
      return INVALID;
    }
    return OK(input.data);
  }
};
ZodNull.create = (params) => {
  return new ZodNull({
    typeName: ZodFirstPartyTypeKind.ZodNull,
    ...processCreateParams(params)
  });
};
var ZodAny = class extends ZodType {
  constructor() {
    super(...arguments);
    this._any = true;
  }
  _parse(input) {
    return OK(input.data);
  }
};
ZodAny.create = (params) => {
  return new ZodAny({
    typeName: ZodFirstPartyTypeKind.ZodAny,
    ...processCreateParams(params)
  });
};
var ZodUnknown = class extends ZodType {
  constructor() {
    super(...arguments);
    this._unknown = true;
  }
  _parse(input) {
    return OK(input.data);
  }
};
ZodUnknown.create = (params) => {
  return new ZodUnknown({
    typeName: ZodFirstPartyTypeKind.ZodUnknown,
    ...processCreateParams(params)
  });
};
var ZodNever = class extends ZodType {
  _parse(input) {
    const ctx = this._getOrReturnCtx(input);
    addIssueToContext(ctx, {
      code: ZodIssueCode.invalid_type,
      expected: ZodParsedType.never,
      received: ctx.parsedType
    });
    return INVALID;
  }
};
ZodNever.create = (params) => {
  return new ZodNever({
    typeName: ZodFirstPartyTypeKind.ZodNever,
    ...processCreateParams(params)
  });
};
var ZodVoid = class extends ZodType {
  _parse(input) {
    const parsedType = this._getType(input);
    if (parsedType !== ZodParsedType.undefined) {
      const ctx = this._getOrReturnCtx(input);
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.void,
        received: ctx.parsedType
      });
      return INVALID;
    }
    return OK(input.data);
  }
};
ZodVoid.create = (params) => {
  return new ZodVoid({
    typeName: ZodFirstPartyTypeKind.ZodVoid,
    ...processCreateParams(params)
  });
};
var ZodArray = class _ZodArray extends ZodType {
  _parse(input) {
    const { ctx, status } = this._processInputParams(input);
    const def = this._def;
    if (ctx.parsedType !== ZodParsedType.array) {
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.array,
        received: ctx.parsedType
      });
      return INVALID;
    }
    if (def.exactLength !== null) {
      const tooBig = ctx.data.length > def.exactLength.value;
      const tooSmall = ctx.data.length < def.exactLength.value;
      if (tooBig || tooSmall) {
        addIssueToContext(ctx, {
          code: tooBig ? ZodIssueCode.too_big : ZodIssueCode.too_small,
          minimum: tooSmall ? def.exactLength.value : void 0,
          maximum: tooBig ? def.exactLength.value : void 0,
          type: "array",
          inclusive: true,
          exact: true,
          message: def.exactLength.message
        });
        status.dirty();
      }
    }
    if (def.minLength !== null) {
      if (ctx.data.length < def.minLength.value) {
        addIssueToContext(ctx, {
          code: ZodIssueCode.too_small,
          minimum: def.minLength.value,
          type: "array",
          inclusive: true,
          exact: false,
          message: def.minLength.message
        });
        status.dirty();
      }
    }
    if (def.maxLength !== null) {
      if (ctx.data.length > def.maxLength.value) {
        addIssueToContext(ctx, {
          code: ZodIssueCode.too_big,
          maximum: def.maxLength.value,
          type: "array",
          inclusive: true,
          exact: false,
          message: def.maxLength.message
        });
        status.dirty();
      }
    }
    if (ctx.common.async) {
      return Promise.all([...ctx.data].map((item, i) => {
        return def.type._parseAsync(new ParseInputLazyPath(ctx, item, ctx.path, i));
      })).then((result2) => {
        return ParseStatus.mergeArray(status, result2);
      });
    }
    const result = [...ctx.data].map((item, i) => {
      return def.type._parseSync(new ParseInputLazyPath(ctx, item, ctx.path, i));
    });
    return ParseStatus.mergeArray(status, result);
  }
  get element() {
    return this._def.type;
  }
  min(minLength, message) {
    return new _ZodArray({
      ...this._def,
      minLength: { value: minLength, message: errorUtil.toString(message) }
    });
  }
  max(maxLength, message) {
    return new _ZodArray({
      ...this._def,
      maxLength: { value: maxLength, message: errorUtil.toString(message) }
    });
  }
  length(len, message) {
    return new _ZodArray({
      ...this._def,
      exactLength: { value: len, message: errorUtil.toString(message) }
    });
  }
  nonempty(message) {
    return this.min(1, message);
  }
};
ZodArray.create = (schema, params) => {
  return new ZodArray({
    type: schema,
    minLength: null,
    maxLength: null,
    exactLength: null,
    typeName: ZodFirstPartyTypeKind.ZodArray,
    ...processCreateParams(params)
  });
};
function deepPartialify(schema) {
  if (schema instanceof ZodObject) {
    const newShape = {};
    for (const key in schema.shape) {
      const fieldSchema = schema.shape[key];
      newShape[key] = ZodOptional.create(deepPartialify(fieldSchema));
    }
    return new ZodObject({
      ...schema._def,
      shape: () => newShape
    });
  } else if (schema instanceof ZodArray) {
    return new ZodArray({
      ...schema._def,
      type: deepPartialify(schema.element)
    });
  } else if (schema instanceof ZodOptional) {
    return ZodOptional.create(deepPartialify(schema.unwrap()));
  } else if (schema instanceof ZodNullable) {
    return ZodNullable.create(deepPartialify(schema.unwrap()));
  } else if (schema instanceof ZodTuple) {
    return ZodTuple.create(schema.items.map((item) => deepPartialify(item)));
  } else {
    return schema;
  }
}
var ZodObject = class _ZodObject extends ZodType {
  constructor() {
    super(...arguments);
    this._cached = null;
    this.nonstrict = this.passthrough;
    this.augment = this.extend;
  }
  _getCached() {
    if (this._cached !== null)
      return this._cached;
    const shape = this._def.shape();
    const keys = util.objectKeys(shape);
    this._cached = { shape, keys };
    return this._cached;
  }
  _parse(input) {
    const parsedType = this._getType(input);
    if (parsedType !== ZodParsedType.object) {
      const ctx2 = this._getOrReturnCtx(input);
      addIssueToContext(ctx2, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.object,
        received: ctx2.parsedType
      });
      return INVALID;
    }
    const { status, ctx } = this._processInputParams(input);
    const { shape, keys: shapeKeys } = this._getCached();
    const extraKeys = [];
    if (!(this._def.catchall instanceof ZodNever && this._def.unknownKeys === "strip")) {
      for (const key in ctx.data) {
        if (!shapeKeys.includes(key)) {
          extraKeys.push(key);
        }
      }
    }
    const pairs = [];
    for (const key of shapeKeys) {
      const keyValidator = shape[key];
      const value = ctx.data[key];
      pairs.push({
        key: { status: "valid", value: key },
        value: keyValidator._parse(new ParseInputLazyPath(ctx, value, ctx.path, key)),
        alwaysSet: key in ctx.data
      });
    }
    if (this._def.catchall instanceof ZodNever) {
      const unknownKeys = this._def.unknownKeys;
      if (unknownKeys === "passthrough") {
        for (const key of extraKeys) {
          pairs.push({
            key: { status: "valid", value: key },
            value: { status: "valid", value: ctx.data[key] }
          });
        }
      } else if (unknownKeys === "strict") {
        if (extraKeys.length > 0) {
          addIssueToContext(ctx, {
            code: ZodIssueCode.unrecognized_keys,
            keys: extraKeys
          });
          status.dirty();
        }
      } else if (unknownKeys === "strip") {
      } else {
        throw new Error(`Internal ZodObject error: invalid unknownKeys value.`);
      }
    } else {
      const catchall = this._def.catchall;
      for (const key of extraKeys) {
        const value = ctx.data[key];
        pairs.push({
          key: { status: "valid", value: key },
          value: catchall._parse(
            new ParseInputLazyPath(ctx, value, ctx.path, key)
            //, ctx.child(key), value, getParsedType(value)
          ),
          alwaysSet: key in ctx.data
        });
      }
    }
    if (ctx.common.async) {
      return Promise.resolve().then(async () => {
        const syncPairs = [];
        for (const pair of pairs) {
          const key = await pair.key;
          const value = await pair.value;
          syncPairs.push({
            key,
            value,
            alwaysSet: pair.alwaysSet
          });
        }
        return syncPairs;
      }).then((syncPairs) => {
        return ParseStatus.mergeObjectSync(status, syncPairs);
      });
    } else {
      return ParseStatus.mergeObjectSync(status, pairs);
    }
  }
  get shape() {
    return this._def.shape();
  }
  strict(message) {
    errorUtil.errToObj;
    return new _ZodObject({
      ...this._def,
      unknownKeys: "strict",
      ...message !== void 0 ? {
        errorMap: (issue, ctx) => {
          const defaultError = this._def.errorMap?.(issue, ctx).message ?? ctx.defaultError;
          if (issue.code === "unrecognized_keys")
            return {
              message: errorUtil.errToObj(message).message ?? defaultError
            };
          return {
            message: defaultError
          };
        }
      } : {}
    });
  }
  strip() {
    return new _ZodObject({
      ...this._def,
      unknownKeys: "strip"
    });
  }
  passthrough() {
    return new _ZodObject({
      ...this._def,
      unknownKeys: "passthrough"
    });
  }
  // const AugmentFactory =
  //   <Def extends ZodObjectDef>(def: Def) =>
  //   <Augmentation extends ZodRawShape>(
  //     augmentation: Augmentation
  //   ): ZodObject<
  //     extendShape<ReturnType<Def["shape"]>, Augmentation>,
  //     Def["unknownKeys"],
  //     Def["catchall"]
  //   > => {
  //     return new ZodObject({
  //       ...def,
  //       shape: () => ({
  //         ...def.shape(),
  //         ...augmentation,
  //       }),
  //     }) as any;
  //   };
  extend(augmentation) {
    return new _ZodObject({
      ...this._def,
      shape: () => ({
        ...this._def.shape(),
        ...augmentation
      })
    });
  }
  /**
   * Prior to zod@1.0.12 there was a bug in the
   * inferred type of merged objects. Please
   * upgrade if you are experiencing issues.
   */
  merge(merging) {
    const merged = new _ZodObject({
      unknownKeys: merging._def.unknownKeys,
      catchall: merging._def.catchall,
      shape: () => ({
        ...this._def.shape(),
        ...merging._def.shape()
      }),
      typeName: ZodFirstPartyTypeKind.ZodObject
    });
    return merged;
  }
  // merge<
  //   Incoming extends AnyZodObject,
  //   Augmentation extends Incoming["shape"],
  //   NewOutput extends {
  //     [k in keyof Augmentation | keyof Output]: k extends keyof Augmentation
  //       ? Augmentation[k]["_output"]
  //       : k extends keyof Output
  //       ? Output[k]
  //       : never;
  //   },
  //   NewInput extends {
  //     [k in keyof Augmentation | keyof Input]: k extends keyof Augmentation
  //       ? Augmentation[k]["_input"]
  //       : k extends keyof Input
  //       ? Input[k]
  //       : never;
  //   }
  // >(
  //   merging: Incoming
  // ): ZodObject<
  //   extendShape<T, ReturnType<Incoming["_def"]["shape"]>>,
  //   Incoming["_def"]["unknownKeys"],
  //   Incoming["_def"]["catchall"],
  //   NewOutput,
  //   NewInput
  // > {
  //   const merged: any = new ZodObject({
  //     unknownKeys: merging._def.unknownKeys,
  //     catchall: merging._def.catchall,
  //     shape: () =>
  //       objectUtil.mergeShapes(this._def.shape(), merging._def.shape()),
  //     typeName: ZodFirstPartyTypeKind.ZodObject,
  //   }) as any;
  //   return merged;
  // }
  setKey(key, schema) {
    return this.augment({ [key]: schema });
  }
  // merge<Incoming extends AnyZodObject>(
  //   merging: Incoming
  // ): //ZodObject<T & Incoming["_shape"], UnknownKeys, Catchall> = (merging) => {
  // ZodObject<
  //   extendShape<T, ReturnType<Incoming["_def"]["shape"]>>,
  //   Incoming["_def"]["unknownKeys"],
  //   Incoming["_def"]["catchall"]
  // > {
  //   // const mergedShape = objectUtil.mergeShapes(
  //   //   this._def.shape(),
  //   //   merging._def.shape()
  //   // );
  //   const merged: any = new ZodObject({
  //     unknownKeys: merging._def.unknownKeys,
  //     catchall: merging._def.catchall,
  //     shape: () =>
  //       objectUtil.mergeShapes(this._def.shape(), merging._def.shape()),
  //     typeName: ZodFirstPartyTypeKind.ZodObject,
  //   }) as any;
  //   return merged;
  // }
  catchall(index) {
    return new _ZodObject({
      ...this._def,
      catchall: index
    });
  }
  pick(mask) {
    const shape = {};
    for (const key of util.objectKeys(mask)) {
      if (mask[key] && this.shape[key]) {
        shape[key] = this.shape[key];
      }
    }
    return new _ZodObject({
      ...this._def,
      shape: () => shape
    });
  }
  omit(mask) {
    const shape = {};
    for (const key of util.objectKeys(this.shape)) {
      if (!mask[key]) {
        shape[key] = this.shape[key];
      }
    }
    return new _ZodObject({
      ...this._def,
      shape: () => shape
    });
  }
  /**
   * @deprecated
   */
  deepPartial() {
    return deepPartialify(this);
  }
  partial(mask) {
    const newShape = {};
    for (const key of util.objectKeys(this.shape)) {
      const fieldSchema = this.shape[key];
      if (mask && !mask[key]) {
        newShape[key] = fieldSchema;
      } else {
        newShape[key] = fieldSchema.optional();
      }
    }
    return new _ZodObject({
      ...this._def,
      shape: () => newShape
    });
  }
  required(mask) {
    const newShape = {};
    for (const key of util.objectKeys(this.shape)) {
      if (mask && !mask[key]) {
        newShape[key] = this.shape[key];
      } else {
        const fieldSchema = this.shape[key];
        let newField = fieldSchema;
        while (newField instanceof ZodOptional) {
          newField = newField._def.innerType;
        }
        newShape[key] = newField;
      }
    }
    return new _ZodObject({
      ...this._def,
      shape: () => newShape
    });
  }
  keyof() {
    return createZodEnum(util.objectKeys(this.shape));
  }
};
ZodObject.create = (shape, params) => {
  return new ZodObject({
    shape: () => shape,
    unknownKeys: "strip",
    catchall: ZodNever.create(),
    typeName: ZodFirstPartyTypeKind.ZodObject,
    ...processCreateParams(params)
  });
};
ZodObject.strictCreate = (shape, params) => {
  return new ZodObject({
    shape: () => shape,
    unknownKeys: "strict",
    catchall: ZodNever.create(),
    typeName: ZodFirstPartyTypeKind.ZodObject,
    ...processCreateParams(params)
  });
};
ZodObject.lazycreate = (shape, params) => {
  return new ZodObject({
    shape,
    unknownKeys: "strip",
    catchall: ZodNever.create(),
    typeName: ZodFirstPartyTypeKind.ZodObject,
    ...processCreateParams(params)
  });
};
var ZodUnion = class extends ZodType {
  _parse(input) {
    const { ctx } = this._processInputParams(input);
    const options = this._def.options;
    function handleResults(results) {
      for (const result of results) {
        if (result.result.status === "valid") {
          return result.result;
        }
      }
      for (const result of results) {
        if (result.result.status === "dirty") {
          ctx.common.issues.push(...result.ctx.common.issues);
          return result.result;
        }
      }
      const unionErrors = results.map((result) => new ZodError(result.ctx.common.issues));
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_union,
        unionErrors
      });
      return INVALID;
    }
    if (ctx.common.async) {
      return Promise.all(options.map(async (option) => {
        const childCtx = {
          ...ctx,
          common: {
            ...ctx.common,
            issues: []
          },
          parent: null
        };
        return {
          result: await option._parseAsync({
            data: ctx.data,
            path: ctx.path,
            parent: childCtx
          }),
          ctx: childCtx
        };
      })).then(handleResults);
    } else {
      let dirty = void 0;
      const issues = [];
      for (const option of options) {
        const childCtx = {
          ...ctx,
          common: {
            ...ctx.common,
            issues: []
          },
          parent: null
        };
        const result = option._parseSync({
          data: ctx.data,
          path: ctx.path,
          parent: childCtx
        });
        if (result.status === "valid") {
          return result;
        } else if (result.status === "dirty" && !dirty) {
          dirty = { result, ctx: childCtx };
        }
        if (childCtx.common.issues.length) {
          issues.push(childCtx.common.issues);
        }
      }
      if (dirty) {
        ctx.common.issues.push(...dirty.ctx.common.issues);
        return dirty.result;
      }
      const unionErrors = issues.map((issues2) => new ZodError(issues2));
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_union,
        unionErrors
      });
      return INVALID;
    }
  }
  get options() {
    return this._def.options;
  }
};
ZodUnion.create = (types, params) => {
  return new ZodUnion({
    options: types,
    typeName: ZodFirstPartyTypeKind.ZodUnion,
    ...processCreateParams(params)
  });
};
var getDiscriminator = (type) => {
  if (type instanceof ZodLazy) {
    return getDiscriminator(type.schema);
  } else if (type instanceof ZodEffects) {
    return getDiscriminator(type.innerType());
  } else if (type instanceof ZodLiteral) {
    return [type.value];
  } else if (type instanceof ZodEnum) {
    return type.options;
  } else if (type instanceof ZodNativeEnum) {
    return util.objectValues(type.enum);
  } else if (type instanceof ZodDefault) {
    return getDiscriminator(type._def.innerType);
  } else if (type instanceof ZodUndefined) {
    return [void 0];
  } else if (type instanceof ZodNull) {
    return [null];
  } else if (type instanceof ZodOptional) {
    return [void 0, ...getDiscriminator(type.unwrap())];
  } else if (type instanceof ZodNullable) {
    return [null, ...getDiscriminator(type.unwrap())];
  } else if (type instanceof ZodBranded) {
    return getDiscriminator(type.unwrap());
  } else if (type instanceof ZodReadonly) {
    return getDiscriminator(type.unwrap());
  } else if (type instanceof ZodCatch) {
    return getDiscriminator(type._def.innerType);
  } else {
    return [];
  }
};
var ZodDiscriminatedUnion = class _ZodDiscriminatedUnion extends ZodType {
  _parse(input) {
    const { ctx } = this._processInputParams(input);
    if (ctx.parsedType !== ZodParsedType.object) {
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.object,
        received: ctx.parsedType
      });
      return INVALID;
    }
    const discriminator = this.discriminator;
    const discriminatorValue = ctx.data[discriminator];
    const option = this.optionsMap.get(discriminatorValue);
    if (!option) {
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_union_discriminator,
        options: Array.from(this.optionsMap.keys()),
        path: [discriminator]
      });
      return INVALID;
    }
    if (ctx.common.async) {
      return option._parseAsync({
        data: ctx.data,
        path: ctx.path,
        parent: ctx
      });
    } else {
      return option._parseSync({
        data: ctx.data,
        path: ctx.path,
        parent: ctx
      });
    }
  }
  get discriminator() {
    return this._def.discriminator;
  }
  get options() {
    return this._def.options;
  }
  get optionsMap() {
    return this._def.optionsMap;
  }
  /**
   * The constructor of the discriminated union schema. Its behaviour is very similar to that of the normal z.union() constructor.
   * However, it only allows a union of objects, all of which need to share a discriminator property. This property must
   * have a different value for each object in the union.
   * @param discriminator the name of the discriminator property
   * @param types an array of object schemas
   * @param params
   */
  static create(discriminator, options, params) {
    const optionsMap = /* @__PURE__ */ new Map();
    for (const type of options) {
      const discriminatorValues = getDiscriminator(type.shape[discriminator]);
      if (!discriminatorValues.length) {
        throw new Error(`A discriminator value for key \`${discriminator}\` could not be extracted from all schema options`);
      }
      for (const value of discriminatorValues) {
        if (optionsMap.has(value)) {
          throw new Error(`Discriminator property ${String(discriminator)} has duplicate value ${String(value)}`);
        }
        optionsMap.set(value, type);
      }
    }
    return new _ZodDiscriminatedUnion({
      typeName: ZodFirstPartyTypeKind.ZodDiscriminatedUnion,
      discriminator,
      options,
      optionsMap,
      ...processCreateParams(params)
    });
  }
};
function mergeValues(a, b) {
  const aType = getParsedType(a);
  const bType = getParsedType(b);
  if (a === b) {
    return { valid: true, data: a };
  } else if (aType === ZodParsedType.object && bType === ZodParsedType.object) {
    const bKeys = util.objectKeys(b);
    const sharedKeys = util.objectKeys(a).filter((key) => bKeys.indexOf(key) !== -1);
    const newObj = { ...a, ...b };
    for (const key of sharedKeys) {
      const sharedValue = mergeValues(a[key], b[key]);
      if (!sharedValue.valid) {
        return { valid: false };
      }
      newObj[key] = sharedValue.data;
    }
    return { valid: true, data: newObj };
  } else if (aType === ZodParsedType.array && bType === ZodParsedType.array) {
    if (a.length !== b.length) {
      return { valid: false };
    }
    const newArray = [];
    for (let index = 0; index < a.length; index++) {
      const itemA = a[index];
      const itemB = b[index];
      const sharedValue = mergeValues(itemA, itemB);
      if (!sharedValue.valid) {
        return { valid: false };
      }
      newArray.push(sharedValue.data);
    }
    return { valid: true, data: newArray };
  } else if (aType === ZodParsedType.date && bType === ZodParsedType.date && +a === +b) {
    return { valid: true, data: a };
  } else {
    return { valid: false };
  }
}
var ZodIntersection = class extends ZodType {
  _parse(input) {
    const { status, ctx } = this._processInputParams(input);
    const handleParsed = (parsedLeft, parsedRight) => {
      if (isAborted(parsedLeft) || isAborted(parsedRight)) {
        return INVALID;
      }
      const merged = mergeValues(parsedLeft.value, parsedRight.value);
      if (!merged.valid) {
        addIssueToContext(ctx, {
          code: ZodIssueCode.invalid_intersection_types
        });
        return INVALID;
      }
      if (isDirty(parsedLeft) || isDirty(parsedRight)) {
        status.dirty();
      }
      return { status: status.value, value: merged.data };
    };
    if (ctx.common.async) {
      return Promise.all([
        this._def.left._parseAsync({
          data: ctx.data,
          path: ctx.path,
          parent: ctx
        }),
        this._def.right._parseAsync({
          data: ctx.data,
          path: ctx.path,
          parent: ctx
        })
      ]).then(([left, right]) => handleParsed(left, right));
    } else {
      return handleParsed(this._def.left._parseSync({
        data: ctx.data,
        path: ctx.path,
        parent: ctx
      }), this._def.right._parseSync({
        data: ctx.data,
        path: ctx.path,
        parent: ctx
      }));
    }
  }
};
ZodIntersection.create = (left, right, params) => {
  return new ZodIntersection({
    left,
    right,
    typeName: ZodFirstPartyTypeKind.ZodIntersection,
    ...processCreateParams(params)
  });
};
var ZodTuple = class _ZodTuple extends ZodType {
  _parse(input) {
    const { status, ctx } = this._processInputParams(input);
    if (ctx.parsedType !== ZodParsedType.array) {
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.array,
        received: ctx.parsedType
      });
      return INVALID;
    }
    if (ctx.data.length < this._def.items.length) {
      addIssueToContext(ctx, {
        code: ZodIssueCode.too_small,
        minimum: this._def.items.length,
        inclusive: true,
        exact: false,
        type: "array"
      });
      return INVALID;
    }
    const rest = this._def.rest;
    if (!rest && ctx.data.length > this._def.items.length) {
      addIssueToContext(ctx, {
        code: ZodIssueCode.too_big,
        maximum: this._def.items.length,
        inclusive: true,
        exact: false,
        type: "array"
      });
      status.dirty();
    }
    const items = [...ctx.data].map((item, itemIndex) => {
      const schema = this._def.items[itemIndex] || this._def.rest;
      if (!schema)
        return null;
      return schema._parse(new ParseInputLazyPath(ctx, item, ctx.path, itemIndex));
    }).filter((x) => !!x);
    if (ctx.common.async) {
      return Promise.all(items).then((results) => {
        return ParseStatus.mergeArray(status, results);
      });
    } else {
      return ParseStatus.mergeArray(status, items);
    }
  }
  get items() {
    return this._def.items;
  }
  rest(rest) {
    return new _ZodTuple({
      ...this._def,
      rest
    });
  }
};
ZodTuple.create = (schemas, params) => {
  if (!Array.isArray(schemas)) {
    throw new Error("You must pass an array of schemas to z.tuple([ ... ])");
  }
  return new ZodTuple({
    items: schemas,
    typeName: ZodFirstPartyTypeKind.ZodTuple,
    rest: null,
    ...processCreateParams(params)
  });
};
var ZodRecord = class _ZodRecord extends ZodType {
  get keySchema() {
    return this._def.keyType;
  }
  get valueSchema() {
    return this._def.valueType;
  }
  _parse(input) {
    const { status, ctx } = this._processInputParams(input);
    if (ctx.parsedType !== ZodParsedType.object) {
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.object,
        received: ctx.parsedType
      });
      return INVALID;
    }
    const pairs = [];
    const keyType = this._def.keyType;
    const valueType = this._def.valueType;
    for (const key in ctx.data) {
      pairs.push({
        key: keyType._parse(new ParseInputLazyPath(ctx, key, ctx.path, key)),
        value: valueType._parse(new ParseInputLazyPath(ctx, ctx.data[key], ctx.path, key)),
        alwaysSet: key in ctx.data
      });
    }
    if (ctx.common.async) {
      return ParseStatus.mergeObjectAsync(status, pairs);
    } else {
      return ParseStatus.mergeObjectSync(status, pairs);
    }
  }
  get element() {
    return this._def.valueType;
  }
  static create(first, second, third) {
    if (second instanceof ZodType) {
      return new _ZodRecord({
        keyType: first,
        valueType: second,
        typeName: ZodFirstPartyTypeKind.ZodRecord,
        ...processCreateParams(third)
      });
    }
    return new _ZodRecord({
      keyType: ZodString.create(),
      valueType: first,
      typeName: ZodFirstPartyTypeKind.ZodRecord,
      ...processCreateParams(second)
    });
  }
};
var ZodMap = class extends ZodType {
  get keySchema() {
    return this._def.keyType;
  }
  get valueSchema() {
    return this._def.valueType;
  }
  _parse(input) {
    const { status, ctx } = this._processInputParams(input);
    if (ctx.parsedType !== ZodParsedType.map) {
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.map,
        received: ctx.parsedType
      });
      return INVALID;
    }
    const keyType = this._def.keyType;
    const valueType = this._def.valueType;
    const pairs = [...ctx.data.entries()].map(([key, value], index) => {
      return {
        key: keyType._parse(new ParseInputLazyPath(ctx, key, ctx.path, [index, "key"])),
        value: valueType._parse(new ParseInputLazyPath(ctx, value, ctx.path, [index, "value"]))
      };
    });
    if (ctx.common.async) {
      const finalMap = /* @__PURE__ */ new Map();
      return Promise.resolve().then(async () => {
        for (const pair of pairs) {
          const key = await pair.key;
          const value = await pair.value;
          if (key.status === "aborted" || value.status === "aborted") {
            return INVALID;
          }
          if (key.status === "dirty" || value.status === "dirty") {
            status.dirty();
          }
          finalMap.set(key.value, value.value);
        }
        return { status: status.value, value: finalMap };
      });
    } else {
      const finalMap = /* @__PURE__ */ new Map();
      for (const pair of pairs) {
        const key = pair.key;
        const value = pair.value;
        if (key.status === "aborted" || value.status === "aborted") {
          return INVALID;
        }
        if (key.status === "dirty" || value.status === "dirty") {
          status.dirty();
        }
        finalMap.set(key.value, value.value);
      }
      return { status: status.value, value: finalMap };
    }
  }
};
ZodMap.create = (keyType, valueType, params) => {
  return new ZodMap({
    valueType,
    keyType,
    typeName: ZodFirstPartyTypeKind.ZodMap,
    ...processCreateParams(params)
  });
};
var ZodSet = class _ZodSet extends ZodType {
  _parse(input) {
    const { status, ctx } = this._processInputParams(input);
    if (ctx.parsedType !== ZodParsedType.set) {
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.set,
        received: ctx.parsedType
      });
      return INVALID;
    }
    const def = this._def;
    if (def.minSize !== null) {
      if (ctx.data.size < def.minSize.value) {
        addIssueToContext(ctx, {
          code: ZodIssueCode.too_small,
          minimum: def.minSize.value,
          type: "set",
          inclusive: true,
          exact: false,
          message: def.minSize.message
        });
        status.dirty();
      }
    }
    if (def.maxSize !== null) {
      if (ctx.data.size > def.maxSize.value) {
        addIssueToContext(ctx, {
          code: ZodIssueCode.too_big,
          maximum: def.maxSize.value,
          type: "set",
          inclusive: true,
          exact: false,
          message: def.maxSize.message
        });
        status.dirty();
      }
    }
    const valueType = this._def.valueType;
    function finalizeSet(elements2) {
      const parsedSet = /* @__PURE__ */ new Set();
      for (const element of elements2) {
        if (element.status === "aborted")
          return INVALID;
        if (element.status === "dirty")
          status.dirty();
        parsedSet.add(element.value);
      }
      return { status: status.value, value: parsedSet };
    }
    const elements = [...ctx.data.values()].map((item, i) => valueType._parse(new ParseInputLazyPath(ctx, item, ctx.path, i)));
    if (ctx.common.async) {
      return Promise.all(elements).then((elements2) => finalizeSet(elements2));
    } else {
      return finalizeSet(elements);
    }
  }
  min(minSize, message) {
    return new _ZodSet({
      ...this._def,
      minSize: { value: minSize, message: errorUtil.toString(message) }
    });
  }
  max(maxSize, message) {
    return new _ZodSet({
      ...this._def,
      maxSize: { value: maxSize, message: errorUtil.toString(message) }
    });
  }
  size(size, message) {
    return this.min(size, message).max(size, message);
  }
  nonempty(message) {
    return this.min(1, message);
  }
};
ZodSet.create = (valueType, params) => {
  return new ZodSet({
    valueType,
    minSize: null,
    maxSize: null,
    typeName: ZodFirstPartyTypeKind.ZodSet,
    ...processCreateParams(params)
  });
};
var ZodFunction = class _ZodFunction extends ZodType {
  constructor() {
    super(...arguments);
    this.validate = this.implement;
  }
  _parse(input) {
    const { ctx } = this._processInputParams(input);
    if (ctx.parsedType !== ZodParsedType.function) {
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.function,
        received: ctx.parsedType
      });
      return INVALID;
    }
    function makeArgsIssue(args, error) {
      return makeIssue({
        data: args,
        path: ctx.path,
        errorMaps: [ctx.common.contextualErrorMap, ctx.schemaErrorMap, getErrorMap(), en_default].filter((x) => !!x),
        issueData: {
          code: ZodIssueCode.invalid_arguments,
          argumentsError: error
        }
      });
    }
    function makeReturnsIssue(returns, error) {
      return makeIssue({
        data: returns,
        path: ctx.path,
        errorMaps: [ctx.common.contextualErrorMap, ctx.schemaErrorMap, getErrorMap(), en_default].filter((x) => !!x),
        issueData: {
          code: ZodIssueCode.invalid_return_type,
          returnTypeError: error
        }
      });
    }
    const params = { errorMap: ctx.common.contextualErrorMap };
    const fn = ctx.data;
    if (this._def.returns instanceof ZodPromise) {
      const me = this;
      return OK(async function(...args) {
        const error = new ZodError([]);
        const parsedArgs = await me._def.args.parseAsync(args, params).catch((e) => {
          error.addIssue(makeArgsIssue(args, e));
          throw error;
        });
        const result = await Reflect.apply(fn, this, parsedArgs);
        const parsedReturns = await me._def.returns._def.type.parseAsync(result, params).catch((e) => {
          error.addIssue(makeReturnsIssue(result, e));
          throw error;
        });
        return parsedReturns;
      });
    } else {
      const me = this;
      return OK(function(...args) {
        const parsedArgs = me._def.args.safeParse(args, params);
        if (!parsedArgs.success) {
          throw new ZodError([makeArgsIssue(args, parsedArgs.error)]);
        }
        const result = Reflect.apply(fn, this, parsedArgs.data);
        const parsedReturns = me._def.returns.safeParse(result, params);
        if (!parsedReturns.success) {
          throw new ZodError([makeReturnsIssue(result, parsedReturns.error)]);
        }
        return parsedReturns.data;
      });
    }
  }
  parameters() {
    return this._def.args;
  }
  returnType() {
    return this._def.returns;
  }
  args(...items) {
    return new _ZodFunction({
      ...this._def,
      args: ZodTuple.create(items).rest(ZodUnknown.create())
    });
  }
  returns(returnType) {
    return new _ZodFunction({
      ...this._def,
      returns: returnType
    });
  }
  implement(func) {
    const validatedFunc = this.parse(func);
    return validatedFunc;
  }
  strictImplement(func) {
    const validatedFunc = this.parse(func);
    return validatedFunc;
  }
  static create(args, returns, params) {
    return new _ZodFunction({
      args: args ? args : ZodTuple.create([]).rest(ZodUnknown.create()),
      returns: returns || ZodUnknown.create(),
      typeName: ZodFirstPartyTypeKind.ZodFunction,
      ...processCreateParams(params)
    });
  }
};
var ZodLazy = class extends ZodType {
  get schema() {
    return this._def.getter();
  }
  _parse(input) {
    const { ctx } = this._processInputParams(input);
    const lazySchema = this._def.getter();
    return lazySchema._parse({ data: ctx.data, path: ctx.path, parent: ctx });
  }
};
ZodLazy.create = (getter, params) => {
  return new ZodLazy({
    getter,
    typeName: ZodFirstPartyTypeKind.ZodLazy,
    ...processCreateParams(params)
  });
};
var ZodLiteral = class extends ZodType {
  _parse(input) {
    if (input.data !== this._def.value) {
      const ctx = this._getOrReturnCtx(input);
      addIssueToContext(ctx, {
        received: ctx.data,
        code: ZodIssueCode.invalid_literal,
        expected: this._def.value
      });
      return INVALID;
    }
    return { status: "valid", value: input.data };
  }
  get value() {
    return this._def.value;
  }
};
ZodLiteral.create = (value, params) => {
  return new ZodLiteral({
    value,
    typeName: ZodFirstPartyTypeKind.ZodLiteral,
    ...processCreateParams(params)
  });
};
function createZodEnum(values, params) {
  return new ZodEnum({
    values,
    typeName: ZodFirstPartyTypeKind.ZodEnum,
    ...processCreateParams(params)
  });
}
var ZodEnum = class _ZodEnum extends ZodType {
  _parse(input) {
    if (typeof input.data !== "string") {
      const ctx = this._getOrReturnCtx(input);
      const expectedValues = this._def.values;
      addIssueToContext(ctx, {
        expected: util.joinValues(expectedValues),
        received: ctx.parsedType,
        code: ZodIssueCode.invalid_type
      });
      return INVALID;
    }
    if (!this._cache) {
      this._cache = new Set(this._def.values);
    }
    if (!this._cache.has(input.data)) {
      const ctx = this._getOrReturnCtx(input);
      const expectedValues = this._def.values;
      addIssueToContext(ctx, {
        received: ctx.data,
        code: ZodIssueCode.invalid_enum_value,
        options: expectedValues
      });
      return INVALID;
    }
    return OK(input.data);
  }
  get options() {
    return this._def.values;
  }
  get enum() {
    const enumValues = {};
    for (const val of this._def.values) {
      enumValues[val] = val;
    }
    return enumValues;
  }
  get Values() {
    const enumValues = {};
    for (const val of this._def.values) {
      enumValues[val] = val;
    }
    return enumValues;
  }
  get Enum() {
    const enumValues = {};
    for (const val of this._def.values) {
      enumValues[val] = val;
    }
    return enumValues;
  }
  extract(values, newDef = this._def) {
    return _ZodEnum.create(values, {
      ...this._def,
      ...newDef
    });
  }
  exclude(values, newDef = this._def) {
    return _ZodEnum.create(this.options.filter((opt) => !values.includes(opt)), {
      ...this._def,
      ...newDef
    });
  }
};
ZodEnum.create = createZodEnum;
var ZodNativeEnum = class extends ZodType {
  _parse(input) {
    const nativeEnumValues = util.getValidEnumValues(this._def.values);
    const ctx = this._getOrReturnCtx(input);
    if (ctx.parsedType !== ZodParsedType.string && ctx.parsedType !== ZodParsedType.number) {
      const expectedValues = util.objectValues(nativeEnumValues);
      addIssueToContext(ctx, {
        expected: util.joinValues(expectedValues),
        received: ctx.parsedType,
        code: ZodIssueCode.invalid_type
      });
      return INVALID;
    }
    if (!this._cache) {
      this._cache = new Set(util.getValidEnumValues(this._def.values));
    }
    if (!this._cache.has(input.data)) {
      const expectedValues = util.objectValues(nativeEnumValues);
      addIssueToContext(ctx, {
        received: ctx.data,
        code: ZodIssueCode.invalid_enum_value,
        options: expectedValues
      });
      return INVALID;
    }
    return OK(input.data);
  }
  get enum() {
    return this._def.values;
  }
};
ZodNativeEnum.create = (values, params) => {
  return new ZodNativeEnum({
    values,
    typeName: ZodFirstPartyTypeKind.ZodNativeEnum,
    ...processCreateParams(params)
  });
};
var ZodPromise = class extends ZodType {
  unwrap() {
    return this._def.type;
  }
  _parse(input) {
    const { ctx } = this._processInputParams(input);
    if (ctx.parsedType !== ZodParsedType.promise && ctx.common.async === false) {
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.promise,
        received: ctx.parsedType
      });
      return INVALID;
    }
    const promisified = ctx.parsedType === ZodParsedType.promise ? ctx.data : Promise.resolve(ctx.data);
    return OK(promisified.then((data) => {
      return this._def.type.parseAsync(data, {
        path: ctx.path,
        errorMap: ctx.common.contextualErrorMap
      });
    }));
  }
};
ZodPromise.create = (schema, params) => {
  return new ZodPromise({
    type: schema,
    typeName: ZodFirstPartyTypeKind.ZodPromise,
    ...processCreateParams(params)
  });
};
var ZodEffects = class extends ZodType {
  innerType() {
    return this._def.schema;
  }
  sourceType() {
    return this._def.schema._def.typeName === ZodFirstPartyTypeKind.ZodEffects ? this._def.schema.sourceType() : this._def.schema;
  }
  _parse(input) {
    const { status, ctx } = this._processInputParams(input);
    const effect = this._def.effect || null;
    const checkCtx = {
      addIssue: (arg) => {
        addIssueToContext(ctx, arg);
        if (arg.fatal) {
          status.abort();
        } else {
          status.dirty();
        }
      },
      get path() {
        return ctx.path;
      }
    };
    checkCtx.addIssue = checkCtx.addIssue.bind(checkCtx);
    if (effect.type === "preprocess") {
      const processed = effect.transform(ctx.data, checkCtx);
      if (ctx.common.async) {
        return Promise.resolve(processed).then(async (processed2) => {
          if (status.value === "aborted")
            return INVALID;
          const result = await this._def.schema._parseAsync({
            data: processed2,
            path: ctx.path,
            parent: ctx
          });
          if (result.status === "aborted")
            return INVALID;
          if (result.status === "dirty")
            return DIRTY(result.value);
          if (status.value === "dirty")
            return DIRTY(result.value);
          return result;
        });
      } else {
        if (status.value === "aborted")
          return INVALID;
        const result = this._def.schema._parseSync({
          data: processed,
          path: ctx.path,
          parent: ctx
        });
        if (result.status === "aborted")
          return INVALID;
        if (result.status === "dirty")
          return DIRTY(result.value);
        if (status.value === "dirty")
          return DIRTY(result.value);
        return result;
      }
    }
    if (effect.type === "refinement") {
      const executeRefinement = (acc) => {
        const result = effect.refinement(acc, checkCtx);
        if (ctx.common.async) {
          return Promise.resolve(result);
        }
        if (result instanceof Promise) {
          throw new Error("Async refinement encountered during synchronous parse operation. Use .parseAsync instead.");
        }
        return acc;
      };
      if (ctx.common.async === false) {
        const inner = this._def.schema._parseSync({
          data: ctx.data,
          path: ctx.path,
          parent: ctx
        });
        if (inner.status === "aborted")
          return INVALID;
        if (inner.status === "dirty")
          status.dirty();
        executeRefinement(inner.value);
        return { status: status.value, value: inner.value };
      } else {
        return this._def.schema._parseAsync({ data: ctx.data, path: ctx.path, parent: ctx }).then((inner) => {
          if (inner.status === "aborted")
            return INVALID;
          if (inner.status === "dirty")
            status.dirty();
          return executeRefinement(inner.value).then(() => {
            return { status: status.value, value: inner.value };
          });
        });
      }
    }
    if (effect.type === "transform") {
      if (ctx.common.async === false) {
        const base = this._def.schema._parseSync({
          data: ctx.data,
          path: ctx.path,
          parent: ctx
        });
        if (!isValid(base))
          return INVALID;
        const result = effect.transform(base.value, checkCtx);
        if (result instanceof Promise) {
          throw new Error(`Asynchronous transform encountered during synchronous parse operation. Use .parseAsync instead.`);
        }
        return { status: status.value, value: result };
      } else {
        return this._def.schema._parseAsync({ data: ctx.data, path: ctx.path, parent: ctx }).then((base) => {
          if (!isValid(base))
            return INVALID;
          return Promise.resolve(effect.transform(base.value, checkCtx)).then((result) => ({
            status: status.value,
            value: result
          }));
        });
      }
    }
    util.assertNever(effect);
  }
};
ZodEffects.create = (schema, effect, params) => {
  return new ZodEffects({
    schema,
    typeName: ZodFirstPartyTypeKind.ZodEffects,
    effect,
    ...processCreateParams(params)
  });
};
ZodEffects.createWithPreprocess = (preprocess, schema, params) => {
  return new ZodEffects({
    schema,
    effect: { type: "preprocess", transform: preprocess },
    typeName: ZodFirstPartyTypeKind.ZodEffects,
    ...processCreateParams(params)
  });
};
var ZodOptional = class extends ZodType {
  _parse(input) {
    const parsedType = this._getType(input);
    if (parsedType === ZodParsedType.undefined) {
      return OK(void 0);
    }
    return this._def.innerType._parse(input);
  }
  unwrap() {
    return this._def.innerType;
  }
};
ZodOptional.create = (type, params) => {
  return new ZodOptional({
    innerType: type,
    typeName: ZodFirstPartyTypeKind.ZodOptional,
    ...processCreateParams(params)
  });
};
var ZodNullable = class extends ZodType {
  _parse(input) {
    const parsedType = this._getType(input);
    if (parsedType === ZodParsedType.null) {
      return OK(null);
    }
    return this._def.innerType._parse(input);
  }
  unwrap() {
    return this._def.innerType;
  }
};
ZodNullable.create = (type, params) => {
  return new ZodNullable({
    innerType: type,
    typeName: ZodFirstPartyTypeKind.ZodNullable,
    ...processCreateParams(params)
  });
};
var ZodDefault = class extends ZodType {
  _parse(input) {
    const { ctx } = this._processInputParams(input);
    let data = ctx.data;
    if (ctx.parsedType === ZodParsedType.undefined) {
      data = this._def.defaultValue();
    }
    return this._def.innerType._parse({
      data,
      path: ctx.path,
      parent: ctx
    });
  }
  removeDefault() {
    return this._def.innerType;
  }
};
ZodDefault.create = (type, params) => {
  return new ZodDefault({
    innerType: type,
    typeName: ZodFirstPartyTypeKind.ZodDefault,
    defaultValue: typeof params.default === "function" ? params.default : () => params.default,
    ...processCreateParams(params)
  });
};
var ZodCatch = class extends ZodType {
  _parse(input) {
    const { ctx } = this._processInputParams(input);
    const newCtx = {
      ...ctx,
      common: {
        ...ctx.common,
        issues: []
      }
    };
    const result = this._def.innerType._parse({
      data: newCtx.data,
      path: newCtx.path,
      parent: {
        ...newCtx
      }
    });
    if (isAsync(result)) {
      return result.then((result2) => {
        return {
          status: "valid",
          value: result2.status === "valid" ? result2.value : this._def.catchValue({
            get error() {
              return new ZodError(newCtx.common.issues);
            },
            input: newCtx.data
          })
        };
      });
    } else {
      return {
        status: "valid",
        value: result.status === "valid" ? result.value : this._def.catchValue({
          get error() {
            return new ZodError(newCtx.common.issues);
          },
          input: newCtx.data
        })
      };
    }
  }
  removeCatch() {
    return this._def.innerType;
  }
};
ZodCatch.create = (type, params) => {
  return new ZodCatch({
    innerType: type,
    typeName: ZodFirstPartyTypeKind.ZodCatch,
    catchValue: typeof params.catch === "function" ? params.catch : () => params.catch,
    ...processCreateParams(params)
  });
};
var ZodNaN = class extends ZodType {
  _parse(input) {
    const parsedType = this._getType(input);
    if (parsedType !== ZodParsedType.nan) {
      const ctx = this._getOrReturnCtx(input);
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.nan,
        received: ctx.parsedType
      });
      return INVALID;
    }
    return { status: "valid", value: input.data };
  }
};
ZodNaN.create = (params) => {
  return new ZodNaN({
    typeName: ZodFirstPartyTypeKind.ZodNaN,
    ...processCreateParams(params)
  });
};
var BRAND = Symbol("zod_brand");
var ZodBranded = class extends ZodType {
  _parse(input) {
    const { ctx } = this._processInputParams(input);
    const data = ctx.data;
    return this._def.type._parse({
      data,
      path: ctx.path,
      parent: ctx
    });
  }
  unwrap() {
    return this._def.type;
  }
};
var ZodPipeline = class _ZodPipeline extends ZodType {
  _parse(input) {
    const { status, ctx } = this._processInputParams(input);
    if (ctx.common.async) {
      const handleAsync = async () => {
        const inResult = await this._def.in._parseAsync({
          data: ctx.data,
          path: ctx.path,
          parent: ctx
        });
        if (inResult.status === "aborted")
          return INVALID;
        if (inResult.status === "dirty") {
          status.dirty();
          return DIRTY(inResult.value);
        } else {
          return this._def.out._parseAsync({
            data: inResult.value,
            path: ctx.path,
            parent: ctx
          });
        }
      };
      return handleAsync();
    } else {
      const inResult = this._def.in._parseSync({
        data: ctx.data,
        path: ctx.path,
        parent: ctx
      });
      if (inResult.status === "aborted")
        return INVALID;
      if (inResult.status === "dirty") {
        status.dirty();
        return {
          status: "dirty",
          value: inResult.value
        };
      } else {
        return this._def.out._parseSync({
          data: inResult.value,
          path: ctx.path,
          parent: ctx
        });
      }
    }
  }
  static create(a, b) {
    return new _ZodPipeline({
      in: a,
      out: b,
      typeName: ZodFirstPartyTypeKind.ZodPipeline
    });
  }
};
var ZodReadonly = class extends ZodType {
  _parse(input) {
    const result = this._def.innerType._parse(input);
    const freeze = (data) => {
      if (isValid(data)) {
        data.value = Object.freeze(data.value);
      }
      return data;
    };
    return isAsync(result) ? result.then((data) => freeze(data)) : freeze(result);
  }
  unwrap() {
    return this._def.innerType;
  }
};
ZodReadonly.create = (type, params) => {
  return new ZodReadonly({
    innerType: type,
    typeName: ZodFirstPartyTypeKind.ZodReadonly,
    ...processCreateParams(params)
  });
};
function cleanParams(params, data) {
  const p = typeof params === "function" ? params(data) : typeof params === "string" ? { message: params } : params;
  const p2 = typeof p === "string" ? { message: p } : p;
  return p2;
}
function custom(check, _params = {}, fatal) {
  if (check)
    return ZodAny.create().superRefine((data, ctx) => {
      const r = check(data);
      if (r instanceof Promise) {
        return r.then((r2) => {
          if (!r2) {
            const params = cleanParams(_params, data);
            const _fatal = params.fatal ?? fatal ?? true;
            ctx.addIssue({ code: "custom", ...params, fatal: _fatal });
          }
        });
      }
      if (!r) {
        const params = cleanParams(_params, data);
        const _fatal = params.fatal ?? fatal ?? true;
        ctx.addIssue({ code: "custom", ...params, fatal: _fatal });
      }
      return;
    });
  return ZodAny.create();
}
var late = {
  object: ZodObject.lazycreate
};
var ZodFirstPartyTypeKind;
(function(ZodFirstPartyTypeKind2) {
  ZodFirstPartyTypeKind2["ZodString"] = "ZodString";
  ZodFirstPartyTypeKind2["ZodNumber"] = "ZodNumber";
  ZodFirstPartyTypeKind2["ZodNaN"] = "ZodNaN";
  ZodFirstPartyTypeKind2["ZodBigInt"] = "ZodBigInt";
  ZodFirstPartyTypeKind2["ZodBoolean"] = "ZodBoolean";
  ZodFirstPartyTypeKind2["ZodDate"] = "ZodDate";
  ZodFirstPartyTypeKind2["ZodSymbol"] = "ZodSymbol";
  ZodFirstPartyTypeKind2["ZodUndefined"] = "ZodUndefined";
  ZodFirstPartyTypeKind2["ZodNull"] = "ZodNull";
  ZodFirstPartyTypeKind2["ZodAny"] = "ZodAny";
  ZodFirstPartyTypeKind2["ZodUnknown"] = "ZodUnknown";
  ZodFirstPartyTypeKind2["ZodNever"] = "ZodNever";
  ZodFirstPartyTypeKind2["ZodVoid"] = "ZodVoid";
  ZodFirstPartyTypeKind2["ZodArray"] = "ZodArray";
  ZodFirstPartyTypeKind2["ZodObject"] = "ZodObject";
  ZodFirstPartyTypeKind2["ZodUnion"] = "ZodUnion";
  ZodFirstPartyTypeKind2["ZodDiscriminatedUnion"] = "ZodDiscriminatedUnion";
  ZodFirstPartyTypeKind2["ZodIntersection"] = "ZodIntersection";
  ZodFirstPartyTypeKind2["ZodTuple"] = "ZodTuple";
  ZodFirstPartyTypeKind2["ZodRecord"] = "ZodRecord";
  ZodFirstPartyTypeKind2["ZodMap"] = "ZodMap";
  ZodFirstPartyTypeKind2["ZodSet"] = "ZodSet";
  ZodFirstPartyTypeKind2["ZodFunction"] = "ZodFunction";
  ZodFirstPartyTypeKind2["ZodLazy"] = "ZodLazy";
  ZodFirstPartyTypeKind2["ZodLiteral"] = "ZodLiteral";
  ZodFirstPartyTypeKind2["ZodEnum"] = "ZodEnum";
  ZodFirstPartyTypeKind2["ZodEffects"] = "ZodEffects";
  ZodFirstPartyTypeKind2["ZodNativeEnum"] = "ZodNativeEnum";
  ZodFirstPartyTypeKind2["ZodOptional"] = "ZodOptional";
  ZodFirstPartyTypeKind2["ZodNullable"] = "ZodNullable";
  ZodFirstPartyTypeKind2["ZodDefault"] = "ZodDefault";
  ZodFirstPartyTypeKind2["ZodCatch"] = "ZodCatch";
  ZodFirstPartyTypeKind2["ZodPromise"] = "ZodPromise";
  ZodFirstPartyTypeKind2["ZodBranded"] = "ZodBranded";
  ZodFirstPartyTypeKind2["ZodPipeline"] = "ZodPipeline";
  ZodFirstPartyTypeKind2["ZodReadonly"] = "ZodReadonly";
})(ZodFirstPartyTypeKind || (ZodFirstPartyTypeKind = {}));
var instanceOfType = (cls, params = {
  message: `Input not instance of ${cls.name}`
}) => custom((data) => data instanceof cls, params);
var stringType = ZodString.create;
var numberType = ZodNumber.create;
var nanType = ZodNaN.create;
var bigIntType = ZodBigInt.create;
var booleanType = ZodBoolean.create;
var dateType = ZodDate.create;
var symbolType = ZodSymbol.create;
var undefinedType = ZodUndefined.create;
var nullType = ZodNull.create;
var anyType = ZodAny.create;
var unknownType = ZodUnknown.create;
var neverType = ZodNever.create;
var voidType = ZodVoid.create;
var arrayType = ZodArray.create;
var objectType = ZodObject.create;
var strictObjectType = ZodObject.strictCreate;
var unionType = ZodUnion.create;
var discriminatedUnionType = ZodDiscriminatedUnion.create;
var intersectionType = ZodIntersection.create;
var tupleType = ZodTuple.create;
var recordType = ZodRecord.create;
var mapType = ZodMap.create;
var setType = ZodSet.create;
var functionType = ZodFunction.create;
var lazyType = ZodLazy.create;
var literalType = ZodLiteral.create;
var enumType = ZodEnum.create;
var nativeEnumType = ZodNativeEnum.create;
var promiseType = ZodPromise.create;
var effectsType = ZodEffects.create;
var optionalType = ZodOptional.create;
var nullableType = ZodNullable.create;
var preprocessType = ZodEffects.createWithPreprocess;
var pipelineType = ZodPipeline.create;
var ostring = () => stringType().optional();
var onumber = () => numberType().optional();
var oboolean = () => booleanType().optional();
var coerce = {
  string: ((arg) => ZodString.create({ ...arg, coerce: true })),
  number: ((arg) => ZodNumber.create({ ...arg, coerce: true })),
  boolean: ((arg) => ZodBoolean.create({
    ...arg,
    coerce: true
  })),
  bigint: ((arg) => ZodBigInt.create({ ...arg, coerce: true })),
  date: ((arg) => ZodDate.create({ ...arg, coerce: true }))
};
var NEVER = INVALID;

// src/core/validation/schemas.ts
var PositiveNumberSchema = external_exports.number().positive();
var NonNegativeNumberSchema = external_exports.number().nonnegative();
var TimestampSchema = external_exports.number().int().positive();
var SymbolSchema = external_exports.string().min(1);
var OrderTypeSchema = external_exports.enum(["market", "limit", "stopMarket", "stopLimit"]);
var OrderSideSchema = external_exports.enum(["buy", "sell"]);
var OrderStatusSchema = external_exports.enum([
  "open",
  "closed",
  "canceled",
  "expired",
  "rejected",
  "filled",
  "partiallyFilled"
]);
var TimeInForceSchema = external_exports.enum(["GTC", "IOC", "FOK", "PO"]);
var OrderRequestSchema = external_exports.object({
  symbol: SymbolSchema,
  type: OrderTypeSchema,
  side: OrderSideSchema,
  amount: PositiveNumberSchema,
  price: PositiveNumberSchema.optional(),
  stopPrice: PositiveNumberSchema.optional(),
  timeInForce: TimeInForceSchema.optional(),
  reduceOnly: external_exports.boolean().default(false),
  postOnly: external_exports.boolean().default(false),
  clientOrderId: external_exports.string().optional(),
  leverage: external_exports.number().int().min(1).max(100).optional(),
  params: external_exports.record(external_exports.unknown()).optional()
}).refine(
  (data) => {
    if (data.type === "limit" || data.type === "stopLimit") {
      return data.price !== void 0 && data.price > 0;
    }
    return true;
  },
  {
    message: "Limit orders require a valid price",
    path: ["price"]
  }
).refine(
  (data) => {
    if (data.type === "stopMarket" || data.type === "stopLimit") {
      return data.stopPrice !== void 0 && data.stopPrice > 0;
    }
    return true;
  },
  {
    message: "Stop orders require a valid stopPrice",
    path: ["stopPrice"]
  }
);
var OrderSchema = external_exports.object({
  id: external_exports.string(),
  symbol: SymbolSchema,
  type: OrderTypeSchema,
  side: OrderSideSchema,
  amount: PositiveNumberSchema,
  price: PositiveNumberSchema.optional(),
  stopPrice: PositiveNumberSchema.optional(),
  status: OrderStatusSchema,
  filled: NonNegativeNumberSchema,
  remaining: NonNegativeNumberSchema,
  averagePrice: PositiveNumberSchema.optional(),
  timeInForce: TimeInForceSchema.optional(),
  reduceOnly: external_exports.boolean(),
  postOnly: external_exports.boolean(),
  clientOrderId: external_exports.string().optional(),
  timestamp: TimestampSchema,
  lastUpdateTimestamp: TimestampSchema.optional(),
  info: external_exports.record(external_exports.unknown()).optional()
});
var PositionSideSchema = external_exports.enum(["long", "short"]);
var MarginModeSchema = external_exports.enum(["cross", "isolated"]);
var PositionSchema = external_exports.object({
  symbol: SymbolSchema,
  side: PositionSideSchema,
  size: PositiveNumberSchema,
  entryPrice: PositiveNumberSchema,
  markPrice: PositiveNumberSchema,
  liquidationPrice: PositiveNumberSchema,
  unrealizedPnl: external_exports.number(),
  realizedPnl: external_exports.number(),
  leverage: external_exports.number().int().positive(),
  marginMode: MarginModeSchema,
  margin: NonNegativeNumberSchema,
  maintenanceMargin: NonNegativeNumberSchema,
  marginRatio: external_exports.number().min(0).max(1),
  timestamp: TimestampSchema,
  info: external_exports.record(external_exports.unknown()).optional()
});
var MarketSchema = external_exports.object({
  id: external_exports.string(),
  symbol: SymbolSchema,
  base: external_exports.string(),
  quote: external_exports.string(),
  settle: external_exports.string(),
  active: external_exports.boolean(),
  minAmount: PositiveNumberSchema,
  maxAmount: PositiveNumberSchema.optional(),
  minCost: PositiveNumberSchema.optional(),
  pricePrecision: external_exports.number().int().nonnegative(),
  amountPrecision: external_exports.number().int().nonnegative(),
  priceTickSize: PositiveNumberSchema,
  amountStepSize: PositiveNumberSchema,
  makerFee: external_exports.number(),
  takerFee: external_exports.number().nonnegative(),
  maxLeverage: external_exports.number().int().positive(),
  fundingIntervalHours: external_exports.number().positive(),
  contractSize: PositiveNumberSchema.optional(),
  info: external_exports.record(external_exports.unknown()).optional()
});
var PriceLevelSchema = external_exports.tuple([PositiveNumberSchema, NonNegativeNumberSchema]);
var OrderBookSchema = external_exports.object({
  symbol: SymbolSchema,
  timestamp: TimestampSchema,
  bids: external_exports.array(PriceLevelSchema),
  asks: external_exports.array(PriceLevelSchema),
  sequenceId: external_exports.number().optional(),
  checksum: external_exports.string().optional(),
  exchange: external_exports.string()
});
var TradeSchema = external_exports.object({
  id: external_exports.string(),
  symbol: SymbolSchema,
  orderId: external_exports.string().optional(),
  side: OrderSideSchema,
  price: PositiveNumberSchema,
  amount: PositiveNumberSchema,
  cost: PositiveNumberSchema,
  timestamp: TimestampSchema,
  info: external_exports.record(external_exports.unknown()).optional()
});
var FundingRateSchema = external_exports.object({
  symbol: SymbolSchema,
  fundingRate: external_exports.number(),
  fundingTimestamp: TimestampSchema,
  nextFundingTimestamp: TimestampSchema,
  markPrice: PositiveNumberSchema,
  indexPrice: PositiveNumberSchema,
  fundingIntervalHours: external_exports.number().positive(),
  info: external_exports.record(external_exports.unknown()).optional()
});
var BalanceSchema = external_exports.object({
  currency: external_exports.string(),
  total: NonNegativeNumberSchema,
  free: NonNegativeNumberSchema,
  used: NonNegativeNumberSchema,
  usdValue: NonNegativeNumberSchema.optional(),
  info: external_exports.record(external_exports.unknown()).optional()
});
var TickerSchema = external_exports.object({
  symbol: SymbolSchema,
  last: PositiveNumberSchema,
  bid: PositiveNumberSchema,
  bidVolume: NonNegativeNumberSchema.optional(),
  ask: PositiveNumberSchema,
  askVolume: NonNegativeNumberSchema.optional(),
  high: PositiveNumberSchema,
  low: PositiveNumberSchema,
  open: PositiveNumberSchema,
  close: PositiveNumberSchema,
  change: external_exports.number(),
  percentage: external_exports.number(),
  baseVolume: NonNegativeNumberSchema,
  quoteVolume: NonNegativeNumberSchema,
  timestamp: TimestampSchema,
  info: external_exports.record(external_exports.unknown()).optional()
});
var OHLCVTimeframeSchema = external_exports.enum([
  "1m",
  "3m",
  "5m",
  "15m",
  "30m",
  "1h",
  "2h",
  "4h",
  "6h",
  "8h",
  "12h",
  "1d",
  "3d",
  "1w",
  "1M"
]);
var OHLCVSchema = external_exports.tuple([
  TimestampSchema,
  // timestamp
  PositiveNumberSchema,
  // open
  PositiveNumberSchema,
  // high
  PositiveNumberSchema,
  // low
  PositiveNumberSchema,
  // close
  NonNegativeNumberSchema
  // volume
]);
var OHLCVParamsSchema = external_exports.object({
  limit: external_exports.number().int().positive().optional(),
  since: TimestampSchema.optional(),
  until: TimestampSchema.optional()
}).optional();
var MarketParamsSchema = external_exports.object({
  active: external_exports.boolean().optional(),
  ids: external_exports.array(external_exports.string()).optional()
}).optional();
var OrderBookParamsSchema = external_exports.object({
  limit: external_exports.number().int().positive().optional()
}).optional();
var TradeParamsSchema = external_exports.object({
  limit: external_exports.number().int().positive().optional(),
  since: TimestampSchema.optional()
}).optional();
function validateData(schema, data, context) {
  const result = schema.safeParse(data);
  if (!result.success) {
    const errors = result.error.errors.map((err2) => `${err2.path.join(".")}: ${err2.message}`);
    throw new Error(
      `Validation failed${context ? ` for ${context}` : ""}: ${errors.join(", ")}`
    );
  }
  return result.data;
}

// src/core/validation/middleware.ts
function validate(schema, data, options) {
  const result = schema.safeParse(data);
  if (!result.success) {
    const errors = mapZodErrors(result.error);
    const errorMessage = formatValidationErrors(errors, options.errorPrefix);
    if (options.throwOnError !== false) {
      const error = new PerpDEXError(
        errorMessage,
        "VALIDATION_ERROR",
        options.exchange
      );
      if (options.context?.correlationId) {
        error.withCorrelationId(options.context.correlationId);
      }
      throw error;
    }
  }
  return result.data;
}
function validateSafe(schema, data) {
  const result = schema.safeParse(data);
  if (result.success) {
    return { success: true, data: result.data };
  }
  return {
    success: false,
    errors: mapZodErrors(result.error)
  };
}
function validateOrderRequest(data, options) {
  const result = OrderRequestSchema.safeParse(data);
  if (!result.success) {
    const errors = mapZodErrors(result.error);
    const errorMessage = formatValidationErrors(errors, "Invalid order");
    const error = new InvalidOrderError(
      errorMessage,
      "INVALID_ORDER_REQUEST",
      options.exchange
    );
    if (options.context?.correlationId) {
      error.withCorrelationId(options.context.correlationId);
    }
    throw error;
  }
  return result.data;
}
function validateOrderBookParams(data, options) {
  if (data === void 0 || data === null) {
    return void 0;
  }
  return validate(OrderBookParamsSchema, data, {
    ...options,
    errorPrefix: "Invalid order book params"
  });
}
function validateTradeParams(data, options) {
  if (data === void 0 || data === null) {
    return void 0;
  }
  return validate(TradeParamsSchema, data, {
    ...options,
    errorPrefix: "Invalid trade params"
  });
}
function validateMarketParams(data, options) {
  if (data === void 0 || data === null) {
    return void 0;
  }
  return validate(MarketParamsSchema, data, {
    ...options,
    errorPrefix: "Invalid market params"
  });
}
function validateOHLCVParams(data, options) {
  if (data === void 0 || data === null) {
    return void 0;
  }
  return validate(OHLCVParamsSchema, data, {
    ...options,
    errorPrefix: "Invalid OHLCV params"
  });
}
function validateOHLCVTimeframe(data, options) {
  return validate(OHLCVTimeframeSchema, data, {
    ...options,
    errorPrefix: "Invalid OHLCV timeframe"
  });
}
function validateArray(schema, data, options) {
  const results = [];
  const errors = [];
  for (let i = 0; i < data.length; i++) {
    const result = schema.safeParse(data[i]);
    if (result.success) {
      results.push(result.data);
    } else {
      const itemErrors = mapZodErrors(result.error);
      errors.push(
        ...itemErrors.map((e) => ({
          ...e,
          field: `[${i}].${e.field}`
        }))
      );
    }
  }
  if (errors.length > 0 && options.throwOnError !== false) {
    const errorMessage = formatValidationErrors(errors, options.errorPrefix);
    const error = new PerpDEXError(
      errorMessage,
      "VALIDATION_ERROR",
      options.exchange
    );
    if (options.context?.correlationId) {
      error.withCorrelationId(options.context.correlationId);
    }
    throw error;
  }
  return results;
}
function createValidator(exchange) {
  return {
    /**
     * Validate any data against a schema
     */
    validate: (schema, data, context) => validate(schema, data, { exchange, context }),
    /**
     * Validate order request
     */
    orderRequest: (data, context) => validateOrderRequest(data, { exchange, context }),
    /**
     * Validate order book params
     */
    orderBookParams: (data, context) => validateOrderBookParams(data, { exchange, context }),
    /**
     * Validate trade params
     */
    tradeParams: (data, context) => validateTradeParams(data, { exchange, context }),
    /**
     * Validate market params
     */
    marketParams: (data, context) => validateMarketParams(data, { exchange, context }),
    /**
     * Validate OHLCV params
     */
    ohlcvParams: (data, context) => validateOHLCVParams(data, { exchange, context }),
    /**
     * Validate OHLCV timeframe
     */
    ohlcvTimeframe: (data, context) => validateOHLCVTimeframe(data, { exchange, context }),
    /**
     * Validate array of items
     */
    array: (schema, data, context) => validateArray(schema, data, { exchange, context })
  };
}
function mapZodErrors(zodError) {
  return zodError.errors.map((err2) => ({
    field: err2.path.join(".") || "root",
    message: err2.message,
    code: err2.code,
    value: "received" in err2 ? err2.received : void 0
  }));
}
function formatValidationErrors(errors, prefix) {
  const errorMessages = errors.map((e) => {
    const location = e.field !== "root" ? ` at '${e.field}'` : "";
    return `${e.message}${location}`;
  });
  const baseMessage = prefix ? `${prefix}: ` : "Validation failed: ";
  return `${baseMessage}${errorMessages.join("; ")}`;
}
function validateResponse(schema, exchange) {
  return function(_target, _propertyKey, descriptor) {
    const originalMethod = descriptor.value;
    descriptor.value = async function(...args) {
      const result = await originalMethod.apply(this, args);
      return validate(schema, result, { exchange, errorPrefix: "Invalid response" });
    };
    return descriptor;
  };
}

// src/adapters/base/BaseAdapter.ts
var BaseAdapter = class {
  _isReady = false;
  _isDisconnected = false;
  config;
  authStrategy;
  rateLimiter;
  _logger;
  circuitBreaker;
  httpClient;
  prometheusMetrics;
  // Resource tracking
  timers = /* @__PURE__ */ new Set();
  intervals = /* @__PURE__ */ new Set();
  abortControllers = /* @__PURE__ */ new Set();
  // Cache management
  marketCache = null;
  marketCacheExpiry = 0;
  marketCacheTTL = 5 * 60 * 1e3;
  // 5 minutes default
  // Metrics tracking
  metrics = {
    totalRequests: 0,
    successfulRequests: 0,
    failedRequests: 0,
    rateLimitHits: 0,
    averageLatency: 0,
    endpointStats: /* @__PURE__ */ new Map(),
    startedAt: Date.now()
  };
  constructor(config = {}) {
    this.config = {
      timeout: 3e4,
      testnet: false,
      debug: false,
      ...config
    };
    if (isMetricsInitialized()) {
      this.prometheusMetrics = getMetrics();
    }
    this.circuitBreaker = new CircuitBreaker(config.circuitBreaker);
    this.circuitBreaker.on("open", () => {
      this.warn("Circuit breaker OPENED - rejecting requests");
      if (this.prometheusMetrics) {
        this.prometheusMetrics.updateCircuitBreakerState(this.id, "OPEN");
        this.prometheusMetrics.recordCircuitBreakerTransition(this.id, "CLOSED", "OPEN");
      }
    });
    this.circuitBreaker.on("halfOpen", () => {
      this.info("Circuit breaker HALF_OPEN - testing recovery");
      if (this.prometheusMetrics) {
        this.prometheusMetrics.updateCircuitBreakerState(this.id, "HALF_OPEN");
        this.prometheusMetrics.recordCircuitBreakerTransition(this.id, "OPEN", "HALF_OPEN");
      }
    });
    this.circuitBreaker.on("close", () => {
      this.info("Circuit breaker CLOSED - normal operation resumed");
      if (this.prometheusMetrics) {
        this.prometheusMetrics.updateCircuitBreakerState(this.id, "CLOSED");
        this.prometheusMetrics.recordCircuitBreakerTransition(this.id, "HALF_OPEN", "CLOSED");
      }
    });
    this.circuitBreaker.on("success", () => {
      if (this.prometheusMetrics) {
        this.prometheusMetrics.recordCircuitBreakerSuccess(this.id);
      }
    });
    this.circuitBreaker.on("failure", () => {
      if (this.prometheusMetrics) {
        this.prometheusMetrics.recordCircuitBreakerFailure(this.id);
      }
    });
  }
  // ===========================================================================
  // Logger Methods (from LoggerMixin)
  // ===========================================================================
  get logger() {
    if (!this._logger) {
      this._logger = new Logger(this.name, {
        level: this.config.debug ? "debug" /* DEBUG */ : "info" /* INFO */,
        enabled: true,
        maskSensitiveData: true
      });
    }
    return this._logger;
  }
  debug(message, meta) {
    this.logger.debug(message, meta);
  }
  info(message, meta) {
    this.logger.info(message, meta);
  }
  warn(message, meta) {
    this.logger.warn(message, meta);
  }
  error(message, error, meta) {
    this.logger.error(message, error, meta);
  }
  // ===========================================================================
  // State Getters
  // ===========================================================================
  get isReady() {
    return this._isReady;
  }
  isDisconnected() {
    return this._isDisconnected;
  }
  async disconnect() {
    if (this._isDisconnected) {
      this.debug("Already disconnected");
      return;
    }
    this.debug("Disconnecting and cleaning up resources...");
    for (const timer of this.timers) {
      clearTimeout(timer);
    }
    this.timers.clear();
    for (const interval of this.intervals) {
      clearInterval(interval);
    }
    this.intervals.clear();
    for (const controller of this.abortControllers) {
      controller.abort();
    }
    this.abortControllers.clear();
    this.clearCache();
    this.circuitBreaker.destroy();
    this._isReady = false;
    this._isDisconnected = true;
    this.debug("Disconnected and cleanup complete");
  }
  // ===========================================================================
  // Cache Management (from CacheManagerMixin)
  // ===========================================================================
  clearCache() {
    this.marketCache = null;
    this.marketCacheExpiry = 0;
  }
  async preloadMarkets(options) {
    const ttl = options?.ttl ?? this.marketCacheTTL;
    const params = options?.params;
    this.debug("Preloading markets...");
    const markets = await this.fetchMarketsFromAPI(params);
    this.marketCache = markets;
    this.marketCacheExpiry = Date.now() + ttl;
    this.marketCacheTTL = ttl;
    this.debug("Preloaded markets", { count: markets.length, ttl });
  }
  getPreloadedMarkets() {
    if (!this.marketCache) {
      return null;
    }
    const isExpired = Date.now() >= this.marketCacheExpiry;
    if (isExpired) {
      this.debug("Market cache expired");
      this.marketCache = null;
      this.marketCacheExpiry = 0;
      return null;
    }
    return this.marketCache;
  }
  async fetchMarketsFromAPI(params) {
    return this.fetchMarkets(params);
  }
  // ===========================================================================
  // Health Check (from HealthCheckMixin)
  // ===========================================================================
  async healthCheck(config = {}) {
    const {
      timeout = 5e3,
      checkWebSocket = true,
      checkAuth = true,
      includeRateLimit = true
    } = config;
    const startTime = Date.now();
    const timestamp = Date.now();
    const result = {
      status: "unhealthy",
      latency: 0,
      exchange: this.id,
      api: { reachable: false, latency: 0 },
      timestamp
    };
    try {
      result.api = await this.checkApiHealth(timeout);
      if (checkWebSocket && this.has.watchOrderBook) {
        result.websocket = await this.checkWebSocketHealth();
      }
      if (checkAuth && this.authStrategy) {
        result.auth = await this.checkAuthHealth();
      }
      if (includeRateLimit && this.rateLimiter) {
        result.rateLimit = this.getRateLimitStatus();
      }
      result.status = determineHealthStatus(
        result.api.reachable,
        result.websocket?.connected,
        result.auth?.valid
      );
      result.latency = Date.now() - startTime;
      return result;
    } catch (error) {
      result.latency = Date.now() - startTime;
      result.api.error = error instanceof Error ? error.message : "Unknown error";
      return result;
    }
  }
  async checkApiHealth(timeout) {
    const startTime = Date.now();
    try {
      await Promise.race([
        this.performApiHealthCheck(),
        new Promise(
          (_, reject) => setTimeout(() => reject(new Error("Health check timeout")), timeout)
        )
      ]);
      return { reachable: true, latency: Date.now() - startTime };
    } catch (error) {
      return {
        reachable: false,
        latency: Date.now() - startTime,
        error: error instanceof Error ? error.message : "Unknown error"
      };
    }
  }
  async performApiHealthCheck() {
    await this.fetchMarkets({ active: true });
  }
  async checkWebSocketHealth() {
    return { connected: false, reconnecting: false };
  }
  async checkAuthHealth() {
    return { valid: !!this.authStrategy };
  }
  getRateLimitStatus() {
    return void 0;
  }
  // ===========================================================================
  // Metrics (from MetricsTrackerMixin)
  // ===========================================================================
  updateEndpointMetrics(endpointKey, latency, isError) {
    let stats = this.metrics.endpointStats.get(endpointKey);
    if (!stats) {
      stats = {
        endpoint: endpointKey,
        count: 0,
        totalLatency: 0,
        errors: 0,
        minLatency: Infinity,
        maxLatency: 0
      };
      this.metrics.endpointStats.set(endpointKey, stats);
    }
    stats.count++;
    stats.totalLatency += latency;
    stats.minLatency = Math.min(stats.minLatency, latency);
    stats.maxLatency = Math.max(stats.maxLatency, latency);
    stats.lastRequestAt = Date.now();
    if (isError) {
      stats.errors++;
    }
  }
  updateAverageLatency(latency) {
    const total = this.metrics.totalRequests;
    const currentAvg = this.metrics.averageLatency;
    this.metrics.averageLatency = (currentAvg * (total - 1) + latency) / total;
  }
  getMetrics() {
    return createMetricsSnapshot(this.metrics);
  }
  getCircuitBreakerMetrics() {
    return this.circuitBreaker.getMetrics();
  }
  getCircuitBreakerState() {
    return this.circuitBreaker.getState();
  }
  resetMetrics() {
    this.metrics.lastResetAt = Date.now();
    this.metrics.totalRequests = 0;
    this.metrics.successfulRequests = 0;
    this.metrics.failedRequests = 0;
    this.metrics.rateLimitHits = 0;
    this.metrics.averageLatency = 0;
    this.metrics.endpointStats.clear();
  }
  trackRateLimitHit() {
    this.metrics.rateLimitHits++;
  }
  // ===========================================================================
  // HTTP Request (from HttpRequestMixin)
  // ===========================================================================
  async request(method, url, body, headers) {
    const maxAttempts = 3;
    const initialDelay = 1e3;
    const maxDelay = 1e4;
    const multiplier = 2;
    const retryableStatuses = [408, 429, 500, 502, 503, 504];
    const correlationId = generateCorrelationId();
    return this.circuitBreaker.execute(async () => {
      let lastError;
      for (let attempt = 0; attempt < maxAttempts; attempt++) {
        const startTime = Date.now();
        const endpoint = this.extractEndpoint(url);
        const endpointKey = `${method}:${endpoint}`;
        this.debug(`Request ${correlationId}`, { method, endpoint, attempt: attempt + 1, correlationId });
        this.metrics.totalRequests++;
        const controller = new AbortController();
        this.abortControllers.add(controller);
        const timeout = setTimeout(() => controller.abort(), this.config.timeout);
        this.registerTimer(timeout);
        try {
          const response = await fetch(url, {
            method,
            headers: { "Content-Type": "application/json", "X-Correlation-ID": correlationId, ...headers },
            body: body ? JSON.stringify(body) : void 0,
            signal: controller.signal
          });
          if (!response.ok) {
            const shouldRetry = attempt < maxAttempts - 1 && retryableStatuses.includes(response.status);
            const error = new Error(`HTTP ${response.status}: ${response.statusText}`);
            if (!shouldRetry) {
              throw error;
            }
            const latency2 = Date.now() - startTime;
            this.metrics.failedRequests++;
            this.updateEndpointMetrics(endpointKey, latency2, true);
            this.updateAverageLatency(latency2);
            lastError = error;
            const delay = Math.min(initialDelay * Math.pow(multiplier, attempt), maxDelay);
            clearTimeout(timeout);
            this.timers.delete(timeout);
            this.abortControllers.delete(controller);
            await new Promise((resolve) => setTimeout(resolve, delay));
            continue;
          }
          const result = await response.json();
          const latency = Date.now() - startTime;
          this.metrics.successfulRequests++;
          this.updateEndpointMetrics(endpointKey, latency, false);
          this.updateAverageLatency(latency);
          this.debug(`Request ${correlationId} completed`, { correlationId, latency, status: response.status });
          if (this.prometheusMetrics) {
            this.prometheusMetrics.recordRequest(this.id, endpoint, "success", latency);
          }
          clearTimeout(timeout);
          this.timers.delete(timeout);
          this.abortControllers.delete(controller);
          return result;
        } catch (error) {
          const latency = Date.now() - startTime;
          this.metrics.failedRequests++;
          this.updateEndpointMetrics(endpointKey, latency, true);
          this.updateAverageLatency(latency);
          this.debug(`Request ${correlationId} failed`, {
            correlationId,
            latency,
            error: error instanceof Error ? error.message : "Unknown error",
            attempt: attempt + 1
          });
          if (this.prometheusMetrics) {
            this.prometheusMetrics.recordRequest(this.id, endpoint, "error", latency);
            const errorType = error instanceof Error ? error.constructor.name : "UnknownError";
            this.prometheusMetrics.recordRequestError(this.id, endpoint, errorType);
          }
          clearTimeout(timeout);
          this.timers.delete(timeout);
          this.abortControllers.delete(controller);
          const isNetworkError5 = error instanceof Error && (error.name === "AbortError" || error.message.includes("fetch") || error.message.includes("network"));
          if (attempt < maxAttempts - 1 && isNetworkError5) {
            lastError = error;
            const delay = Math.min(initialDelay * Math.pow(multiplier, attempt), maxDelay);
            await new Promise((resolve) => setTimeout(resolve, delay));
            continue;
          }
          throw this.attachCorrelationId(error, correlationId);
        }
      }
      throw this.attachCorrelationId(lastError || new Error("Request failed after retries"), correlationId);
    });
  }
  registerTimer(timer) {
    this.timers.add(timer);
  }
  registerInterval(interval) {
    this.intervals.add(interval);
  }
  unregisterTimer(timer) {
    clearTimeout(timer);
    this.timers.delete(timer);
  }
  unregisterInterval(interval) {
    clearInterval(interval);
    this.intervals.delete(interval);
  }
  extractEndpoint(url) {
    try {
      const urlObj = new URL(url);
      return urlObj.pathname;
    } catch {
      return url;
    }
  }
  async fetchOHLCV(_symbol, _timeframe, _params) {
    if (!this.has.fetchOHLCV) {
      throw new NotSupportedError(`${this.name} does not support OHLCV data`, "NOT_SUPPORTED", this.id);
    }
    throw new Error("fetchOHLCV must be implemented by subclass");
  }
  async fetchTickers(symbols) {
    if (!this.has.fetchTickers) {
      const result = {};
      const symbolsToFetch = symbols ?? (await this.fetchMarkets()).map((m) => m.symbol);
      for (const symbol of symbolsToFetch) {
        try {
          result[symbol] = await this.fetchTicker(symbol);
        } catch (error) {
          this.debug(`Failed to fetch ticker for ${symbol}`, { error });
        }
      }
      return result;
    }
    throw new Error("fetchTickers must be implemented by subclass");
  }
  async fetchCurrencies() {
    if (!this.has.fetchCurrencies) {
      throw new NotSupportedError(`${this.name} does not support fetching currencies`, "NOT_SUPPORTED", this.id);
    }
    throw new Error("fetchCurrencies must be implemented by subclass");
  }
  async fetchStatus() {
    if (!this.has.fetchStatus) {
      try {
        await this.fetchMarkets();
        return { status: "ok", updated: Date.now() };
      } catch (error) {
        return { status: "error", message: error instanceof Error ? error.message : "Unknown error", updated: Date.now() };
      }
    }
    throw new Error("fetchStatus must be implemented by subclass");
  }
  async fetchTime() {
    if (!this.has.fetchTime) {
      throw new NotSupportedError(`${this.name} does not support fetching server time`, "NOT_SUPPORTED", this.id);
    }
    throw new Error("fetchTime must be implemented by subclass");
  }
  async fetchDeposits(_currency, _since, _limit) {
    if (!this.has.fetchDeposits) {
      throw new NotSupportedError(`${this.name} does not support fetching deposit history`, "NOT_SUPPORTED", this.id);
    }
    throw new Error("fetchDeposits must be implemented by subclass");
  }
  async fetchWithdrawals(_currency, _since, _limit) {
    if (!this.has.fetchWithdrawals) {
      throw new NotSupportedError(`${this.name} does not support fetching withdrawal history`, "NOT_SUPPORTED", this.id);
    }
    throw new Error("fetchWithdrawals must be implemented by subclass");
  }
  async fetchLedger(_currency, _since, _limit, _params) {
    if (!this.has.fetchLedger) {
      throw new NotSupportedError(`${this.name} does not support fetching ledger`, "NOT_SUPPORTED", this.id);
    }
    throw new Error("fetchLedger must be implemented by subclass");
  }
  async fetchFundingHistory(_symbol, _since, _limit) {
    if (!this.has.fetchFundingHistory) {
      throw new NotSupportedError(`${this.name} does not support fetching funding history`, "NOT_SUPPORTED", this.id);
    }
    throw new Error("fetchFundingHistory must be implemented by subclass");
  }
  // ===========================================================================
  // Batch Operations (from OrderHelpersMixin)
  // ===========================================================================
  async createBatchOrders(requests) {
    if (this.has.createBatchOrders === true) {
      throw new Error("createBatchOrders must be implemented by subclass when has.createBatchOrders is true");
    }
    this.debug("No native batch support, creating orders sequentially", { count: requests.length });
    const orders = [];
    const errors = [];
    for (let i = 0; i < requests.length; i++) {
      const request = requests[i];
      if (!request) continue;
      try {
        const order = await this.createOrder(request);
        orders.push(order);
      } catch (error) {
        const err2 = error instanceof Error ? error : new Error(String(error));
        errors.push({ index: i, error: err2 });
        this.debug("Failed to create order", { index: i + 1, total: requests.length, error: err2.message });
      }
    }
    if (orders.length === 0 && errors.length > 0) {
      const firstError = errors[0];
      if (firstError) {
        throw new Error(`All batch order creations failed. First error: ${firstError.error.message}`);
      }
    }
    if (errors.length > 0) {
      this.debug("Batch order creation completed", { succeeded: orders.length, failed: errors.length });
    }
    return orders;
  }
  async cancelBatchOrders(orderIds, symbol) {
    if (this.has.cancelBatchOrders === true) {
      throw new Error("cancelBatchOrders must be implemented by subclass when has.cancelBatchOrders is true");
    }
    this.debug("No native batch support, canceling orders sequentially", { count: orderIds.length });
    const orders = [];
    const errors = [];
    for (let i = 0; i < orderIds.length; i++) {
      const orderId = orderIds[i];
      if (!orderId) continue;
      try {
        const order = await this.cancelOrder(orderId, symbol);
        orders.push(order);
      } catch (error) {
        const err2 = error instanceof Error ? error : new Error(String(error));
        errors.push({ index: i, orderId, error: err2 });
        this.debug("Failed to cancel order", { orderId, error: err2.message });
      }
    }
    if (orders.length === 0 && errors.length > 0) {
      const firstError = errors[0];
      if (firstError) {
        throw new Error(`All batch order cancellations failed. First error: ${firstError.error.message}`);
      }
    }
    if (errors.length > 0) {
      this.debug("Batch order cancellation completed", { succeeded: orders.length, failed: errors.length });
    }
    return orders;
  }
  async editOrder(_orderId, _symbol, _type, _side, _amount, _price, _params) {
    if (!this.has.editOrder) {
      throw new NotSupportedError(`${this.name} does not support editing orders`, "NOT_SUPPORTED", this.id);
    }
    throw new Error("editOrder must be implemented by subclass");
  }
  // ===========================================================================
  // Order Query
  // ===========================================================================
  async fetchOrder(_orderId, _symbol) {
    if (!this.has.fetchOrder) {
      throw new NotSupportedError(`${this.name} does not support fetching single orders`, "NOT_SUPPORTED", this.id);
    }
    throw new Error("fetchOrder must be implemented by subclass");
  }
  async fetchOpenOrders(_symbol, _since, _limit) {
    if (!this.has.fetchOpenOrders) {
      throw new NotSupportedError(`${this.name} does not support fetching open orders`, "NOT_SUPPORTED", this.id);
    }
    throw new Error("fetchOpenOrders must be implemented by subclass");
  }
  async fetchClosedOrders(_symbol, _since, _limit) {
    if (!this.has.fetchClosedOrders) {
      throw new NotSupportedError(`${this.name} does not support fetching closed orders`, "NOT_SUPPORTED", this.id);
    }
    throw new Error("fetchClosedOrders must be implemented by subclass");
  }
  // ===========================================================================
  // Convenience Order Methods (CCXT-compatible)
  // ===========================================================================
  async createLimitBuyOrder(symbol, amount, price, params) {
    return this.createOrder({ symbol, type: "limit", side: "buy", amount, price, ...params });
  }
  async createLimitSellOrder(symbol, amount, price, params) {
    return this.createOrder({ symbol, type: "limit", side: "sell", amount, price, ...params });
  }
  async createMarketBuyOrder(symbol, amount, params) {
    return this.createOrder({ symbol, type: "market", side: "buy", amount, ...params });
  }
  async createMarketSellOrder(symbol, amount, params) {
    return this.createOrder({ symbol, type: "market", side: "sell", amount, ...params });
  }
  async createStopLossOrder(symbol, amount, stopPrice, params) {
    return this.createOrder({ symbol, type: "stopMarket", side: "sell", amount, stopPrice, reduceOnly: true, ...params });
  }
  async createTakeProfitOrder(symbol, amount, takeProfitPrice, params) {
    return this.createOrder({ symbol, type: "limit", side: "sell", amount, price: takeProfitPrice, reduceOnly: true, ...params });
  }
  async setMarginMode(_symbol, _marginMode) {
    if (!this.has.setMarginMode || this.has.setMarginMode === "emulated") {
      throw new NotSupportedError(`${this.name} does not support setting margin mode directly`, "NOT_SUPPORTED", this.id);
    }
    throw new Error("setMarginMode must be implemented by subclass");
  }
  // ===========================================================================
  // WebSocket Streams - default implementation throws if not supported
  // ===========================================================================
  async *watchOrderBook(_symbol, _limit) {
    if (!this.has.watchOrderBook) {
      throw new NotSupportedError(`${this.name} does not support order book streaming`, "NOT_SUPPORTED", this.id);
    }
    throw new Error("watchOrderBook must be implemented by subclass");
    yield {};
  }
  async *watchTrades(_symbol) {
    if (!this.has.watchTrades) {
      throw new NotSupportedError(`${this.name} does not support trade streaming`, "NOT_SUPPORTED", this.id);
    }
    throw new Error("watchTrades must be implemented by subclass");
    yield {};
  }
  async *watchTicker(_symbol) {
    if (!this.has.watchTicker) {
      throw new NotSupportedError(`${this.name} does not support ticker streaming`, "NOT_SUPPORTED", this.id);
    }
    throw new Error("watchTicker must be implemented by subclass");
    yield {};
  }
  async *watchTickers(_symbols) {
    if (!this.has.watchTickers) {
      throw new NotSupportedError(`${this.name} does not support multiple ticker streaming`, "NOT_SUPPORTED", this.id);
    }
    throw new Error("watchTickers must be implemented by subclass");
    yield {};
  }
  async *watchPositions() {
    if (!this.has.watchPositions) {
      throw new NotSupportedError(`${this.name} does not support position streaming`, "NOT_SUPPORTED", this.id);
    }
    throw new Error("watchPositions must be implemented by subclass");
    yield [];
  }
  async *watchOrders() {
    if (!this.has.watchOrders) {
      throw new NotSupportedError(`${this.name} does not support order streaming`, "NOT_SUPPORTED", this.id);
    }
    throw new Error("watchOrders must be implemented by subclass");
    yield [];
  }
  async *watchBalance() {
    if (!this.has.watchBalance) {
      throw new NotSupportedError(`${this.name} does not support balance streaming`, "NOT_SUPPORTED", this.id);
    }
    throw new Error("watchBalance must be implemented by subclass");
    yield [];
  }
  async *watchFundingRate(_symbol) {
    if (!this.has.watchFundingRate) {
      throw new NotSupportedError(`${this.name} does not support funding rate streaming`, "NOT_SUPPORTED", this.id);
    }
    throw new Error("watchFundingRate must be implemented by subclass");
    yield {};
  }
  async *watchOHLCV(_symbol, _timeframe) {
    if (!this.has.watchOHLCV) {
      throw new NotSupportedError(`${this.name} does not support OHLCV streaming`, "NOT_SUPPORTED", this.id);
    }
    throw new Error("watchOHLCV must be implemented by subclass");
    yield [0, 0, 0, 0, 0, 0];
  }
  async *watchMyTrades(_symbol) {
    if (!this.has.watchMyTrades) {
      throw new NotSupportedError(`${this.name} does not support user trade streaming`, "NOT_SUPPORTED", this.id);
    }
    throw new Error("watchMyTrades must be implemented by subclass");
    yield {};
  }
  // ===========================================================================
  // Additional Info Methods
  // ===========================================================================
  async fetchUserFees() {
    if (!this.has.fetchUserFees) {
      throw new NotSupportedError(`${this.name} does not support fetching user fees`, "NOT_SUPPORTED", this.id);
    }
    throw new Error("fetchUserFees must be implemented by subclass");
  }
  async fetchPortfolio() {
    if (!this.has.fetchPortfolio) {
      throw new NotSupportedError(`${this.name} does not support fetching portfolio metrics`, "NOT_SUPPORTED", this.id);
    }
    throw new Error("fetchPortfolio must be implemented by subclass");
  }
  async fetchRateLimitStatus() {
    if (!this.has.fetchRateLimitStatus) {
      throw new NotSupportedError(`${this.name} does not support fetching rate limit status`, "NOT_SUPPORTED", this.id);
    }
    throw new Error("fetchRateLimitStatus must be implemented by subclass");
  }
  // ===========================================================================
  // Utility Methods
  // ===========================================================================
  supportsFeature(feature) {
    return this.has[feature] === true;
  }
  assertFeatureSupported(feature) {
    if (!this.has[feature]) {
      throw new NotSupportedError(`Feature '${feature}' is not supported by ${this.name}`, "NOT_SUPPORTED", this.id);
    }
  }
  ensureInitialized() {
    if (!this._isReady) {
      throw new Error(`${this.name} adapter not initialized. Call initialize() first.`);
    }
  }
  // ===========================================================================
  // Input Validation
  // ===========================================================================
  validateOrder(request, correlationId) {
    return validateOrderRequest(request, {
      exchange: this.id,
      context: correlationId ? { correlationId } : void 0
    });
  }
  getValidator() {
    return createValidator(this.id);
  }
  attachCorrelationId(error, correlationId) {
    if (error instanceof PerpDEXError) {
      error.withCorrelationId(correlationId);
      return error;
    }
    const message = error instanceof Error ? error.message : String(error);
    return new PerpDEXError(message, "REQUEST_ERROR", this.id, error).withCorrelationId(correlationId);
  }
  // ===========================================================================
  // Python-style Method Aliases
  // ===========================================================================
  fetch_markets = this.fetchMarkets.bind(this);
  fetch_ticker = this.fetchTicker.bind(this);
  fetch_order_book = this.fetchOrderBook.bind(this);
  fetch_trades = this.fetchTrades.bind(this);
  fetch_funding_rate = this.fetchFundingRate.bind(this);
  fetch_funding_rate_history = this.fetchFundingRateHistory.bind(this);
  fetch_ohlcv = this.fetchOHLCV.bind(this);
  create_order = this.createOrder.bind(this);
  cancel_order = this.cancelOrder.bind(this);
  cancel_all_orders = this.cancelAllOrders.bind(this);
  create_batch_orders = this.createBatchOrders.bind(this);
  cancel_batch_orders = this.cancelBatchOrders.bind(this);
  fetch_positions = this.fetchPositions.bind(this);
  fetch_balance = this.fetchBalance.bind(this);
  set_leverage = this.setLeverage.bind(this);
  set_margin_mode = this.setMarginMode.bind(this);
  fetch_open_orders = this.fetchOpenOrders.bind(this);
  health_check = this.healthCheck.bind(this);
  get_metrics = this.getMetrics.bind(this);
  reset_metrics = this.resetMetrics.bind(this);
  preload_markets = this.preloadMarkets.bind(this);
  get_preloaded_markets = this.getPreloadedMarkets.bind(this);
  clear_cache = this.clearCache.bind(this);
  fetch_deposits = this.fetchDeposits.bind(this);
  fetch_withdrawals = this.fetchWithdrawals.bind(this);
  get fetch_order_history() {
    return this.fetchOrderHistory.bind(this);
  }
  get fetch_my_trades() {
    return this.fetchMyTrades.bind(this);
  }
};

// src/adapters/hyperliquid/constants.ts
var HYPERLIQUID_MAINNET_API = "https://api.hyperliquid.xyz";
var HYPERLIQUID_TESTNET_API = "https://api.hyperliquid-testnet.xyz";
var HYPERLIQUID_MAINNET_WS = "wss://api.hyperliquid.xyz/ws";
var HYPERLIQUID_TESTNET_WS = "wss://api.hyperliquid-testnet.xyz/ws";
var HYPERLIQUID_CHAIN_ID = 1337;
var HYPERLIQUID_EIP712_DOMAIN = {
  name: "Exchange",
  version: "1",
  chainId: HYPERLIQUID_CHAIN_ID,
  verifyingContract: "0x0000000000000000000000000000000000000000"
};
var HYPERLIQUID_ACTION_TYPES = {
  Agent: [
    { name: "source", type: "string" },
    { name: "connectionId", type: "bytes32" }
  ]
};
var HYPERLIQUID_RATE_LIMIT = {
  maxRequests: 1200,
  windowMs: 6e4,
  // 1 minute
  weights: {
    // Public endpoints
    fetchMarkets: 1,
    fetchOrderBook: 2,
    fetchTrades: 1,
    fetchTicker: 1,
    fetchFundingRate: 1,
    fetchOHLCV: 2,
    // Private endpoints
    fetchPositions: 2,
    fetchBalance: 2,
    createOrder: 5,
    cancelOrder: 3,
    createBatchOrders: 20,
    cancelAllOrders: 10
  }
};
function unifiedToHyperliquid(symbol) {
  const parts = symbol.split("/");
  const base = parts[0];
  if (!base) {
    throw new Error(`Invalid symbol format: ${symbol}`);
  }
  return base;
}
function hyperliquidToUnified(exchangeSymbol) {
  return `${exchangeSymbol}/USDT:USDT`;
}
var HYPERLIQUID_DEFAULT_PRECISION = {
  price: 6,
  amount: 3
};
var HYPERLIQUID_WS_CHANNELS = {
  L2_BOOK: "l2Book",
  TRADES: "trades",
  ALL_MIDS: "allMids",
  USER: "user",
  USER_EVENTS: "userEvents",
  USER_FILLS: "userFills"
};
var HYPERLIQUID_WS_RECONNECT = {
  enabled: true,
  maxAttempts: 10,
  initialDelay: 500,
  maxDelay: 3e4,
  multiplier: 2,
  jitter: 0.1
};
var HYPERLIQUID_FUNDING_INTERVAL_HOURS = 8;
var HYPERLIQUID_ERROR_MESSAGES = {
  "insufficient margin": "INSUFFICIENT_MARGIN",
  "invalid signature": "INVALID_SIGNATURE",
  "order would immediately match": "ORDER_WOULD_MATCH",
  "position does not exist": "POSITION_NOT_FOUND",
  "order not found": "ORDER_NOT_FOUND",
  "rate limit exceeded": "RATE_LIMIT_EXCEEDED"
};

// src/adapters/hyperliquid/HyperliquidAuth.ts
var import_ethers = require("ethers");
var HyperliquidAuth = class {
  constructor(wallet) {
    this.wallet = wallet;
  }
  nonce = Date.now();
  /**
   * Sign a request with EIP-712 signature
   */
  async sign(request) {
    if (!request.body) {
      return {
        ...request,
        headers: this.getHeaders()
      };
    }
    const action = request.body;
    const signedAction = await this.signAction(action);
    return {
      ...request,
      body: signedAction,
      headers: this.getHeaders()
    };
  }
  /**
   * Get authentication headers
   */
  getHeaders() {
    return {
      "Content-Type": "application/json"
    };
  }
  /**
   * Sign an action using EIP-712
   */
  async signAction(action) {
    this.nonce++;
    const connectionId = import_ethers.ethers.keccak256(
      import_ethers.ethers.solidityPacked(["address"], [this.wallet.address])
    );
    const typedData = {
      domain: HYPERLIQUID_EIP712_DOMAIN,
      types: HYPERLIQUID_ACTION_TYPES,
      primaryType: "Agent",
      message: {
        source: "a",
        // 'a' for API
        connectionId
      }
    };
    const signature = await this.wallet.signTypedData(
      typedData.domain,
      { Agent: typedData.types.Agent },
      typedData.message
    );
    const sig = import_ethers.ethers.Signature.from(signature);
    return {
      action,
      nonce: this.nonce,
      signature: {
        r: sig.r,
        s: sig.s,
        v: sig.v
      }
    };
  }
  /**
   * Get wallet address
   */
  getAddress() {
    return this.wallet.address;
  }
  /**
   * Create connection ID for WebSocket authentication
   */
  getConnectionId() {
    return import_ethers.ethers.keccak256(import_ethers.ethers.solidityPacked(["address"], [this.wallet.address]));
  }
};

// src/adapters/hyperliquid/HyperliquidNormalizer.ts
var HyperliquidNormalizer = class {
  // ===========================================================================
  // Symbol Conversion
  // ===========================================================================
  /**
   * Convert Hyperliquid symbol to CCXT format
   *
   * @param hyperliquidSymbol - Hyperliquid symbol (e.g., "BTC-PERP", "ETH-PERP")
   * @returns CCXT formatted symbol (e.g., "BTC/USDT:USDT")
   *
   * @example
   * ```typescript
   * normalizer.symbolToCCXT('BTC-PERP');  // "BTC/USDT:USDT"
   * normalizer.symbolToCCXT('ETH-PERP');  // "ETH/USDT:USDT"
   * ```
   */
  symbolToCCXT(hyperliquidSymbol) {
    return hyperliquidToUnified(hyperliquidSymbol);
  }
  /**
   * Convert CCXT symbol to Hyperliquid format
   *
   * @param ccxtSymbol - CCXT symbol (e.g., "BTC/USDT:USDT")
   * @returns Hyperliquid formatted symbol (e.g., "BTC-PERP")
   *
   * @example
   * ```typescript
   * normalizer.symbolFromCCXT('BTC/USDT:USDT'); // "BTC-PERP"
   * normalizer.symbolFromCCXT('ETH/USDT:USDT'); // "ETH-PERP"
   * ```
   */
  symbolFromCCXT(ccxtSymbol) {
    const [base] = ccxtSymbol.split("/");
    return `${base}-PERP`;
  }
  // ===========================================================================
  // Order Normalization
  // ===========================================================================
  /**
   * Normalize Hyperliquid open order to unified format
   *
   * @param order - Hyperliquid open order
   * @param symbol - Exchange symbol (for reference)
   * @returns Unified order
   */
  normalizeOrder(order, _symbol) {
    const unifiedSymbol = hyperliquidToUnified(order.coin);
    const isBuy = order.side === "B";
    return {
      id: order.oid.toString(),
      symbol: unifiedSymbol,
      type: "limit",
      // Hyperliquid open orders are always limit orders
      side: isBuy ? "buy" : "sell",
      amount: parseFloat(order.origSz),
      price: parseFloat(order.limitPx),
      status: "open",
      filled: parseFloat(order.origSz) - parseFloat(order.sz),
      remaining: parseFloat(order.sz),
      reduceOnly: false,
      postOnly: false,
      clientOrderId: order.cloid,
      timestamp: order.timestamp
    };
  }
  /**
   * Normalize multiple orders
   *
   * @param orders - Array of Hyperliquid orders
   * @param symbol - Exchange symbol
   * @returns Array of unified orders
   */
  normalizeOrders(orders, symbol) {
    return orders.map((order) => this.normalizeOrder(order, symbol));
  }
  /**
   * Normalize Hyperliquid historical order to unified format
   *
   * @param historicalOrder - Hyperliquid historical order
   * @returns Unified order
   */
  normalizeHistoricalOrder(historicalOrder) {
    const order = historicalOrder.order;
    const unifiedSymbol = hyperliquidToUnified(order.coin);
    const isBuy = order.side === "B";
    const origSize = parseFloat(order.origSz);
    const currentSize = parseFloat(order.sz);
    let status;
    switch (historicalOrder.status) {
      case "filled":
        status = "filled";
        break;
      case "canceled":
        status = "canceled";
        break;
      case "rejected":
        status = "rejected";
        break;
      case "open":
        status = "open";
        break;
      default:
        status = "open";
    }
    return {
      id: order.oid.toString(),
      symbol: unifiedSymbol,
      type: "limit",
      // Historical orders are typically limits
      side: isBuy ? "buy" : "sell",
      amount: origSize,
      price: parseFloat(order.limitPx),
      status,
      filled: origSize - currentSize,
      remaining: currentSize,
      reduceOnly: false,
      postOnly: false,
      clientOrderId: order.cloid,
      timestamp: order.timestamp,
      lastUpdateTimestamp: historicalOrder.statusTimestamp,
      info: {
        orderType: order.orderType
      }
    };
  }
  // ===========================================================================
  // Position Normalization
  // ===========================================================================
  /**
   * Normalize Hyperliquid position to unified format
   *
   * @param hlPosition - Hyperliquid position
   * @returns Unified position
   */
  normalizePosition(hlPosition) {
    const pos = hlPosition.position;
    const unifiedSymbol = hyperliquidToUnified(pos.coin);
    const size = Math.abs(parseFloat(pos.szi));
    const isLong = parseFloat(pos.szi) > 0;
    return {
      symbol: unifiedSymbol,
      side: isLong ? "long" : "short",
      size,
      entryPrice: parseFloat(pos.entryPx),
      markPrice: 0,
      // Need to fetch separately
      liquidationPrice: pos.liquidationPx ? parseFloat(pos.liquidationPx) : 0,
      unrealizedPnl: parseFloat(pos.unrealizedPnl),
      realizedPnl: 0,
      // Not provided in position data
      leverage: pos.leverage.value,
      marginMode: pos.leverage.type,
      margin: parseFloat(pos.marginUsed),
      maintenanceMargin: 0,
      // Not directly provided
      marginRatio: 0,
      // Calculate if needed
      timestamp: Date.now()
    };
  }
  /**
   * Normalize multiple positions
   *
   * @param positions - Array of Hyperliquid positions
   * @returns Array of unified positions
   */
  normalizePositions(positions) {
    return positions.map((pos) => this.normalizePosition(pos));
  }
  // ===========================================================================
  // Market Normalization
  // ===========================================================================
  /**
   * Normalize Hyperliquid asset to unified market format
   *
   * @param asset - Hyperliquid asset
   * @param index - Market index
   * @returns Unified market
   */
  normalizeMarket(asset, index) {
    const unifiedSymbol = hyperliquidToUnified(asset.name);
    const [base = "", rest = ""] = unifiedSymbol.split("/");
    const [quote = "", settle = ""] = rest.split(":");
    return {
      id: index.toString(),
      symbol: unifiedSymbol,
      base,
      quote,
      settle,
      active: true,
      minAmount: Math.pow(10, -asset.szDecimals),
      pricePrecision: HYPERLIQUID_DEFAULT_PRECISION.price,
      amountPrecision: asset.szDecimals,
      priceTickSize: Math.pow(10, -HYPERLIQUID_DEFAULT_PRECISION.price),
      amountStepSize: Math.pow(10, -asset.szDecimals),
      makerFee: 2e-4,
      // 0.02%
      takerFee: 5e-4,
      // 0.05%
      maxLeverage: asset.maxLeverage,
      fundingIntervalHours: HYPERLIQUID_FUNDING_INTERVAL_HOURS,
      info: {
        onlyIsolated: asset.onlyIsolated
      }
    };
  }
  /**
   * Normalize multiple markets
   *
   * @param assets - Array of Hyperliquid assets
   * @returns Array of unified markets
   */
  normalizeMarkets(assets) {
    return assets.map((asset, index) => this.normalizeMarket(asset, index));
  }
  // ===========================================================================
  // Order Book Normalization
  // ===========================================================================
  /**
   * Normalize Hyperliquid L2 order book to unified format
   *
   * @param book - Hyperliquid L2 book
   * @returns Unified order book
   */
  normalizeOrderBook(book) {
    const unifiedSymbol = hyperliquidToUnified(book.coin);
    const bids = book.levels[0]?.map((level) => [
      parseFloat(level.px),
      parseFloat(level.sz)
    ]) || [];
    const asks = book.levels[1]?.map((level) => [
      parseFloat(level.px),
      parseFloat(level.sz)
    ]) || [];
    return {
      symbol: unifiedSymbol,
      timestamp: book.time,
      bids,
      asks,
      exchange: "hyperliquid"
    };
  }
  // ===========================================================================
  // Trade Normalization
  // ===========================================================================
  /**
   * Normalize Hyperliquid WebSocket trade to unified format
   *
   * @param trade - Hyperliquid WS trade
   * @returns Unified trade
   */
  normalizeTrade(trade) {
    const unifiedSymbol = hyperliquidToUnified(trade.coin);
    const price = parseFloat(trade.px);
    const amount = parseFloat(trade.sz);
    return {
      id: trade.hash,
      symbol: unifiedSymbol,
      side: trade.side === "B" ? "buy" : "sell",
      price,
      amount,
      cost: price * amount,
      timestamp: trade.time
    };
  }
  /**
   * Normalize Hyperliquid fill to unified trade format
   *
   * @param fill - Hyperliquid fill
   * @returns Unified trade
   */
  normalizeFill(fill) {
    const unifiedSymbol = hyperliquidToUnified(fill.coin);
    const price = parseFloat(fill.px);
    const amount = parseFloat(fill.sz);
    return {
      id: fill.hash,
      symbol: unifiedSymbol,
      side: fill.side === "B" ? "buy" : "sell",
      price,
      amount,
      cost: price * amount,
      timestamp: fill.time,
      info: {
        fee: fill.fee,
        closedPnl: fill.closedPnl,
        tid: fill.tid
      }
    };
  }
  /**
   * Normalize Hyperliquid user fill to unified trade format
   *
   * @param fill - Hyperliquid user fill
   * @returns Unified trade
   */
  normalizeUserFill(fill) {
    return this.normalizeFill(fill);
  }
  /**
   * Normalize multiple trades
   *
   * @param trades - Array of Hyperliquid trades
   * @returns Array of unified trades
   */
  normalizeTrades(trades) {
    return trades.map((trade) => this.normalizeTrade(trade));
  }
  // ===========================================================================
  // Funding Rate Normalization
  // ===========================================================================
  /**
   * Normalize Hyperliquid funding rate to unified format
   *
   * @param fundingData - Hyperliquid funding rate
   * @param markPrice - Current mark price
   * @returns Unified funding rate
   */
  normalizeFundingRate(fundingData, markPrice) {
    const unifiedSymbol = hyperliquidToUnified(fundingData.coin);
    return {
      symbol: unifiedSymbol,
      fundingRate: parseFloat(fundingData.fundingRate),
      fundingTimestamp: fundingData.time,
      nextFundingTimestamp: fundingData.time + HYPERLIQUID_FUNDING_INTERVAL_HOURS * 3600 * 1e3,
      markPrice,
      indexPrice: markPrice,
      // Hyperliquid doesn't separate index price
      fundingIntervalHours: HYPERLIQUID_FUNDING_INTERVAL_HOURS
    };
  }
  // ===========================================================================
  // Balance Normalization
  // ===========================================================================
  /**
   * Normalize Hyperliquid user state to unified balance format
   *
   * @param userState - Hyperliquid user state
   * @returns Array of unified balances
   */
  normalizeBalance(userState) {
    const accountValue = parseFloat(userState.marginSummary.accountValue);
    const totalMarginUsed = parseFloat(userState.marginSummary.totalMarginUsed);
    const withdrawable = parseFloat(userState.withdrawable);
    return [
      {
        currency: "USDT",
        total: accountValue,
        free: withdrawable,
        used: totalMarginUsed,
        usdValue: accountValue
      }
    ];
  }
  // ===========================================================================
  // Ticker Normalization
  // ===========================================================================
  /**
   * Normalize ticker data
   *
   * @param coin - Hyperliquid coin symbol
   * @param data - Ticker data with mid price
   * @returns Unified ticker
   */
  normalizeTicker(coin, data) {
    const unifiedSymbol = hyperliquidToUnified(coin);
    const mid = parseFloat(data.mid);
    return {
      symbol: unifiedSymbol,
      last: mid,
      bid: mid,
      ask: mid,
      high: mid,
      low: mid,
      open: mid,
      close: mid,
      change: 0,
      percentage: 0,
      baseVolume: 0,
      quoteVolume: 0,
      timestamp: Date.now()
    };
  }
};

// src/adapters/hyperliquid/HyperliquidWebSocket.ts
var HyperliquidWebSocket = class {
  wsManager;
  normalizer;
  auth;
  symbolToExchange;
  fetchOpenOrders;
  constructor(deps) {
    this.wsManager = deps.wsManager;
    this.normalizer = deps.normalizer;
    this.auth = deps.auth;
    this.symbolToExchange = deps.symbolToExchange;
    this.fetchOpenOrders = deps.fetchOpenOrders;
  }
  /**
   * Watch order book updates in real-time
   *
   * @param symbol - Symbol in unified format (e.g., "BTC/USDT:USDT")
   * @param _limit - Optional depth limit (not used by Hyperliquid)
   */
  async *watchOrderBook(symbol, _limit) {
    const exchangeSymbol = this.symbolToExchange(symbol);
    const subscription = {
      method: "subscribe",
      subscription: {
        type: HYPERLIQUID_WS_CHANNELS.L2_BOOK,
        coin: exchangeSymbol
      }
    };
    const unsubscribe = {
      method: "unsubscribe",
      subscription: {
        type: HYPERLIQUID_WS_CHANNELS.L2_BOOK,
        coin: exchangeSymbol
      }
    };
    for await (const data of this.wsManager.watch(
      `${HYPERLIQUID_WS_CHANNELS.L2_BOOK}:${exchangeSymbol}`,
      subscription,
      unsubscribe
    )) {
      yield this.normalizer.normalizeOrderBook(data);
    }
  }
  /**
   * Watch trades in real-time
   *
   * @param symbol - Symbol in unified format (e.g., "BTC/USDT:USDT")
   */
  async *watchTrades(symbol) {
    const exchangeSymbol = this.symbolToExchange(symbol);
    const subscription = {
      method: "subscribe",
      subscription: {
        type: HYPERLIQUID_WS_CHANNELS.TRADES,
        coin: exchangeSymbol
      }
    };
    for await (const data of this.wsManager.watch(
      `${HYPERLIQUID_WS_CHANNELS.TRADES}:${exchangeSymbol}`,
      subscription
    )) {
      yield this.normalizer.normalizeTrade(data);
    }
  }
  /**
   * Watch ticker updates in real-time
   *
   * Subscribes to allMids channel and filters for the requested symbol.
   *
   * @param symbol - Symbol in unified format (e.g., "BTC/USDT:USDT")
   */
  async *watchTicker(symbol) {
    const subscription = {
      method: "subscribe",
      subscription: {
        type: HYPERLIQUID_WS_CHANNELS.ALL_MIDS
      }
    };
    const exchangeSymbol = this.symbolToExchange(symbol);
    for await (const data of this.wsManager.watch(
      HYPERLIQUID_WS_CHANNELS.ALL_MIDS,
      subscription
    )) {
      const mid = data.mids?.[exchangeSymbol];
      if (mid) {
        yield this.normalizer.normalizeTicker(exchangeSymbol, { mid });
      }
    }
  }
  /**
   * Watch position updates in real-time
   *
   * Requires authentication.
   */
  async *watchPositions() {
    if (!this.auth) {
      throw new Error("Authentication required for position streaming");
    }
    const subscription = {
      method: "subscribe",
      subscription: {
        type: HYPERLIQUID_WS_CHANNELS.USER,
        user: this.auth.getAddress()
      }
    };
    for await (const data of this.wsManager.watch(
      `${HYPERLIQUID_WS_CHANNELS.USER}:${this.auth.getAddress()}`,
      subscription
    )) {
      const positions = data.assetPositions.filter((p) => parseFloat(p.position.szi) !== 0).map((p) => this.normalizer.normalizePosition(p));
      yield positions;
    }
  }
  /**
   * Watch open orders in real-time
   *
   * Subscribes to user fills and yields updated order list when fills occur.
   * Requires authentication.
   */
  async *watchOrders() {
    if (!this.auth) {
      throw new Error("Authentication required for order streaming");
    }
    const subscription = {
      method: "subscribe",
      subscription: {
        type: HYPERLIQUID_WS_CHANNELS.USER_FILLS,
        user: this.auth.getAddress()
      }
    };
    yield await this.fetchOpenOrders();
    for await (const _fillEvent of this.wsManager.watch(
      `${HYPERLIQUID_WS_CHANNELS.USER_FILLS}:${this.auth.getAddress()}`,
      subscription
    )) {
      const orders = await this.fetchOpenOrders();
      yield orders;
    }
  }
  /**
   * Watch user trades (fills) in real-time
   *
   * Requires authentication.
   *
   * @param symbol - Optional symbol to filter trades
   */
  async *watchMyTrades(symbol) {
    if (!this.auth) {
      throw new Error("Authentication required for trade streaming");
    }
    const subscription = {
      method: "subscribe",
      subscription: {
        type: HYPERLIQUID_WS_CHANNELS.USER_FILLS,
        user: this.auth.getAddress()
      }
    };
    const exchangeSymbol = symbol ? this.symbolToExchange(symbol) : void 0;
    for await (const fill of this.wsManager.watch(
      `${HYPERLIQUID_WS_CHANNELS.USER_FILLS}:${this.auth.getAddress()}`,
      subscription
    )) {
      if (exchangeSymbol && fill.coin !== exchangeSymbol) {
        continue;
      }
      yield this.normalizer.normalizeUserFill(fill);
    }
  }
};

// src/adapters/hyperliquid/utils.ts
function convertOrderRequest(request, exchangeSymbol) {
  const isBuy = request.side === "buy";
  let orderType;
  if (request.type === "market") {
    orderType = { market: {} };
  } else {
    let tif = "Gtc";
    if (request.timeInForce === "IOC") {
      tif = "Ioc";
    } else if (request.postOnly) {
      tif = "Alo";
    }
    orderType = { limit: { tif } };
  }
  return {
    coin: exchangeSymbol,
    is_buy: isBuy,
    sz: request.amount,
    limit_px: request.price ?? 0,
    order_type: orderType,
    reduce_only: request.reduceOnly ?? false,
    cloid: request.clientOrderId
  };
}
function mapError(error) {
  if (error instanceof PerpDEXError) {
    return error;
  }
  if (error instanceof Error) {
    const message = error.message.toLowerCase();
    for (const [pattern, code] of Object.entries(HYPERLIQUID_ERROR_MESSAGES)) {
      if (message.includes(pattern)) {
        switch (code) {
          case "INSUFFICIENT_MARGIN":
            return new InsufficientMarginError(error.message, code, "hyperliquid", error);
          case "INVALID_SIGNATURE":
            return new InvalidSignatureError(error.message, code, "hyperliquid", error);
          case "ORDER_WOULD_MATCH":
            return new InvalidOrderError(error.message, code, "hyperliquid", error);
          case "POSITION_NOT_FOUND":
            return new PositionNotFoundError(error.message, code, "hyperliquid", error);
          case "ORDER_NOT_FOUND":
            return new OrderNotFoundError(error.message, code, "hyperliquid", error);
          case "RATE_LIMIT_EXCEEDED":
            return new RateLimitError(error.message, code, "hyperliquid", void 0, error);
        }
      }
    }
    if (message.includes("429")) {
      return new RateLimitError("Rate limit exceeded", "RATE_LIMIT", "hyperliquid", void 0, error);
    }
    if (message.includes("503") || message.includes("502")) {
      return new ExchangeUnavailableError(
        "Exchange temporarily unavailable",
        "EXCHANGE_DOWN",
        "hyperliquid",
        error
      );
    }
  }
  return new ExchangeUnavailableError(
    "Unknown exchange error",
    "UNKNOWN_ERROR",
    "hyperliquid",
    error
  );
}

// src/adapters/hyperliquid/HyperliquidMarketData.ts
var INTERVAL_MAP = {
  "1m": "1m",
  "3m": "3m",
  "5m": "5m",
  "15m": "15m",
  "30m": "30m",
  "1h": "1h",
  "2h": "2h",
  "4h": "4h",
  "6h": "6h",
  "8h": "8h",
  "12h": "12h",
  "1d": "1d",
  "3d": "3d",
  "1w": "1w",
  "1M": "1M"
};
var DURATION_MAP = {
  "1m": 24 * 60 * 60 * 1e3,
  // 24 hours of 1m candles
  "3m": 3 * 24 * 60 * 60 * 1e3,
  // 3 days
  "5m": 5 * 24 * 60 * 60 * 1e3,
  // 5 days
  "15m": 7 * 24 * 60 * 60 * 1e3,
  // 7 days
  "30m": 14 * 24 * 60 * 60 * 1e3,
  // 14 days
  "1h": 30 * 24 * 60 * 60 * 1e3,
  // 30 days
  "2h": 60 * 24 * 60 * 60 * 1e3,
  // 60 days
  "4h": 90 * 24 * 60 * 60 * 1e3,
  // 90 days
  "6h": 120 * 24 * 60 * 60 * 1e3,
  // 120 days
  "8h": 180 * 24 * 60 * 60 * 1e3,
  // 180 days
  "12h": 365 * 24 * 60 * 60 * 1e3,
  // 1 year
  "1d": 365 * 24 * 60 * 60 * 1e3,
  // 1 year
  "3d": 2 * 365 * 24 * 60 * 60 * 1e3,
  // 2 years
  "1w": 3 * 365 * 24 * 60 * 60 * 1e3,
  // 3 years
  "1M": 5 * 365 * 24 * 60 * 60 * 1e3
  // 5 years
};
function getInterval(timeframe) {
  return INTERVAL_MAP[timeframe] || "1h";
}
function getDefaultDuration(timeframe) {
  return DURATION_MAP[timeframe] || 30 * 24 * 60 * 60 * 1e3;
}
function buildOHLCVRequest(exchangeSymbol, timeframe, params) {
  const now = Date.now();
  const defaultDuration = getDefaultDuration(timeframe);
  return {
    coin: exchangeSymbol,
    interval: getInterval(timeframe),
    startTime: params?.since ?? now - defaultDuration,
    endTime: params?.until ?? now
  };
}
function parseCandles(response, limit) {
  if (!response || !Array.isArray(response)) {
    return [];
  }
  const candles = limit ? response.slice(-limit) : response;
  return candles.map((candle) => [
    candle.t,
    parseFloat(candle.o),
    parseFloat(candle.h),
    parseFloat(candle.l),
    parseFloat(candle.c),
    parseFloat(candle.v)
  ]);
}
function parseFundingRates(response, symbol, markPrice, limit) {
  let fundingRates = response.map((rate) => ({
    symbol,
    fundingRate: parseFloat(rate.fundingRate),
    fundingTimestamp: rate.time,
    nextFundingTimestamp: rate.time + 8 * 3600 * 1e3,
    // 8 hours
    markPrice,
    indexPrice: markPrice,
    fundingIntervalHours: 8
  }));
  fundingRates.sort((a, b) => b.fundingTimestamp - a.fundingTimestamp);
  if (limit) {
    fundingRates = fundingRates.slice(0, limit);
  }
  return fundingRates;
}
function buildCurrentFundingRate(latest, symbol, markPrice) {
  return {
    symbol,
    fundingRate: parseFloat(latest.fundingRate),
    fundingTimestamp: latest.time,
    nextFundingTimestamp: latest.time + 8 * 3600 * 1e3,
    // 8 hours
    markPrice,
    indexPrice: markPrice,
    fundingIntervalHours: 8
  };
}

// src/adapters/hyperliquid/HyperliquidInfoMethods.ts
function parseUserFees(response) {
  const makerFee = parseFloat(response.userAddRate);
  const takerFee = parseFloat(response.userCrossRate);
  return {
    maker: makerFee,
    taker: takerFee,
    info: response
  };
}
function parsePortfolio(response) {
  const dayPeriod = response.find(([period]) => period === "day");
  if (!dayPeriod) {
    throw new PerpDEXError(
      "Day period data not found in portfolio response",
      "INVALID_RESPONSE",
      "hyperliquid"
    );
  }
  const [, dayData] = dayPeriod;
  const latestAccountValue = dayData.accountValueHistory.length > 0 ? parseFloat(dayData.accountValueHistory[dayData.accountValueHistory.length - 1][1]) : 0;
  const latestDailyPnl = dayData.pnlHistory.length > 0 ? parseFloat(dayData.pnlHistory[dayData.pnlHistory.length - 1][1]) : 0;
  const weekPeriod = response.find(([period]) => period === "week");
  const monthPeriod = response.find(([period]) => period === "month");
  const weeklyPnl = weekPeriod && weekPeriod[1].pnlHistory.length > 0 ? parseFloat(weekPeriod[1].pnlHistory[weekPeriod[1].pnlHistory.length - 1][1]) : 0;
  const monthlyPnl = monthPeriod && monthPeriod[1].pnlHistory.length > 0 ? parseFloat(monthPeriod[1].pnlHistory[monthPeriod[1].pnlHistory.length - 1][1]) : 0;
  const dailyPnlPercentage = latestAccountValue > 0 ? latestDailyPnl / latestAccountValue * 100 : 0;
  const weeklyPnlPercentage = latestAccountValue > 0 ? weeklyPnl / latestAccountValue * 100 : 0;
  const monthlyPnlPercentage = latestAccountValue > 0 ? monthlyPnl / latestAccountValue * 100 : 0;
  return {
    totalValue: latestAccountValue,
    dailyPnl: latestDailyPnl,
    dailyPnlPercentage,
    weeklyPnl,
    weeklyPnlPercentage,
    monthlyPnl,
    monthlyPnlPercentage,
    timestamp: Date.now(),
    info: response
  };
}
function parseRateLimitStatus(response) {
  const used = response.nRequestsUsed;
  const cap = response.nRequestsCap;
  const windowMs = 6e4;
  return {
    remaining: cap - used,
    limit: cap,
    resetAt: Date.now() + windowMs,
    percentUsed: cap > 0 ? used / cap * 100 : 0,
    info: response
  };
}

// src/adapters/hyperliquid/HyperliquidAccount.ts
function processOrderHistory(response, normalizer, symbol, since, limit) {
  let orders = response.map((order) => normalizer.normalizeHistoricalOrder(order));
  if (symbol) {
    orders = orders.filter((order) => order.symbol === symbol);
  }
  if (since) {
    orders = orders.filter((order) => order.timestamp >= since);
  }
  orders.sort((a, b) => b.timestamp - a.timestamp);
  if (limit) {
    orders = orders.slice(0, limit);
  }
  return orders;
}
function processUserFills(response, normalizer, symbol, since, limit) {
  let trades = response.map((fill) => normalizer.normalizeUserFill(fill));
  if (symbol) {
    trades = trades.filter((trade) => trade.symbol === symbol);
  }
  if (since) {
    trades = trades.filter((trade) => trade.timestamp >= since);
  }
  trades.sort((a, b) => b.timestamp - a.timestamp);
  if (limit) {
    trades = trades.slice(0, limit);
  }
  return trades;
}
function processOpenOrders(response, normalizer, symbol) {
  const orders = response.map((order) => normalizer.normalizeOrder(order, order.coin));
  if (symbol) {
    return orders.filter((o) => o.symbol === symbol);
  }
  return orders;
}

// src/adapters/hyperliquid/HyperliquidAdapter.ts
var HyperliquidAdapter = class extends BaseAdapter {
  id = "hyperliquid";
  name = "Hyperliquid";
  has = {
    // Market Data
    fetchMarkets: true,
    fetchTicker: true,
    fetchOrderBook: true,
    fetchTrades: true,
    fetchOHLCV: true,
    fetchFundingRate: true,
    fetchFundingRateHistory: true,
    // Trading
    createOrder: true,
    cancelOrder: true,
    cancelAllOrders: true,
    createBatchOrders: true,
    cancelBatchOrders: true,
    editOrder: false,
    // Account History
    fetchOrderHistory: true,
    fetchMyTrades: true,
    fetchDeposits: false,
    fetchWithdrawals: false,
    // Positions & Balance
    fetchPositions: true,
    fetchBalance: true,
    setLeverage: true,
    setMarginMode: "emulated",
    // WebSocket
    watchOrderBook: true,
    watchTrades: true,
    watchTicker: true,
    watchPositions: true,
    watchOrders: true,
    watchBalance: false,
    watchFundingRate: false,
    watchMyTrades: true,
    // Advanced
    twapOrders: false,
    vaultTrading: false,
    // Additional Info
    fetchUserFees: true,
    fetchPortfolio: true,
    fetchRateLimitStatus: true
  };
  apiUrl;
  wsUrl;
  wsManager;
  wsHandler;
  auth;
  rateLimiter;
  normalizer;
  constructor(config = {}) {
    super(config);
    this.apiUrl = config.testnet ? HYPERLIQUID_TESTNET_API : HYPERLIQUID_MAINNET_API;
    this.wsUrl = config.testnet ? HYPERLIQUID_TESTNET_WS : HYPERLIQUID_MAINNET_WS;
    this.normalizer = new HyperliquidNormalizer();
    this.rateLimiter = new RateLimiter({
      maxTokens: config.rateLimit?.maxRequests ?? HYPERLIQUID_RATE_LIMIT.maxRequests,
      windowMs: config.rateLimit?.windowMs ?? HYPERLIQUID_RATE_LIMIT.windowMs,
      weights: config.rateLimit?.weights ?? HYPERLIQUID_RATE_LIMIT.weights,
      exchange: "hyperliquid"
    });
    if (config.wallet) {
      this.auth = new HyperliquidAuth(config.wallet);
    } else if (config.privateKey) {
      const wallet = new import_ethers2.Wallet(config.privateKey);
      this.auth = new HyperliquidAuth(wallet);
    }
  }
  // ===========================================================================
  // Connection Management
  // ===========================================================================
  async initialize() {
    if (this._isReady) {
      return;
    }
    this.wsManager = new WebSocketManager({
      url: this.wsUrl,
      reconnect: HYPERLIQUID_WS_RECONNECT
    });
    await this.wsManager.connect();
    this.wsHandler = new HyperliquidWebSocket({
      wsManager: this.wsManager,
      normalizer: this.normalizer,
      auth: this.auth,
      symbolToExchange: this.symbolToExchange.bind(this),
      fetchOpenOrders: this.fetchOpenOrders.bind(this)
    });
    this._isReady = true;
    this.debug("Adapter initialized");
  }
  async disconnect() {
    if (this.wsManager) {
      await this.wsManager.disconnect();
    }
    this._isReady = false;
    this.debug("Adapter disconnected");
  }
  // ===========================================================================
  // Market Data (Public)
  // ===========================================================================
  async fetchMarkets(params) {
    await this.rateLimiter.acquire("fetchMarkets");
    try {
      const response = await this.request("POST", `${this.apiUrl}/info`, {
        type: "meta"
      });
      const markets = response.universe.map((asset, index) => this.normalizer.normalizeMarket(asset, index));
      if (params?.active !== void 0) {
        return markets.filter((m) => m.active === params.active);
      }
      return markets;
    } catch (error) {
      throw mapError(error);
    }
  }
  async fetchTicker(symbol) {
    await this.rateLimiter.acquire("fetchTicker");
    try {
      const allMids = await this.request("POST", `${this.apiUrl}/info`, {
        type: "allMids"
      });
      const exchangeSymbol = this.symbolToExchange(symbol);
      const mid = allMids[exchangeSymbol];
      if (!mid) {
        throw new Error(`No ticker data for ${symbol}`);
      }
      return this.normalizer.normalizeTicker(exchangeSymbol, { mid });
    } catch (error) {
      throw mapError(error);
    }
  }
  async fetchOrderBook(symbol, _params) {
    await this.rateLimiter.acquire("fetchOrderBook");
    try {
      const exchangeSymbol = this.symbolToExchange(symbol);
      const response = await this.request("POST", `${this.apiUrl}/info`, {
        type: "l2Book",
        coin: exchangeSymbol
      });
      return this.normalizer.normalizeOrderBook(response);
    } catch (error) {
      throw mapError(error);
    }
  }
  async fetchTrades(_symbol, _params) {
    throw new NotSupportedError(
      "fetchTrades is not supported via REST API. Use watchTrades (WebSocket) instead.",
      "NOT_SUPPORTED",
      "hyperliquid"
    );
  }
  /**
   * Fetch OHLCV (candlestick) data
   *
   * @param symbol - Symbol in unified format (e.g., "BTC/USDT:USDT")
   * @param timeframe - Candlestick timeframe
   * @param params - Optional parameters (since, until, limit)
   * @returns Array of OHLCV tuples [timestamp, open, high, low, close, volume]
   */
  async fetchOHLCV(symbol, timeframe = "1h", params) {
    await this.rateLimiter.acquire("fetchOHLCV");
    try {
      const exchangeSymbol = this.symbolToExchange(symbol);
      const req = buildOHLCVRequest(exchangeSymbol, timeframe, params);
      const response = await this.request("POST", `${this.apiUrl}/info`, {
        type: "candleSnapshot",
        req
      });
      return parseCandles(response, params?.limit);
    } catch (error) {
      throw mapError(error);
    }
  }
  async fetchFundingRate(symbol) {
    await this.rateLimiter.acquire("fetchFundingRate");
    try {
      const exchangeSymbol = this.symbolToExchange(symbol);
      const response = await this.request("POST", `${this.apiUrl}/info`, {
        type: "fundingHistory",
        coin: exchangeSymbol,
        startTime: Date.now() - 864e5
        // Last 24h
      });
      if (!response || response.length === 0) {
        throw new Error(`No funding rate data for ${symbol}`);
      }
      const latest = response[response.length - 1];
      if (!latest) {
        throw new Error(`No funding rate data for ${symbol}`);
      }
      const allMids = await this.request("POST", `${this.apiUrl}/info`, {
        type: "allMids"
      });
      const markPrice = parseFloat(allMids[exchangeSymbol] ?? "0");
      return buildCurrentFundingRate(latest, symbol, markPrice);
    } catch (error) {
      throw mapError(error);
    }
  }
  async fetchFundingRateHistory(symbol, since, limit) {
    await this.rateLimiter.acquire("fetchFundingRateHistory");
    try {
      const exchangeSymbol = this.symbolToExchange(symbol);
      const startTime = since ?? Date.now() - 7 * 24 * 3600 * 1e3;
      const response = await this.request(
        "POST",
        `${this.apiUrl}/info`,
        {
          type: "fundingHistory",
          coin: exchangeSymbol,
          startTime
        }
      );
      if (!response || response.length === 0) {
        return [];
      }
      const allMids = await this.request("POST", `${this.apiUrl}/info`, {
        type: "allMids"
      });
      const markPrice = parseFloat(allMids[exchangeSymbol] ?? "0");
      return parseFundingRates(response, symbol, markPrice, limit);
    } catch (error) {
      throw mapError(error);
    }
  }
  // ===========================================================================
  // Trading (Private)
  // ===========================================================================
  async createOrder(request) {
    const auth = this.ensureAuth();
    const validatedRequest = this.validateOrder(request);
    await this.rateLimiter.acquire("createOrder");
    try {
      const exchangeSymbol = this.symbolToExchange(validatedRequest.symbol);
      const orderRequest = convertOrderRequest(validatedRequest, exchangeSymbol);
      const action = {
        type: "order",
        orders: [orderRequest],
        grouping: "na"
      };
      const signedRequest = await auth.sign({
        method: "POST",
        path: "/exchange",
        body: action
      });
      const response = await this.request(
        "POST",
        `${this.apiUrl}/exchange`,
        signedRequest.body,
        signedRequest.headers
      );
      if (response.status === "err") {
        throw new Error("Order creation failed");
      }
      const status = response.response.data.statuses[0];
      if (!status) {
        throw new Error("No order status in response");
      }
      if ("error" in status) {
        throw new Error(status.error);
      }
      let orderId;
      if ("resting" in status) {
        orderId = status.resting.oid.toString();
      } else if ("filled" in status) {
        orderId = status.filled.oid.toString();
      } else {
        throw new Error("Unknown order status");
      }
      return {
        id: orderId,
        symbol: request.symbol,
        type: request.type,
        side: request.side,
        amount: request.amount,
        price: request.price,
        status: "filled" in status ? "filled" : "open",
        filled: "filled" in status ? parseFloat(status.filled.totalSz) : 0,
        remaining: request.amount,
        reduceOnly: request.reduceOnly ?? false,
        postOnly: request.postOnly ?? false,
        clientOrderId: request.clientOrderId,
        timestamp: Date.now()
      };
    } catch (error) {
      throw mapError(error);
    }
  }
  async cancelOrder(orderId, symbol) {
    const auth = this.ensureAuth();
    await this.rateLimiter.acquire("cancelOrder");
    try {
      if (!symbol) {
        throw new Error("Symbol required for order cancellation");
      }
      const exchangeSymbol = this.symbolToExchange(symbol);
      const action = {
        type: "cancel",
        cancels: [{ coin: exchangeSymbol, oid: parseInt(orderId) }]
      };
      const signedRequest = await auth.sign({
        method: "POST",
        path: "/exchange",
        body: action
      });
      await this.request(
        "POST",
        `${this.apiUrl}/exchange`,
        signedRequest.body,
        signedRequest.headers
      );
      return {
        id: orderId,
        symbol,
        type: "limit",
        side: "buy",
        amount: 0,
        status: "canceled",
        filled: 0,
        remaining: 0,
        reduceOnly: false,
        postOnly: false,
        timestamp: Date.now()
      };
    } catch (error) {
      throw mapError(error);
    }
  }
  async cancelAllOrders(symbol) {
    this.ensureAuth();
    await this.rateLimiter.acquire("cancelAllOrders");
    try {
      const openOrders = await this.fetchOpenOrders(symbol);
      const canceledOrders = [];
      for (const order of openOrders) {
        try {
          const canceled = await this.cancelOrder(order.id, order.symbol);
          canceledOrders.push(canceled);
        } catch (error) {
          const errorMessage = error instanceof Error ? error.message : String(error);
          this.debug("Failed to cancel order", { orderId: order.id, error: errorMessage });
        }
      }
      return canceledOrders;
    } catch (error) {
      throw mapError(error);
    }
  }
  // ===========================================================================
  // Account History
  // ===========================================================================
  async fetchOrderHistory(symbol, since, limit) {
    try {
      const response = await this.authInfoRequest("fetchOrderHistory", "historicalOrders");
      return processOrderHistory(response, this.normalizer, symbol, since, limit);
    } catch (error) {
      throw mapError(error);
    }
  }
  async fetchMyTrades(symbol, since, limit) {
    try {
      const response = await this.authInfoRequest("fetchMyTrades", "userFills");
      return processUserFills(response, this.normalizer, symbol, since, limit);
    } catch (error) {
      throw mapError(error);
    }
  }
  // ===========================================================================
  // Positions & Balance
  // ===========================================================================
  async fetchPositions(symbols) {
    try {
      const response = await this.authInfoRequest("fetchPositions", "clearinghouseState");
      const positions = response.assetPositions.filter((p) => parseFloat(p.position.szi) !== 0).map((p) => this.normalizer.normalizePosition(p));
      if (symbols && symbols.length > 0) {
        return positions.filter((p) => symbols.includes(p.symbol));
      }
      return positions;
    } catch (error) {
      throw mapError(error);
    }
  }
  async fetchBalance() {
    try {
      const response = await this.authInfoRequest("fetchBalance", "clearinghouseState");
      return this.normalizer.normalizeBalance(response);
    } catch (error) {
      throw mapError(error);
    }
  }
  async setLeverage(symbol, leverage) {
    this.ensureAuth();
    await this.rateLimiter.acquire("setLeverage", 5);
    this.debug(`setLeverage: Updating leverage for ${symbol} to ${leverage}x`);
  }
  // ===========================================================================
  // Additional Info Methods
  // ===========================================================================
  /** Ensure authenticated and return auth instance */
  ensureAuth() {
    this.ensureInitialized();
    if (!this.auth) {
      throw new Error("Authentication required");
    }
    return this.auth;
  }
  /** Make authenticated info request */
  async authInfoRequest(rateLimitKey, type) {
    const auth = this.ensureAuth();
    await this.rateLimiter.acquire(rateLimitKey);
    return this.request("POST", `${this.apiUrl}/info`, {
      type,
      user: auth.getAddress()
    });
  }
  async fetchUserFees() {
    try {
      const response = await this.authInfoRequest("fetchUserFees", "userFees");
      return parseUserFees(response);
    } catch (error) {
      throw mapError(error);
    }
  }
  async fetchPortfolio() {
    try {
      const response = await this.authInfoRequest("fetchPortfolio", "portfolio");
      return parsePortfolio(response);
    } catch (error) {
      throw mapError(error);
    }
  }
  async fetchRateLimitStatus() {
    try {
      const response = await this.authInfoRequest("fetchRateLimitStatus", "userRateLimit");
      return parseRateLimitStatus(response);
    } catch (error) {
      throw mapError(error);
    }
  }
  // ===========================================================================
  // WebSocket Streams (delegated to HyperliquidWebSocket)
  // ===========================================================================
  ensureWsHandler() {
    this.ensureInitialized();
    if (!this.wsHandler) {
      throw new Error("WebSocket handler not initialized");
    }
    return this.wsHandler;
  }
  async *watchOrderBook(symbol, limit) {
    yield* this.ensureWsHandler().watchOrderBook(symbol, limit);
  }
  async *watchTrades(symbol) {
    yield* this.ensureWsHandler().watchTrades(symbol);
  }
  async *watchTicker(symbol) {
    yield* this.ensureWsHandler().watchTicker(symbol);
  }
  async *watchPositions() {
    yield* this.ensureWsHandler().watchPositions();
  }
  async *watchOrders() {
    yield* this.ensureWsHandler().watchOrders();
  }
  async *watchMyTrades(symbol) {
    yield* this.ensureWsHandler().watchMyTrades(symbol);
  }
  // ===========================================================================
  // Helper Methods
  // ===========================================================================
  /** Get default duration for OHLCV timeframe */
  getDefaultDuration(timeframe) {
    return getDefaultDuration(timeframe);
  }
  symbolToExchange(symbol) {
    return unifiedToHyperliquid(symbol);
  }
  symbolFromExchange(exchangeSymbol) {
    return hyperliquidToUnified(exchangeSymbol);
  }
  /**
   * Fetch open orders
   *
   * @param symbol - Optional symbol to filter orders (e.g., "BTC/USDT:USDT")
   * @returns Array of open orders
   */
  async fetchOpenOrders(symbol) {
    if (!this.auth) {
      throw new Error("Authentication required");
    }
    try {
      const response = await this.request(
        "POST",
        `${this.apiUrl}/info`,
        {
          type: "openOrders",
          user: this.auth.getAddress()
        }
      );
      return processOpenOrders(response, this.normalizer, symbol);
    } catch (error) {
      throw mapError(error);
    }
  }
};

// src/utils/crypto.ts
var isBrowser2 = typeof window !== "undefined" && typeof window.crypto !== "undefined";
async function createHmacSha256(key, message) {
  if (isBrowser2) {
    const encoder = new TextEncoder();
    const keyData = encoder.encode(key);
    const msgData = encoder.encode(message);
    const cryptoKey = await crypto.subtle.importKey(
      "raw",
      keyData,
      { name: "HMAC", hash: "SHA-256" },
      false,
      ["sign"]
    );
    const signature = await crypto.subtle.sign("HMAC", cryptoKey, msgData);
    return arrayBufferToHex(signature);
  } else {
    const { createHmac } = await import("crypto");
    return createHmac("sha256", key).update(message).digest("hex");
  }
}
async function createSha3Hash(data) {
  const { sha3_256 } = await Promise.resolve().then(() => __toESM(require_sha3(), 1));
  return sha3_256(data);
}
async function createSha3HashBuffer(data) {
  const { sha3_256 } = await Promise.resolve().then(() => __toESM(require_sha3(), 1));
  return new Uint8Array(sha3_256.array(data));
}
async function createSha256Hash(data) {
  if (isBrowser2) {
    const encoder = new TextEncoder();
    const msgData = typeof data === "string" ? encoder.encode(data) : data;
    const hashBuffer = await crypto.subtle.digest("SHA-256", msgData);
    return arrayBufferToHex(hashBuffer);
  } else {
    const { createHash } = await import("crypto");
    return createHash("sha256").update(data).digest("hex");
  }
}
async function createSha256HashBuffer(data) {
  if (isBrowser2) {
    const encoder = new TextEncoder();
    const msgData = typeof data === "string" ? encoder.encode(data) : data;
    const hashBuffer = await crypto.subtle.digest("SHA-256", msgData);
    return new Uint8Array(hashBuffer);
  } else {
    const { createHash } = await import("crypto");
    const hash3 = createHash("sha256").update(data).digest();
    return new Uint8Array(hash3);
  }
}
function arrayBufferToHex(buffer) {
  const bytes = new Uint8Array(buffer);
  return Array.from(bytes).map((b) => b.toString(16).padStart(2, "0")).join("");
}
function hexToBytes(hex) {
  const cleanHex = hex.startsWith("0x") ? hex.slice(2) : hex;
  const bytes = new Uint8Array(cleanHex.length / 2);
  for (let i = 0; i < cleanHex.length; i += 2) {
    bytes[i / 2] = parseInt(cleanHex.substr(i, 2), 16);
  }
  return bytes;
}
function bytesToHex(bytes) {
  return Array.from(bytes).map((b) => b.toString(16).padStart(2, "0")).join("");
}

// src/core/http/HTTPClient.ts
var DEFAULT_CONFIG2 = {
  timeout: 3e4,
  retry: {
    maxAttempts: 3,
    initialDelay: 1e3,
    maxDelay: 1e4,
    multiplier: 2,
    retryableStatuses: [408, 429, 500, 502, 503, 504]
  },
  circuitBreaker: {
    enabled: true,
    failureThreshold: 5,
    successThreshold: 2,
    resetTimeout: 6e4
  }
};
var HTTPClient = class {
  baseUrl;
  timeout;
  retryConfig;
  circuitBreaker;
  defaultHeaders;
  exchange;
  constructor(config) {
    this.baseUrl = config.baseUrl;
    this.exchange = config.exchange;
    this.timeout = config.timeout ?? DEFAULT_CONFIG2.timeout;
    this.retryConfig = { ...DEFAULT_CONFIG2.retry, ...config.retry };
    this.defaultHeaders = {
      "Content-Type": "application/json",
      ...config.defaultHeaders
    };
    const cbConfig = { ...DEFAULT_CONFIG2.circuitBreaker, ...config.circuitBreaker };
    if (cbConfig.enabled) {
      this.circuitBreaker = new CircuitBreaker({
        failureThreshold: cbConfig.failureThreshold,
        successThreshold: cbConfig.successThreshold,
        resetTimeout: cbConfig.resetTimeout
      });
    } else {
      this.circuitBreaker = null;
    }
  }
  /**
   * Make HTTP GET request
   */
  async get(path, options = {}) {
    return this.request("GET", path, options);
  }
  /**
   * Make HTTP POST request
   */
  async post(path, options = {}) {
    return this.request("POST", path, options);
  }
  /**
   * Make HTTP PUT request
   */
  async put(path, options = {}) {
    return this.request("PUT", path, options);
  }
  /**
   * Make HTTP DELETE request
   */
  async delete(path, options = {}) {
    return this.request("DELETE", path, options);
  }
  /**
   * Make HTTP request with retry and circuit breaker
   */
  async request(method, path, options) {
    const url = `${this.baseUrl}${path}`;
    const timeout = options.timeout ?? this.timeout;
    const executeRequest = async () => {
      if (options.skipRetry) {
        return this.executeRequest(method, url, options, timeout);
      }
      let lastError;
      for (let attempt = 0; attempt < this.retryConfig.maxAttempts; attempt++) {
        try {
          return await this.executeRequest(method, url, options, timeout);
        } catch (error) {
          lastError = error;
          if (error instanceof PerpDEXError && !this.shouldRetry(error, attempt)) {
            throw error;
          }
          if (attempt === this.retryConfig.maxAttempts - 1) {
            throw error;
          }
          const delay = Math.min(
            this.retryConfig.initialDelay * Math.pow(this.retryConfig.multiplier, attempt),
            this.retryConfig.maxDelay
          );
          await new Promise((resolve) => setTimeout(resolve, delay));
        }
      }
      throw lastError || new Error("Request failed");
    };
    if (this.circuitBreaker) {
      return this.circuitBreaker.execute(executeRequest);
    } else {
      return executeRequest();
    }
  }
  /**
   * Execute single HTTP request
   */
  async executeRequest(method, url, options, timeout) {
    const headers = {
      ...this.defaultHeaders,
      ...options.headers
    };
    let body;
    if (options.body) {
      body = typeof options.body === "string" ? options.body : JSON.stringify(options.body);
    }
    try {
      const controller = new AbortController();
      const timeoutId = setTimeout(() => controller.abort(), timeout);
      const response = await fetch(url, {
        method,
        headers,
        body,
        signal: controller.signal
      });
      clearTimeout(timeoutId);
      if (!response.ok) {
        await this.handleErrorResponse(response);
      }
      return await response.json();
    } catch (error) {
      if (error instanceof Error) {
        if (error.name === "AbortError") {
          throw new NetworkError(
            `Request timeout after ${timeout}ms`,
            "REQUEST_TIMEOUT",
            this.exchange,
            error
          );
        }
        if (error.message.includes("fetch") || error.message.includes("network")) {
          throw new NetworkError(
            "Network request failed",
            "NETWORK_ERROR",
            this.exchange,
            error
          );
        }
      }
      throw error;
    }
  }
  /**
   * Handle error response
   */
  async handleErrorResponse(response) {
    let errorBody = {};
    try {
      errorBody = await response.json();
    } catch {
    }
    if (response.status === 429) {
      const retryAfter = response.headers.get("Retry-After");
      throw new RateLimitError(
        "Rate limit exceeded",
        "RATE_LIMIT_EXCEEDED",
        this.exchange,
        retryAfter ? parseInt(retryAfter) : void 0,
        errorBody
      );
    }
    throw new PerpDEXError(
      `HTTP ${response.status}: ${response.statusText}`,
      this.mapStatusToCode(response.status),
      this.exchange,
      errorBody
    );
  }
  /**
   * Map HTTP status to error code
   */
  mapStatusToCode(status) {
    if (status === 400) return "BAD_REQUEST";
    if (status === 401) return "UNAUTHORIZED";
    if (status === 403) return "FORBIDDEN";
    if (status === 404) return "NOT_FOUND";
    if (status === 429) return "RATE_LIMIT_EXCEEDED";
    if (status >= 500) return "SERVER_ERROR";
    return "HTTP_ERROR";
  }
  /**
   * Determine if error should be retried
   */
  shouldRetry(error, attempt) {
    if (attempt >= this.retryConfig.maxAttempts - 1) {
      return false;
    }
    if (error instanceof NetworkError) {
      return true;
    }
    if (error instanceof PerpDEXError) {
      const retryableCodes = ["REQUEST_TIMEOUT", "RATE_LIMIT_EXCEEDED", "SERVER_ERROR"];
      return retryableCodes.includes(error.code);
    }
    return false;
  }
  /**
   * Get circuit breaker state (for monitoring)
   */
  getCircuitBreakerState() {
    return this.circuitBreaker?.getState() ?? null;
  }
};

// src/adapters/lighter/constants.ts
var LIGHTER_API_URLS = {
  mainnet: {
    rest: "https://mainnet.zklighter.elliot.ai",
    websocket: "wss://mainnet.zklighter.elliot.ai/stream"
  },
  testnet: {
    rest: "https://testnet.zklighter.elliot.ai",
    websocket: "wss://testnet.zklighter.elliot.ai/stream"
  }
};
var LIGHTER_RATE_LIMITS = {
  tier1: { maxRequests: 60, windowMs: 6e4 },
  tier2: { maxRequests: 600, windowMs: 6e4 },
  tier3: { maxRequests: 4e3, windowMs: 6e4 }
};
var LIGHTER_ENDPOINT_WEIGHTS = {
  fetchMarkets: 1,
  fetchTicker: 1,
  fetchOrderBook: 2,
  fetchTrades: 2,
  fetchFundingRate: 1,
  fetchPositions: 2,
  fetchBalance: 2,
  fetchOpenOrders: 2,
  createOrder: 5,
  cancelOrder: 3,
  createBatchOrders: 10,
  cancelAllOrders: 10
};
var LIGHTER_WS_CONFIG = {
  reconnectDelay: 1e3,
  maxReconnectDelay: 3e4,
  reconnectAttempts: 5,
  pingInterval: 3e4,
  pongTimeout: 5e3
};
var LIGHTER_WS_CHANNELS = {
  ORDERBOOK: "orderbook",
  TRADES: "trades",
  TICKER: "ticker",
  POSITIONS: "positions",
  ORDERS: "orders",
  FILLS: "fills"
};

// src/adapters/lighter/LighterNormalizer.ts
var LighterNormalizer = class {
  /**
   * Convert unified symbol to Lighter format
   * BTC/USDC:USDC -> BTC (Lighter uses simple symbol names for perps)
   */
  toLighterSymbol(symbol) {
    const [baseQuote] = symbol.split(":");
    const [base] = (baseQuote || "").split("/");
    return base || symbol;
  }
  /**
   * Convert Lighter symbol to unified format
   * BTC -> BTC/USDC:USDC (Lighter perps use USDC as quote/settle)
   */
  normalizeSymbol(lighterSymbol) {
    return `${lighterSymbol}/USDC:USDC`;
  }
  /**
   * Normalize Lighter market to unified format
   * Handles real Lighter API response format from /api/v1/orderBookDetails
   */
  normalizeMarket(lighterMarket) {
    const base = lighterMarket.symbol;
    const quote = "USDC";
    const symbol = `${base}/${quote}:${quote}`;
    const pricePrecision = lighterMarket.supported_price_decimals || lighterMarket.price_decimals || 2;
    const amountPrecision = lighterMarket.supported_size_decimals || lighterMarket.size_decimals || 4;
    const minAmount = parseFloat(lighterMarket.min_base_amount || "0");
    const makerFee = parseFloat(lighterMarket.maker_fee || "0");
    const takerFee = parseFloat(lighterMarket.taker_fee || "0");
    return {
      id: lighterMarket.symbol,
      symbol,
      base,
      quote,
      settle: quote,
      active: lighterMarket.status === "active",
      minAmount,
      maxAmount: void 0,
      pricePrecision,
      amountPrecision,
      priceTickSize: Math.pow(10, -pricePrecision),
      amountStepSize: Math.pow(10, -amountPrecision),
      makerFee,
      takerFee,
      maxLeverage: lighterMarket.default_initial_margin_fraction ? Math.floor(1e4 / lighterMarket.default_initial_margin_fraction) : 20,
      fundingIntervalHours: 8,
      info: lighterMarket
    };
  }
  /**
   * Normalize Lighter order to unified format
   */
  normalizeOrder(lighterOrder) {
    return {
      id: lighterOrder.orderId,
      clientOrderId: lighterOrder.clientOrderId,
      symbol: this.normalizeSymbol(lighterOrder.symbol),
      type: lighterOrder.type,
      side: lighterOrder.side,
      price: lighterOrder.price,
      amount: lighterOrder.size,
      filled: lighterOrder.filledSize,
      remaining: lighterOrder.size - lighterOrder.filledSize,
      status: this.mapOrderStatus(lighterOrder.status),
      timestamp: lighterOrder.timestamp,
      reduceOnly: lighterOrder.reduceOnly,
      postOnly: false,
      info: lighterOrder
    };
  }
  /**
   * Normalize Lighter position to unified format
   */
  normalizePosition(lighterPosition) {
    return {
      symbol: this.normalizeSymbol(lighterPosition.symbol),
      side: lighterPosition.side,
      size: lighterPosition.size,
      entryPrice: lighterPosition.entryPrice,
      markPrice: lighterPosition.markPrice,
      liquidationPrice: lighterPosition.liquidationPrice,
      unrealizedPnl: lighterPosition.unrealizedPnl,
      realizedPnl: 0,
      // Not provided by Lighter
      margin: lighterPosition.margin,
      leverage: lighterPosition.leverage,
      marginMode: "cross",
      // Not provided by Lighter, default to cross
      maintenanceMargin: lighterPosition.margin * 0.5,
      // Estimate as 50% of margin
      marginRatio: lighterPosition.unrealizedPnl / lighterPosition.margin,
      // Calculate from available data
      timestamp: Date.now(),
      info: lighterPosition
    };
  }
  /**
   * Normalize Lighter balance to unified format
   */
  normalizeBalance(lighterBalance) {
    return {
      currency: lighterBalance.currency,
      total: lighterBalance.total,
      free: lighterBalance.available,
      used: lighterBalance.reserved,
      info: lighterBalance
    };
  }
  /**
   * Normalize Lighter order book to unified format
   */
  normalizeOrderBook(lighterOrderBook) {
    return {
      symbol: this.normalizeSymbol(lighterOrderBook.symbol),
      exchange: "lighter",
      bids: lighterOrderBook.bids,
      asks: lighterOrderBook.asks,
      timestamp: lighterOrderBook.timestamp
    };
  }
  /**
   * Normalize Lighter trade to unified format
   */
  normalizeTrade(lighterTrade) {
    return {
      id: lighterTrade.id,
      symbol: this.normalizeSymbol(lighterTrade.symbol),
      side: lighterTrade.side,
      price: lighterTrade.price,
      amount: lighterTrade.amount,
      cost: lighterTrade.price * lighterTrade.amount,
      timestamp: lighterTrade.timestamp,
      info: lighterTrade
    };
  }
  /**
   * Normalize Lighter ticker to unified format
   * Handles real API response from /api/v1/orderBookDetails
   */
  normalizeTicker(lighterTicker) {
    const last = parseFloat(lighterTicker.last_trade_price || "0");
    const high = parseFloat(lighterTicker.daily_price_high || "0");
    const low = parseFloat(lighterTicker.daily_price_low || "0");
    const baseVolume = parseFloat(lighterTicker.daily_base_token_volume || "0");
    const quoteVolume = parseFloat(lighterTicker.daily_quote_token_volume || "0");
    const change = parseFloat(lighterTicker.daily_price_change || "0");
    return {
      symbol: this.normalizeSymbol(lighterTicker.symbol),
      last,
      bid: last,
      // Not directly provided, use last as approximation
      ask: last,
      // Not directly provided, use last as approximation
      high,
      low,
      open: high > 0 ? last / (1 + change / 100) : 0,
      // Calculate from change percentage
      close: last,
      change,
      percentage: change,
      baseVolume,
      quoteVolume,
      timestamp: Date.now(),
      info: lighterTicker
    };
  }
  /**
   * Normalize Lighter funding rate to unified format
   */
  normalizeFundingRate(lighterFundingRate) {
    return {
      symbol: this.normalizeSymbol(lighterFundingRate.symbol),
      fundingRate: lighterFundingRate.fundingRate,
      fundingTimestamp: lighterFundingRate.nextFundingTime,
      nextFundingTimestamp: lighterFundingRate.nextFundingTime,
      markPrice: lighterFundingRate.markPrice,
      indexPrice: lighterFundingRate.markPrice,
      // Not provided by Lighter, use mark price as fallback
      fundingIntervalHours: 8,
      info: lighterFundingRate
    };
  }
  /**
   * Map Lighter order status to unified status
   */
  mapOrderStatus(status) {
    switch (status) {
      case "open":
      case "partially_filled":
        return "open";
      case "filled":
        return "closed";
      case "cancelled":
        return "canceled";
      default:
        return "open";
    }
  }
};

// src/adapters/lighter/LighterWebSocket.ts
var LighterWebSocket = class {
  wsManager;
  normalizer;
  signer;
  apiKey;
  accountIndex;
  apiKeyIndex;
  _hasAuthentication;
  _hasWasmSigning;
  constructor(deps) {
    this.wsManager = deps.wsManager;
    this.normalizer = deps.normalizer;
    this.signer = deps.signer;
    this.apiKey = deps.apiKey;
    this.accountIndex = deps.accountIndex;
    this.apiKeyIndex = deps.apiKeyIndex;
    this._hasAuthentication = deps.hasAuthentication;
    this._hasWasmSigning = deps.hasWasmSigning;
  }
  /**
   * Watch order book updates in real-time
   *
   * @param symbol - Symbol in unified format (e.g., "BTC/USDC:USDC")
   * @param limit - Optional depth limit (default: 50)
   */
  async *watchOrderBook(symbol, limit) {
    const lighterSymbol = this.normalizer.toLighterSymbol(symbol);
    const subscription = {
      type: "subscribe",
      channel: LIGHTER_WS_CHANNELS.ORDERBOOK,
      symbol: lighterSymbol,
      limit: limit || 50
    };
    const channelId = `${LIGHTER_WS_CHANNELS.ORDERBOOK}:${lighterSymbol}`;
    for await (const update of this.wsManager.watch(channelId, subscription)) {
      yield this.normalizer.normalizeOrderBook(update);
    }
  }
  /**
   * Watch trades in real-time
   *
   * @param symbol - Symbol in unified format (e.g., "BTC/USDC:USDC")
   */
  async *watchTrades(symbol) {
    const lighterSymbol = this.normalizer.toLighterSymbol(symbol);
    const subscription = {
      type: "subscribe",
      channel: LIGHTER_WS_CHANNELS.TRADES,
      symbol: lighterSymbol
    };
    const channelId = `${LIGHTER_WS_CHANNELS.TRADES}:${lighterSymbol}`;
    for await (const trade of this.wsManager.watch(channelId, subscription)) {
      yield this.normalizer.normalizeTrade(trade);
    }
  }
  /**
   * Watch ticker updates in real-time
   *
   * @param symbol - Symbol in unified format (e.g., "BTC/USDC:USDC")
   */
  async *watchTicker(symbol) {
    const lighterSymbol = this.normalizer.toLighterSymbol(symbol);
    const subscription = {
      type: "subscribe",
      channel: LIGHTER_WS_CHANNELS.TICKER,
      symbol: lighterSymbol
    };
    const channelId = `${LIGHTER_WS_CHANNELS.TICKER}:${lighterSymbol}`;
    for await (const ticker of this.wsManager.watch(channelId, subscription)) {
      yield this.normalizer.normalizeTicker(ticker);
    }
  }
  /**
   * Watch position updates in real-time
   *
   * Requires authentication.
   */
  async *watchPositions() {
    if (!this._hasAuthentication) {
      throw new PerpDEXError("API credentials required for position streaming", "AUTH_REQUIRED", "lighter");
    }
    const subscription = await this.buildAuthenticatedSubscription(LIGHTER_WS_CHANNELS.POSITIONS);
    const channelId = `${LIGHTER_WS_CHANNELS.POSITIONS}:${this.getAuthIdentifier()}`;
    for await (const positions of this.wsManager.watch(channelId, subscription)) {
      yield positions.map((position) => this.normalizer.normalizePosition(position));
    }
  }
  /**
   * Watch open orders in real-time
   *
   * Requires authentication.
   */
  async *watchOrders() {
    if (!this._hasAuthentication) {
      throw new PerpDEXError("API credentials required for order streaming", "AUTH_REQUIRED", "lighter");
    }
    const subscription = await this.buildAuthenticatedSubscription(LIGHTER_WS_CHANNELS.ORDERS);
    const channelId = `${LIGHTER_WS_CHANNELS.ORDERS}:${this.getAuthIdentifier()}`;
    for await (const orders of this.wsManager.watch(channelId, subscription)) {
      yield orders.map((order) => this.normalizer.normalizeOrder(order));
    }
  }
  /**
   * Watch balance updates in real-time
   *
   * Requires authentication.
   */
  async *watchBalance() {
    if (!this._hasAuthentication) {
      throw new PerpDEXError("API credentials required for balance streaming", "AUTH_REQUIRED", "lighter");
    }
    const subscription = await this.buildAuthenticatedSubscription("balance");
    const channelId = `balance:${this.getAuthIdentifier()}`;
    for await (const balances of this.wsManager.watch(channelId, subscription)) {
      yield balances.map((balance) => this.normalizer.normalizeBalance(balance));
    }
  }
  /**
   * Watch user trades (fills) in real-time
   *
   * Requires authentication.
   *
   * @param symbol - Optional symbol to filter trades
   */
  async *watchMyTrades(symbol) {
    if (!this._hasAuthentication) {
      throw new PerpDEXError("API credentials required for trade streaming", "AUTH_REQUIRED", "lighter");
    }
    const subscription = await this.buildAuthenticatedSubscription(LIGHTER_WS_CHANNELS.FILLS);
    if (symbol) {
      const lighterSymbol = this.normalizer.toLighterSymbol(symbol);
      subscription.symbol = lighterSymbol;
    }
    const channelId = `${LIGHTER_WS_CHANNELS.FILLS}:${this.getAuthIdentifier()}`;
    for await (const trade of this.wsManager.watch(channelId, subscription)) {
      yield this.normalizer.normalizeTrade(trade);
    }
  }
  /**
   * Build authenticated subscription object for WebSocket
   */
  async buildAuthenticatedSubscription(channel) {
    const subscription = {
      type: "subscribe",
      channel
    };
    if (this._hasWasmSigning && this.signer) {
      try {
        const authToken = await this.signer.createAuthToken();
        subscription.authToken = authToken;
      } catch {
        subscription.apiKey = this.apiKey;
      }
    } else if (this.apiKey) {
      subscription.apiKey = this.apiKey;
    }
    return subscription;
  }
  /**
   * Get authentication identifier for channel naming
   */
  getAuthIdentifier() {
    if (this._hasWasmSigning) {
      return `account-${this.accountIndex}-${this.apiKeyIndex}`;
    }
    return this.apiKey || "anonymous";
  }
};

// src/adapters/lighter/utils.ts
function mapError2(error) {
  if (error instanceof PerpDEXError) {
    return error;
  }
  const errorMessage = error instanceof Error ? error.message : String(error);
  const errorLower = errorMessage.toLowerCase();
  const originalError = error instanceof Error ? error : void 0;
  if (errorLower.includes("rate limit") || errorLower.includes("too many requests")) {
    return new RateLimitError("Rate limit exceeded", "RATE_LIMIT_EXCEEDED", "lighter", void 0, originalError);
  }
  if (errorLower.includes("insufficient") && (errorLower.includes("margin") || errorLower.includes("balance"))) {
    return new InsufficientMarginError(
      "Insufficient margin for order",
      "INSUFFICIENT_MARGIN",
      "lighter",
      originalError
    );
  }
  if (errorLower.includes("invalid order") || errorLower.includes("order size") || errorLower.includes("price")) {
    return new InvalidOrderError("Invalid order parameters", "INVALID_ORDER", "lighter", originalError);
  }
  if (errorLower.includes("not found") && errorLower.includes("order")) {
    return new OrderNotFoundError("Order not found", "ORDER_NOT_FOUND", "lighter", originalError);
  }
  if (errorLower.includes("unauthorized") || errorLower.includes("authentication") || errorLower.includes("invalid signature")) {
    return new InvalidSignatureError("Authentication failed", "INVALID_SIGNATURE", "lighter", originalError);
  }
  if (errorLower.includes("unavailable") || errorLower.includes("maintenance") || errorLower.includes("offline")) {
    return new ExchangeUnavailableError(
      "Exchange temporarily unavailable",
      "EXCHANGE_UNAVAILABLE",
      "lighter",
      originalError
    );
  }
  return new PerpDEXError(errorMessage, "UNKNOWN_ERROR", "lighter", originalError);
}

// src/adapters/lighter/signer/LighterWasmSigner.ts
var WasmSignerClient = null;
async function loadWasmSigner() {
  if (WasmSignerClient) {
    return WasmSignerClient;
  }
  try {
    const module2 = await import("@oraichain/lighter-ts-sdk");
    WasmSignerClient = module2.WasmSignerClient;
    return WasmSignerClient;
  } catch (error) {
    throw new Error(
      "Failed to load @oraichain/lighter-ts-sdk. Please install it: npm install @oraichain/lighter-ts-sdk"
    );
  }
}
var LighterWasmSigner = class {
  wasmClient = null;
  config;
  initialized = false;
  apiPublicKey = "";
  constructor(config) {
    const privateKey = config.apiPrivateKey.startsWith("0x") ? config.apiPrivateKey.slice(2) : config.apiPrivateKey;
    this.config = {
      apiPrivateKey: privateKey,
      apiPublicKey: config.apiPublicKey || "",
      accountIndex: config.accountIndex ?? 0,
      apiKeyIndex: config.apiKeyIndex ?? 255,
      chainId: config.chainId,
      libraryPath: config.libraryPath || ""
      // Not used for WASM
    };
    this.apiPublicKey = this.config.apiPublicKey;
  }
  /**
   * Initialize the WASM signer
   * Must be called before any signing operations
   */
  async initialize() {
    if (this.initialized) {
      return;
    }
    try {
      const SignerClass = await loadWasmSigner();
      this.wasmClient = new SignerClass({});
      await this.wasmClient.initialize();
      await this.wasmClient.createClient({
        url: "",
        // Not needed for signing
        privateKey: this.config.apiPrivateKey,
        chainId: this.config.chainId,
        apiKeyIndex: this.config.apiKeyIndex,
        accountIndex: this.config.accountIndex
      });
      this.initialized = true;
    } catch (error) {
      const message = error instanceof Error ? error.message : String(error);
      throw new Error(`Failed to initialize WASM signer: ${message}`);
    }
  }
  /**
   * Ensure the signer is initialized
   */
  ensureInitialized() {
    if (!this.initialized || !this.wasmClient) {
      throw new Error("LighterWasmSigner not initialized. Call initialize() first.");
    }
  }
  /**
   * Sign a create order transaction
   */
  async signCreateOrder(params) {
    this.ensureInitialized();
    const response = await this.wasmClient.signCreateOrder({
      marketIndex: params.marketIndex,
      clientOrderIndex: Number(params.clientOrderIndex),
      baseAmount: Number(params.baseAmount),
      price: params.price,
      isAsk: params.isAsk ? 1 : 0,
      orderType: params.orderType,
      timeInForce: params.timeInForce,
      reduceOnly: params.reduceOnly ? 1 : 0,
      triggerPrice: params.triggerPrice || 0,
      orderExpiry: Number(params.orderExpiry || 0),
      nonce: Number(params.nonce),
      apiKeyIndex: this.config.apiKeyIndex,
      accountIndex: this.config.accountIndex
    });
    if (response.error) {
      throw new Error(`Signing failed: ${response.error}`);
    }
    return {
      txType: response.txType,
      txInfo: response.txInfo || "",
      txHash: response.txHash || ""
    };
  }
  /**
   * Sign a cancel order transaction
   */
  async signCancelOrder(params) {
    this.ensureInitialized();
    const response = await this.wasmClient.signCancelOrder({
      marketIndex: params.marketIndex,
      orderIndex: Number(params.orderId),
      nonce: Number(params.nonce),
      apiKeyIndex: this.config.apiKeyIndex,
      accountIndex: this.config.accountIndex
    });
    if (response.error) {
      throw new Error(`Signing failed: ${response.error}`);
    }
    return {
      txType: response.txType,
      txInfo: response.txInfo || "",
      txHash: response.txHash || ""
    };
  }
  /**
   * Sign a cancel all orders transaction
   */
  async signCancelAllOrders(params) {
    this.ensureInitialized();
    const response = await this.wasmClient.signCancelAllOrders({
      timeInForce: 0,
      time: 0,
      nonce: Number(params.nonce),
      apiKeyIndex: this.config.apiKeyIndex,
      accountIndex: this.config.accountIndex
    });
    if (response.error) {
      throw new Error(`Signing failed: ${response.error}`);
    }
    return {
      txType: response.txType,
      txInfo: response.txInfo || "",
      txHash: response.txHash || ""
    };
  }
  /**
   * Sign a withdraw collateral transaction
   */
  async signWithdrawCollateral(params) {
    this.ensureInitialized();
    const response = await this.wasmClient.signWithdraw({
      usdcAmount: Number(params.amount),
      nonce: Number(params.nonce),
      apiKeyIndex: this.config.apiKeyIndex,
      accountIndex: this.config.accountIndex
    });
    if (response.error) {
      throw new Error(`Signing failed: ${response.error}`);
    }
    return {
      txType: response.txType,
      txInfo: response.txInfo || "",
      txHash: response.txHash || ""
    };
  }
  /**
   * Create a signed authentication token
   *
   * @param expirySeconds - Token validity duration in seconds (default: 3600)
   * @returns Signed auth token string
   */
  async createAuthToken(expirySeconds = 3600) {
    this.ensureInitialized();
    const deadline = Math.floor(Date.now() / 1e3) + expirySeconds;
    const token = await this.wasmClient.createAuthToken(
      deadline,
      this.config.apiKeyIndex,
      this.config.accountIndex
    );
    if (!token || typeof token !== "string") {
      throw new Error("Failed to create auth token");
    }
    return token;
  }
  /**
   * Generate a new API key pair
   * @param seed - Optional seed for deterministic key generation
   */
  async generateApiKey(seed) {
    this.ensureInitialized();
    const keyPair = await this.wasmClient.generateAPIKey(seed);
    return {
      privateKey: keyPair.privateKey,
      publicKey: keyPair.publicKey
    };
  }
  /**
   * Get the API key index
   */
  get apiKeyIndex() {
    return this.config.apiKeyIndex;
  }
  /**
   * Get the account index
   */
  get accountIndex() {
    return this.config.accountIndex;
  }
  /**
   * Get the public key
   */
  get publicKey() {
    return this.apiPublicKey;
  }
  /**
   * Check if the signer is initialized
   */
  get isInitialized() {
    return this.initialized;
  }
  /**
   * Get chain ID
   */
  get chainId() {
    return this.config.chainId;
  }
};

// src/adapters/lighter/NonceManager.ts
var NonceManager = class _NonceManager {
  currentNonce = BigInt(-1);
  httpClient;
  apiKeyIndex;
  autoSync;
  syncPromise = null;
  lastSyncTime = 0;
  logger = new Logger("NonceManager");
  /** Minimum time between forced syncs (ms) */
  static MIN_SYNC_INTERVAL = 1e3;
  constructor(config) {
    this.httpClient = config.httpClient;
    this.apiKeyIndex = config.apiKeyIndex;
    this.autoSync = config.autoSync ?? true;
  }
  /**
   * Get the next nonce value for a transaction
   *
   * On first call, syncs with the server to get the current nonce.
   * Subsequent calls return incrementing local values.
   *
   * @returns Next nonce value
   */
  async getNextNonce() {
    if (this.currentNonce === BigInt(-1) && this.autoSync) {
      await this.sync();
    }
    if (this.currentNonce === BigInt(-1)) {
      throw new Error("Nonce not initialized. Call sync() first.");
    }
    const nonce = this.currentNonce;
    this.currentNonce++;
    return nonce;
  }
  /**
   * Peek at the current nonce without incrementing
   *
   * @returns Current nonce value
   */
  peekNonce() {
    return this.currentNonce;
  }
  /**
   * Synchronize nonce with the server
   *
   * Should be called:
   * - On initialization (automatic if autoSync is true)
   * - After transaction failures that may indicate nonce issues
   * - If local nonce gets too far ahead of server
   */
  async sync() {
    if (this.syncPromise) {
      return this.syncPromise;
    }
    const now = Date.now();
    if (now - this.lastSyncTime < _NonceManager.MIN_SYNC_INTERVAL) {
      return;
    }
    this.syncPromise = this.doSync();
    try {
      await this.syncPromise;
    } finally {
      this.syncPromise = null;
    }
  }
  /**
   * Perform the actual sync operation
   */
  async doSync() {
    try {
      const response = await this.httpClient.get(
        `/api/v1/nextNonce?api_key_index=${this.apiKeyIndex}`
      );
      if (response.code === 0 && response.nonce !== void 0) {
        const serverNonce = BigInt(response.nonce);
        this.currentNonce = serverNonce;
        this.lastSyncTime = Date.now();
      } else {
        throw new Error(`Invalid nonce response: ${JSON.stringify(response)}`);
      }
    } catch (error) {
      if (this.currentNonce !== BigInt(-1)) {
        this.logger.warn("Failed to sync nonce with server, using local value");
        return;
      }
      throw error;
    }
  }
  /**
   * Reset the nonce manager
   *
   * Forces re-sync on next getNextNonce() call.
   * Use after detected nonce errors or when account state changes.
   */
  reset() {
    this.currentNonce = BigInt(-1);
    this.lastSyncTime = 0;
    this.syncPromise = null;
  }
  /**
   * Set a specific nonce value
   *
   * Useful for recovery scenarios or manual override.
   * Use with caution - incorrect nonce will cause transaction failures.
   *
   * @param nonce - Nonce value to set
   */
  setNonce(nonce) {
    if (nonce < BigInt(0)) {
      throw new Error("Nonce cannot be negative");
    }
    this.currentNonce = nonce;
    this.lastSyncTime = Date.now();
  }
  /**
   * Rollback nonce by one
   *
   * Use when a transaction fails before submission
   * (not on server rejection, as the nonce was consumed).
   */
  rollback() {
    if (this.currentNonce > BigInt(0)) {
      this.currentNonce--;
    }
  }
  /**
   * Get time since last sync
   *
   * @returns Milliseconds since last successful sync
   */
  timeSinceSync() {
    if (this.lastSyncTime === 0) {
      return Infinity;
    }
    return Date.now() - this.lastSyncTime;
  }
  /**
   * Check if nonce is initialized
   */
  get isInitialized() {
    return this.currentNonce !== BigInt(-1);
  }
};

// src/adapters/lighter/LighterOrderUtils.ts
function toBaseUnits(amount, decimals) {
  const factor = 10 ** decimals;
  return BigInt(Math.round(amount * factor));
}
function toPriceUnits(price, tickSize) {
  return Math.round(price / tickSize);
}
function mapOrderType(type) {
  switch (type.toLowerCase()) {
    case "limit":
      return 0 /* LIMIT */;
    case "market":
      return 1 /* MARKET */;
    case "stop_limit":
    case "stop-limit":
    case "stoplimit":
      return 2 /* STOP_LIMIT */;
    case "stop_market":
    case "stop-market":
    case "stopmarket":
      return 3 /* STOP_MARKET */;
    default:
      return 0 /* LIMIT */;
  }
}
function mapTimeInForce(tif, postOnly) {
  if (postOnly) {
    return 3 /* POST_ONLY */;
  }
  switch (tif?.toUpperCase()) {
    case "IOC":
      return 1 /* IOC */;
    case "FOK":
      return 2 /* FOK */;
    case "PO":
    case "POST_ONLY":
    case "POSTONLY":
      return 3 /* POST_ONLY */;
    case "GTC":
    default:
      return 0 /* GTC */;
  }
}
function convertOrderRequest2(request, lighterSymbol) {
  const order = {
    symbol: lighterSymbol,
    side: request.side,
    type: request.type,
    quantity: request.amount
  };
  if (request.price !== void 0) {
    order.price = request.price;
  }
  if (request.clientOrderId) {
    order.clientOrderId = request.clientOrderId;
  }
  if (request.reduceOnly) {
    order.reduceOnly = true;
  }
  if (request.postOnly) {
    order.timeInForce = "PO";
  } else if (request.timeInForce) {
    order.timeInForce = request.timeInForce;
  }
  return order;
}

// src/adapters/lighter/LighterTrading.ts
async function createOrderWasm(deps, request) {
  const lighterSymbol = deps.normalizer.toLighterSymbol(request.symbol);
  let marketId = deps.marketIdCache.get(lighterSymbol);
  if (marketId === void 0) {
    await deps.fetchMarkets();
    marketId = deps.marketIdCache.get(lighterSymbol);
    if (marketId === void 0) {
      throw new InvalidOrderError(`Market not found: ${request.symbol}`, "INVALID_SYMBOL", "lighter");
    }
  }
  const metadata = deps.marketMetadataCache.get(lighterSymbol);
  if (!metadata) {
    throw new InvalidOrderError(`Market metadata not found: ${request.symbol}`, "INVALID_SYMBOL", "lighter");
  }
  const nonce = await deps.nonceManager.getNextNonce();
  try {
    const baseAmount = toBaseUnits(request.amount, metadata.baseDecimals);
    const price = toPriceUnits(request.price || 0, metadata.tickSize);
    const orderType = mapOrderType(request.type);
    const timeInForce = mapTimeInForce(request.timeInForce, request.postOnly);
    const signedTx = await deps.signer.signCreateOrder({
      marketIndex: marketId,
      clientOrderIndex: BigInt(request.clientOrderId || Date.now()),
      baseAmount,
      price,
      isAsk: request.side === "sell",
      orderType,
      timeInForce,
      reduceOnly: request.reduceOnly ?? false,
      triggerPrice: request.stopPrice ? toPriceUnits(request.stopPrice, metadata.tickSize) : 0,
      orderExpiry: BigInt(0),
      // No expiry
      nonce
    });
    const response = await deps.request("POST", "/api/v1/sendTx", {
      tx_type: signedTx.txType,
      tx_info: signedTx.txInfo
    });
    if (response.code !== 0) {
      await deps.handleTransactionError(response.code);
      throw new InvalidOrderError(`Order creation failed: code ${response.code}`, "ORDER_REJECTED", "lighter");
    }
    return deps.normalizer.normalizeOrder(response.order);
  } catch (error) {
    const errorMsg = error instanceof Error ? error.message : "";
    if (!errorMsg.includes("code")) {
      deps.nonceManager.rollback();
    }
    throw mapError2(error);
  }
}
async function createOrderHMAC(deps, request) {
  const lighterSymbol = deps.normalizer.toLighterSymbol(request.symbol);
  const orderRequest = convertOrderRequest2(request, lighterSymbol);
  const response = await deps.request("POST", "/orders", orderRequest);
  return deps.normalizer.normalizeOrder(response);
}
async function cancelOrderWasm(deps, orderId, symbol) {
  let marketIndex = 0;
  if (symbol) {
    const lighterSymbol = deps.normalizer.toLighterSymbol(symbol);
    const cached = deps.marketIdCache.get(lighterSymbol);
    if (cached === void 0) {
      await deps.fetchMarkets();
      marketIndex = deps.marketIdCache.get(lighterSymbol) ?? 0;
    } else {
      marketIndex = cached;
    }
  }
  const nonce = await deps.nonceManager.getNextNonce();
  try {
    const signedTx = await deps.signer.signCancelOrder({
      marketIndex,
      orderId: BigInt(orderId),
      nonce
    });
    const response = await deps.request("POST", "/api/v1/sendTx", {
      tx_type: signedTx.txType,
      tx_info: signedTx.txInfo
    });
    if (response.code !== 0) {
      await deps.handleTransactionError(response.code);
      throw new InvalidOrderError(`Cancel failed: code ${response.code}`, "CANCEL_REJECTED", "lighter");
    }
    return deps.normalizer.normalizeOrder(response.order);
  } catch (error) {
    const errorMsg = error instanceof Error ? error.message : "";
    if (!errorMsg.includes("code")) {
      deps.nonceManager.rollback();
    }
    throw mapError2(error);
  }
}
async function cancelOrderHMAC(deps, orderId) {
  const response = await deps.request("DELETE", `/orders/${orderId}`);
  return deps.normalizer.normalizeOrder(response);
}
async function cancelAllOrdersWasm(deps, symbol) {
  let marketIndex = -1;
  if (symbol) {
    const lighterSymbol = deps.normalizer.toLighterSymbol(symbol);
    const cached = deps.marketIdCache.get(lighterSymbol);
    if (cached !== void 0) {
      marketIndex = cached;
    } else {
      await deps.fetchMarkets();
      marketIndex = deps.marketIdCache.get(lighterSymbol) ?? -1;
    }
  }
  const nonce = await deps.nonceManager.getNextNonce();
  try {
    const signedTx = await deps.signer.signCancelAllOrders({
      marketIndex: marketIndex >= 0 ? marketIndex : void 0,
      nonce
    });
    const response = await deps.request("POST", "/api/v1/sendTx", {
      tx_type: signedTx.txType,
      tx_info: signedTx.txInfo
    });
    if (response.code !== 0) {
      await deps.handleTransactionError(response.code);
      throw new InvalidOrderError(`Cancel all failed: code ${response.code}`, "CANCEL_REJECTED", "lighter");
    }
    return (response.orders || []).map((order) => deps.normalizer.normalizeOrder(order));
  } catch (error) {
    const errorMsg = error instanceof Error ? error.message : "";
    if (!errorMsg.includes("code")) {
      deps.nonceManager.rollback();
    }
    throw mapError2(error);
  }
}
async function cancelAllOrdersHMAC(deps, symbol) {
  const path = symbol ? `/orders?symbol=${deps.normalizer.toLighterSymbol(symbol)}` : "/orders";
  const response = await deps.request("DELETE", path);
  if (!Array.isArray(response)) {
    return [];
  }
  return response.map((order) => deps.normalizer.normalizeOrder(order));
}
async function withdrawCollateral(deps, collateralIndex, amount, destinationAddress) {
  if (!deps.signer?.isInitialized || !deps.nonceManager) {
    throw new PerpDEXError(
      "Withdrawals require WASM signing. Configure apiPrivateKey and install @oraichain/lighter-ts-sdk.",
      "AUTH_REQUIRED",
      "lighter"
    );
  }
  if (!destinationAddress.match(/^0x[a-fA-F0-9]{40}$/)) {
    throw new InvalidOrderError(
      "Invalid destination address format",
      "INVALID_ADDRESS",
      "lighter"
    );
  }
  const nonce = await deps.nonceManager.getNextNonce();
  try {
    const signedTx = await deps.signer.signWithdrawCollateral({
      collateralIndex,
      amount,
      destinationAddress,
      nonce
    });
    const response = await deps.request("POST", "/api/v1/sendTx", {
      tx_type: signedTx.txType,
      tx_info: signedTx.txInfo
    });
    if (response.code !== 0) {
      await deps.handleTransactionError(response.code);
      throw new PerpDEXError(
        `Withdrawal failed: code ${response.code}`,
        "WITHDRAWAL_FAILED",
        "lighter"
      );
    }
    return response.tx_hash || signedTx.txHash;
  } catch (error) {
    deps.nonceManager.rollback();
    throw mapError2(error);
  }
}

// src/adapters/lighter/LighterMarketData.ts
async function fetchMarketsData(deps) {
  try {
    const response = await deps.request(
      "GET",
      "/api/v1/orderBookDetails"
    );
    if (!response.order_book_details || !Array.isArray(response.order_book_details)) {
      throw new PerpDEXError("Invalid markets response", "INVALID_RESPONSE", "lighter");
    }
    const perpMarkets = response.order_book_details.filter(
      (m) => m.market_type === "perp"
    );
    for (const market of perpMarkets) {
      if (market.symbol && market.market_id !== void 0) {
        deps.marketIdCache.set(market.symbol, market.market_id);
        deps.marketMetadataCache.set(market.symbol, {
          baseDecimals: market.base_decimals ?? 8,
          quoteDecimals: market.quote_decimals ?? 6,
          tickSize: parseFloat(market.tick_size ?? "0.01"),
          stepSize: parseFloat(market.step_size ?? "0.001")
        });
      }
    }
    return perpMarkets.map((market) => deps.normalizer.normalizeMarket(market));
  } catch (error) {
    throw mapError2(error);
  }
}
async function fetchTickerData(deps, symbol) {
  try {
    const lighterSymbol = deps.normalizer.toLighterSymbol(symbol);
    const response = await deps.request(
      "GET",
      "/api/v1/orderBookDetails"
    );
    if (!response.order_book_details) {
      throw new PerpDEXError("Invalid ticker response", "INVALID_RESPONSE", "lighter");
    }
    const market = response.order_book_details.find(
      (m) => m.symbol === lighterSymbol && m.market_type === "perp"
    );
    if (!market) {
      throw new PerpDEXError(`Market not found: ${symbol}`, "INVALID_SYMBOL", "lighter");
    }
    return deps.normalizer.normalizeTicker(market);
  } catch (error) {
    throw mapError2(error);
  }
}
async function fetchOrderBookData(deps, symbol, limit, fetchMarkets) {
  try {
    const lighterSymbol = deps.normalizer.toLighterSymbol(symbol);
    let marketId = deps.marketIdCache.get(lighterSymbol);
    if (marketId === void 0) {
      await fetchMarkets();
      marketId = deps.marketIdCache.get(lighterSymbol);
      if (marketId === void 0) {
        throw new PerpDEXError(`Market not found: ${symbol}`, "INVALID_SYMBOL", "lighter");
      }
    }
    const response = await deps.request(
      "GET",
      `/api/v1/orderBookOrders?market_id=${marketId}&limit=${limit}`
    );
    const orderBook = {
      symbol: lighterSymbol,
      bids: response.bids?.map((b) => [
        parseFloat(b.price || "0"),
        parseFloat(b.remaining_base_amount || b.size || "0")
      ]) || [],
      asks: response.asks?.map((a) => [
        parseFloat(a.price || "0"),
        parseFloat(a.remaining_base_amount || a.size || "0")
      ]) || [],
      timestamp: Date.now()
    };
    return deps.normalizer.normalizeOrderBook(orderBook);
  } catch (error) {
    throw mapError2(error);
  }
}
async function fetchTradesData(deps, symbol, limit) {
  try {
    const lighterSymbol = deps.normalizer.toLighterSymbol(symbol);
    const response = await deps.request(
      "GET",
      `/api/v1/trades?symbol=${lighterSymbol}&limit=${limit}`
    );
    const trades = response.trades || [];
    if (!Array.isArray(trades)) {
      throw new PerpDEXError("Invalid trades response", "INVALID_RESPONSE", "lighter");
    }
    return trades.map((trade) => {
      const normalizedTrade = {
        id: trade.id || trade.trade_id || String(Date.now()),
        symbol: lighterSymbol,
        side: (trade.side || "buy").toLowerCase(),
        price: parseFloat(trade.price || "0"),
        amount: parseFloat(trade.size || trade.amount || "0"),
        timestamp: trade.timestamp || trade.created_at || Date.now()
      };
      return deps.normalizer.normalizeTrade(normalizedTrade);
    });
  } catch (error) {
    throw mapError2(error);
  }
}
async function fetchFundingRateData(deps, symbol) {
  try {
    const lighterSymbol = deps.normalizer.toLighterSymbol(symbol);
    const response = await deps.request("GET", `/api/v1/funding-rates?symbol=${lighterSymbol}`);
    return deps.normalizer.normalizeFundingRate(response);
  } catch (error) {
    throw mapError2(error);
  }
}

// src/adapters/lighter/LighterAccount.ts
async function fetchPositionsData(deps, symbols) {
  try {
    const response = await deps.request("GET", "/api/v1/account");
    if (!Array.isArray(response)) {
      throw new PerpDEXError("Invalid positions response", "INVALID_RESPONSE", "lighter");
    }
    let positions = response.map((position) => deps.normalizer.normalizePosition(position));
    if (symbols && symbols.length > 0) {
      positions = positions.filter((p) => symbols.includes(p.symbol));
    }
    return positions;
  } catch (error) {
    throw mapError2(error);
  }
}
async function fetchBalanceData(deps) {
  try {
    const response = await deps.request("GET", "/api/v1/account");
    if (!Array.isArray(response)) {
      throw new PerpDEXError("Invalid balance response", "INVALID_RESPONSE", "lighter");
    }
    return response.map((balance) => deps.normalizer.normalizeBalance(balance));
  } catch (error) {
    throw mapError2(error);
  }
}
async function fetchOpenOrdersData(deps, symbol) {
  try {
    const path = symbol ? `/api/v1/accountActiveOrders?symbol=${deps.normalizer.toLighterSymbol(symbol)}` : "/api/v1/accountActiveOrders";
    const response = await deps.request("GET", path);
    if (!Array.isArray(response)) {
      throw new PerpDEXError("Invalid open orders response", "INVALID_RESPONSE", "lighter");
    }
    return response.map((order) => deps.normalizer.normalizeOrder(order));
  } catch (error) {
    throw mapError2(error);
  }
}
async function fetchOrderHistoryData(deps, symbol, since, limit) {
  try {
    const params = new URLSearchParams();
    if (symbol) params.append("symbol", deps.normalizer.toLighterSymbol(symbol));
    if (since) params.append("startTime", since.toString());
    if (limit) params.append("limit", limit.toString());
    const queryString = params.toString();
    const response = await deps.request(
      "GET",
      `/api/v1/accountInactiveOrders${queryString ? `?${queryString}` : ""}`
    );
    if (!Array.isArray(response)) {
      throw new PerpDEXError("Invalid order history response", "INVALID_RESPONSE", "lighter");
    }
    return response.map((order) => deps.normalizer.normalizeOrder(order));
  } catch (error) {
    throw mapError2(error);
  }
}
async function fetchMyTradesData(deps, symbol, since, limit) {
  try {
    const params = new URLSearchParams();
    if (symbol) params.append("symbol", deps.normalizer.toLighterSymbol(symbol));
    if (since) params.append("startTime", since.toString());
    if (limit) params.append("limit", limit.toString());
    const queryString = params.toString();
    const response = await deps.request(
      "GET",
      `/api/v1/accountFills${queryString ? `?${queryString}` : ""}`
    );
    if (!Array.isArray(response)) {
      throw new PerpDEXError("Invalid trade history response", "INVALID_RESPONSE", "lighter");
    }
    return response.map((trade) => deps.normalizer.normalizeTrade(trade));
  } catch (error) {
    throw mapError2(error);
  }
}

// src/adapters/lighter/LighterAdapter.ts
var LIGHTER_CHAIN_IDS = {
  mainnet: 304,
  testnet: 300
};
var LighterAdapter = class extends BaseAdapter {
  id = "lighter";
  name = "Lighter";
  has = {
    fetchMarkets: true,
    fetchTicker: true,
    fetchOrderBook: true,
    fetchTrades: true,
    fetchFundingRate: true,
    fetchFundingRateHistory: false,
    fetchPositions: true,
    fetchBalance: true,
    fetchOrderHistory: true,
    fetchMyTrades: true,
    createOrder: true,
    createBatchOrders: "emulated",
    cancelBatchOrders: "emulated",
    cancelOrder: true,
    cancelAllOrders: true,
    setLeverage: false,
    watchOrderBook: true,
    watchTrades: true,
    watchTicker: true,
    watchPositions: true,
    watchOrders: true,
    watchBalance: true,
    watchMyTrades: true
  };
  apiUrl;
  wsUrl;
  testnet;
  chainId;
  // HMAC auth (legacy)
  apiKey;
  apiSecret;
  // WASM auth (recommended - cross-platform signing)
  apiPrivateKey;
  signer = null;
  nonceManager = null;
  accountIndex;
  apiKeyIndex;
  rateLimiter;
  httpClient;
  normalizer;
  wsManager = null;
  wsHandler = null;
  // Cache for symbol -> market_id mapping (Lighter API requires market_id for orderbook)
  marketIdCache = /* @__PURE__ */ new Map();
  // Cache for symbol -> market metadata (for unit conversions)
  marketMetadataCache = /* @__PURE__ */ new Map();
  constructor(config = {}) {
    super(config);
    this.testnet = config.testnet ?? false;
    const urls = this.testnet ? LIGHTER_API_URLS.testnet : LIGHTER_API_URLS.mainnet;
    this.apiUrl = urls.rest;
    this.wsUrl = urls.websocket;
    this.chainId = config.chainId ?? (this.testnet ? LIGHTER_CHAIN_IDS.testnet : LIGHTER_CHAIN_IDS.mainnet);
    this.apiKey = config.apiKey;
    this.apiSecret = config.apiSecret;
    this.apiPrivateKey = config.apiPrivateKey;
    this.accountIndex = config.accountIndex ?? 0;
    this.apiKeyIndex = config.apiKeyIndex ?? 255;
    this.normalizer = new LighterNormalizer();
    const tier = config.rateLimitTier ?? "tier1";
    const limits = LIGHTER_RATE_LIMITS[tier];
    this.rateLimiter = new RateLimiter({
      maxTokens: limits.maxRequests,
      refillRate: limits.maxRequests / (limits.windowMs / 1e3),
      windowMs: limits.windowMs,
      weights: LIGHTER_ENDPOINT_WEIGHTS
    });
    this.httpClient = new HTTPClient({
      baseUrl: this.apiUrl,
      timeout: config.timeout || 3e4,
      retry: {
        maxAttempts: 3,
        initialDelay: 1e3,
        maxDelay: 1e4,
        multiplier: 2,
        retryableStatuses: [408, 429, 500, 502, 503, 504]
      },
      circuitBreaker: {
        enabled: true,
        failureThreshold: 5,
        successThreshold: 2,
        resetTimeout: 6e4
      },
      exchange: this.id
    });
    if (this.apiPrivateKey) {
      this.signer = new LighterWasmSigner({
        apiPrivateKey: this.apiPrivateKey,
        apiPublicKey: config.apiPublicKey,
        accountIndex: this.accountIndex,
        apiKeyIndex: this.apiKeyIndex,
        chainId: this.chainId
      });
      this.nonceManager = new NonceManager({
        httpClient: this.httpClient,
        apiKeyIndex: this.apiKeyIndex
      });
    }
  }
  /**
   * Check if WASM signing is available and initialized
   * Alias for hasWasmSigning for backward compatibility
   */
  get hasFFISigning() {
    return this.hasWasmSigning;
  }
  /**
   * Check if WASM signing is available and initialized
   */
  get hasWasmSigning() {
    return this.signer !== null && this.signer.isInitialized;
  }
  /**
   * Check if any authentication is configured
   */
  get hasAuthentication() {
    return !!(this.apiPrivateKey || this.apiKey && this.apiSecret);
  }
  async initialize() {
    if (this.signer) {
      try {
        await this.signer.initialize();
      } catch (error) {
        this.logger.warn("WASM signer initialization failed, falling back to HMAC mode", { error: error instanceof Error ? error.message : String(error) });
        this.signer = null;
        this.nonceManager = null;
      }
    }
    try {
      this.wsManager = new WebSocketManager({
        url: this.wsUrl,
        reconnect: {
          enabled: true,
          initialDelay: LIGHTER_WS_CONFIG.reconnectDelay,
          maxDelay: LIGHTER_WS_CONFIG.maxReconnectDelay,
          maxAttempts: LIGHTER_WS_CONFIG.reconnectAttempts,
          multiplier: 2,
          jitter: 0.1
        },
        heartbeat: {
          enabled: true,
          interval: LIGHTER_WS_CONFIG.pingInterval,
          timeout: LIGHTER_WS_CONFIG.pongTimeout
        }
      });
      await this.wsManager.connect();
      this.wsHandler = new LighterWebSocket({
        wsManager: this.wsManager,
        normalizer: this.normalizer,
        signer: this.signer,
        apiKey: this.apiKey,
        accountIndex: this.accountIndex,
        apiKeyIndex: this.apiKeyIndex,
        hasAuthentication: this.hasAuthentication,
        hasWasmSigning: this.hasWasmSigning
      });
    } catch (error) {
      this.wsManager = null;
      this.wsHandler = null;
    }
    this._isReady = true;
  }
  async disconnect() {
    if (this.wsManager) {
      await this.wsManager.disconnect();
      this.wsManager = null;
      this.wsHandler = null;
    }
    this.rateLimiter.destroy();
    this.signer = null;
    this.nonceManager = null;
    this._isReady = false;
  }
  // ==================== Market Data Methods ====================
  /** Get market data dependencies for helper functions */
  getMarketDataDeps() {
    return {
      normalizer: this.normalizer,
      marketIdCache: this.marketIdCache,
      marketMetadataCache: this.marketMetadataCache,
      request: (method, path, body) => this.request(method, path, body)
    };
  }
  async fetchMarkets(_params) {
    await this.rateLimiter.acquire("fetchMarkets");
    return fetchMarketsData(this.getMarketDataDeps());
  }
  async fetchTicker(symbol) {
    await this.rateLimiter.acquire("fetchTicker");
    return fetchTickerData(this.getMarketDataDeps(), symbol);
  }
  async fetchOrderBook(symbol, params) {
    await this.rateLimiter.acquire("fetchOrderBook");
    return fetchOrderBookData(this.getMarketDataDeps(), symbol, params?.limit || 50, () => this.fetchMarkets());
  }
  async fetchTrades(symbol, params) {
    await this.rateLimiter.acquire("fetchTrades");
    return fetchTradesData(this.getMarketDataDeps(), symbol, params?.limit || 100);
  }
  async fetchFundingRate(symbol) {
    await this.rateLimiter.acquire("fetchFundingRate");
    return fetchFundingRateData(this.getMarketDataDeps(), symbol);
  }
  async fetchFundingRateHistory(_symbol, _since, _limit) {
    throw new Error("Lighter does not support funding rate history");
  }
  // ==================== Trading Methods ====================
  /** Get trading dependencies for helper functions */
  getTradingDeps() {
    return {
      normalizer: this.normalizer,
      signer: this.signer,
      nonceManager: this.nonceManager,
      apiKey: this.apiKey,
      apiSecret: this.apiSecret,
      marketIdCache: this.marketIdCache,
      marketMetadataCache: this.marketMetadataCache,
      fetchMarkets: () => this.fetchMarkets(),
      request: (method, path, body) => this.request(method, path, body),
      handleTransactionError: (code) => this.handleTransactionError(code)
    };
  }
  async createOrder(request) {
    const validatedRequest = this.validateOrder(request);
    await this.rateLimiter.acquire("createOrder");
    const deps = this.getTradingDeps();
    if (this.signer && this.nonceManager) {
      return createOrderWasm(deps, validatedRequest);
    }
    if (this.apiKey && this.apiSecret) {
      return createOrderHMAC(deps, validatedRequest);
    }
    throw new InvalidOrderError(
      "API credentials required for trading. Provide apiPrivateKey (recommended) or apiKey + apiSecret.",
      "AUTH_REQUIRED",
      "lighter"
    );
  }
  async cancelOrder(orderId, symbol) {
    await this.rateLimiter.acquire("cancelOrder");
    const deps = this.getTradingDeps();
    if (this.signer && this.nonceManager) {
      return cancelOrderWasm(deps, orderId, symbol);
    }
    if (this.apiKey && this.apiSecret) {
      return cancelOrderHMAC(deps, orderId);
    }
    throw new InvalidOrderError(
      "API credentials required for trading",
      "AUTH_REQUIRED",
      "lighter"
    );
  }
  async cancelAllOrders(symbol) {
    await this.rateLimiter.acquire("cancelAllOrders");
    const deps = this.getTradingDeps();
    if (this.signer && this.nonceManager) {
      return cancelAllOrdersWasm(deps, symbol);
    }
    if (this.apiKey && this.apiSecret) {
      return cancelAllOrdersHMAC(deps, symbol);
    }
    throw new InvalidOrderError(
      "API credentials required for trading",
      "AUTH_REQUIRED",
      "lighter"
    );
  }
  // ==================== Collateral Management ====================
  /**
   * Withdraw collateral from trading account
   *
   * Requires WASM signing - HMAC mode does not support withdrawals.
   *
   * @param collateralIndex - Collateral type index (0 = USDC)
   * @param amount - Amount to withdraw in base units
   * @param destinationAddress - Ethereum address to withdraw to
   * @returns Transaction hash
   */
  async withdrawCollateral(collateralIndex, amount, destinationAddress) {
    return withdrawCollateral(this.getTradingDeps(), collateralIndex, amount, destinationAddress);
  }
  /**
   * Handle transaction errors and auto-resync nonce if needed
   */
  async handleTransactionError(code) {
    const nonceErrorCodes = [
      1001,
      // Nonce too low
      1002,
      // Nonce too high
      1003
      // Invalid nonce
    ];
    if (nonceErrorCodes.includes(code)) {
      this.logger.warn(`Nonce error detected (code ${code}), resyncing...`);
      await this.resyncNonce();
    }
  }
  /** Get account dependencies for helper functions */
  getAccountDeps() {
    return {
      normalizer: this.normalizer,
      request: (method, path, body) => this.request(method, path, body)
    };
  }
  ensureAuthenticated() {
    if (!this.hasAuthentication) {
      throw new PerpDEXError("API credentials required", "AUTH_REQUIRED", "lighter");
    }
  }
  async fetchPositions(symbols) {
    await this.rateLimiter.acquire("fetchPositions");
    this.ensureAuthenticated();
    return fetchPositionsData(this.getAccountDeps(), symbols);
  }
  async fetchBalance() {
    await this.rateLimiter.acquire("fetchBalance");
    this.ensureAuthenticated();
    return fetchBalanceData(this.getAccountDeps());
  }
  async fetchOpenOrders(symbol) {
    await this.rateLimiter.acquire("fetchOpenOrders");
    this.ensureAuthenticated();
    return fetchOpenOrdersData(this.getAccountDeps(), symbol);
  }
  // ==================== Required BaseAdapter Methods ====================
  async setLeverage(_symbol, _leverage) {
    throw new Error("Lighter does not support setLeverage");
  }
  async fetchOrderHistory(symbol, since, limit) {
    await this.rateLimiter.acquire("fetchOrderHistory");
    this.ensureAuthenticated();
    return fetchOrderHistoryData(this.getAccountDeps(), symbol, since, limit);
  }
  async fetchMyTrades(symbol, since, limit) {
    await this.rateLimiter.acquire("fetchMyTrades");
    this.ensureAuthenticated();
    return fetchMyTradesData(this.getAccountDeps(), symbol, since, limit);
  }
  symbolToExchange(symbol) {
    return this.normalizer.toLighterSymbol(symbol);
  }
  symbolFromExchange(exchangeSymbol) {
    return this.normalizer.normalizeSymbol(exchangeSymbol);
  }
  /**
   * Make HTTP request to Lighter API using HTTPClient
   */
  async request(method, path, body) {
    const headers = {};
    if (this.signer && this.signer.isInitialized) {
      try {
        const authToken = await this.signer.createAuthToken();
        headers["Authorization"] = `Bearer ${authToken}`;
      } catch {
        if (this.apiKey && this.apiSecret) {
          await this.addHMACHeaders(headers, method, path, body);
        }
      }
    } else if (this.apiKey && this.apiSecret) {
      await this.addHMACHeaders(headers, method, path, body);
    }
    try {
      switch (method) {
        case "GET":
          return await this.httpClient.get(path, { headers });
        case "POST":
          return await this.httpClient.post(path, { headers, body });
        case "DELETE":
          return await this.httpClient.delete(path, { headers, body });
        default:
          throw new Error(`Unsupported HTTP method: ${method}`);
      }
    } catch (error) {
      throw mapError2(error);
    }
  }
  /**
   * Add HMAC authentication headers
   * Note: This is now async to support browser Web Crypto API
   */
  async addHMACHeaders(headers, method, path, body) {
    const timestamp = Date.now().toString();
    const signature = await this.generateSignature(method, path, timestamp, body);
    headers["X-API-KEY"] = this.apiKey;
    headers["X-TIMESTAMP"] = timestamp;
    headers["X-SIGNATURE"] = signature;
  }
  // ==================== WebSocket Streaming Methods (delegated to LighterWebSocket) ====================
  async *watchOrderBook(symbol, limit) {
    if (!this.wsHandler) {
      throw new PerpDEXError("WebSocket not initialized", "NO_WEBSOCKET", this.id);
    }
    yield* this.wsHandler.watchOrderBook(symbol, limit);
  }
  async *watchTrades(symbol) {
    if (!this.wsHandler) {
      throw new PerpDEXError("WebSocket not initialized", "NO_WEBSOCKET", this.id);
    }
    yield* this.wsHandler.watchTrades(symbol);
  }
  async *watchPositions() {
    if (!this.wsHandler) {
      throw new PerpDEXError("WebSocket not initialized", "NO_WEBSOCKET", this.id);
    }
    yield* this.wsHandler.watchPositions();
  }
  async *watchOrders() {
    if (!this.wsHandler) {
      throw new PerpDEXError("WebSocket not initialized", "NO_WEBSOCKET", this.id);
    }
    yield* this.wsHandler.watchOrders();
  }
  async *watchTicker(symbol) {
    if (!this.wsHandler) {
      throw new PerpDEXError("WebSocket not initialized", "NO_WEBSOCKET", this.id);
    }
    yield* this.wsHandler.watchTicker(symbol);
  }
  async *watchBalance() {
    if (!this.wsHandler) {
      throw new PerpDEXError("WebSocket not initialized", "NO_WEBSOCKET", this.id);
    }
    yield* this.wsHandler.watchBalance();
  }
  /**
   * Watch user trades (fills) in real-time
   *
   * @param symbol - Optional symbol filter
   * @returns AsyncGenerator yielding Trade updates
   */
  async *watchMyTrades(symbol) {
    if (!this.wsHandler) {
      throw new PerpDEXError("WebSocket not initialized", "NO_WEBSOCKET", this.id);
    }
    yield* this.wsHandler.watchMyTrades(symbol);
  }
  // ==================== Private Helper Methods ====================
  /**
   * Generate HMAC signature for authenticated requests
   * Note: This is now async to support browser Web Crypto API
   */
  async generateSignature(method, path, timestamp, body) {
    const message = `${timestamp}${method}${path}${body ? JSON.stringify(body) : ""}`;
    return createHmacSha256(this.apiSecret, message);
  }
  /**
   * Resync nonce with server (useful after errors)
   */
  async resyncNonce() {
    if (this.nonceManager) {
      await this.nonceManager.sync();
    }
  }
  // ==================== Health Check Methods ====================
  /**
   * Ping the server to check connectivity
   *
   * @returns Response time in milliseconds
   */
  async ping() {
    const startTime = Date.now();
    try {
      await this.request("GET", "/api/v1/orderBookDetails");
      return Date.now() - startTime;
    } catch (error) {
      throw mapError2(error);
    }
  }
  /**
   * Get adapter status including connection health
   */
  async getStatus() {
    let latencyMs;
    try {
      latencyMs = await this.ping();
    } catch {
    }
    const rateLimiterStats = this.rateLimiter.getStats();
    return {
      ready: this._isReady,
      authenticated: this.hasAuthentication,
      authMode: this.hasWasmSigning ? "wasm" : this.apiKey && this.apiSecret ? "hmac" : "none",
      wsConnected: this.wsManager !== null,
      network: this.testnet ? "testnet" : "mainnet",
      latencyMs,
      rateLimiter: {
        availableTokens: rateLimiterStats.availableTokens,
        queueLength: rateLimiterStats.queueLength
      }
    };
  }
  /**
   * Check if the adapter is healthy and ready for trading
   */
  async isHealthy() {
    if (!this._isReady) return false;
    try {
      const latency = await this.ping();
      return latency < 5e3;
    } catch {
      return false;
    }
  }
};

// src/adapters/grvt/GRVTSDKWrapper.ts
var import_client = require("@grvt/client");
var GRVTSDKWrapper = class {
  mdg;
  tdg;
  sessionCookie;
  constructor(config) {
    const sdkConfig = {
      host: config.host
    };
    this.mdg = new import_client.MDG(sdkConfig);
    this.tdg = new import_client.TDG(sdkConfig);
  }
  /**
   * Get axios instance from MDG for direct access if needed
   */
  get mdgAxios() {
    return this.mdg.axios;
  }
  /**
   * Get axios instance from TDG for direct access if needed
   */
  get tdgAxios() {
    return this.tdg.axios;
  }
  // ==================== Market Data Methods ====================
  /**
   * Get single instrument details
   */
  async getInstrument(instrumentId, config) {
    return this.mdg.instrument({ instrument: instrumentId }, config);
  }
  /**
   * Get filtered instruments
   */
  async getInstruments(params, config) {
    return this.mdg.instruments(params || {}, config);
  }
  /**
   * Get all instruments
   */
  async getAllInstruments(config) {
    return this.mdg.allInstruments({}, config);
  }
  /**
   * Get mini ticker (lightweight)
   */
  async getMiniTicker(instrumentId, config) {
    return this.mdg.miniTicker({ instrument: instrumentId }, config);
  }
  /**
   * Get full ticker
   */
  async getTicker(instrumentId, config) {
    return this.mdg.ticker({ instrument: instrumentId }, config);
  }
  /**
   * Get order book
   */
  async getOrderBook(instrumentId, depth, config) {
    return this.mdg.orderBook({ instrument: instrumentId, depth }, config);
  }
  /**
   * Get latest trade for instrument
   */
  async getTrade(instrumentId, config) {
    return this.mdg.trade({ instrument: instrumentId }, config);
  }
  /**
   * Get trade history
   */
  async getTradeHistory(params, config) {
    return this.mdg.tradesHistory(params || {}, config);
  }
  /**
   * Get settlement price
   */
  async getSettlement(params, config) {
    return this.mdg.settlement(params || {}, config);
  }
  /**
   * Get funding rate
   */
  async getFunding(instrumentId, config) {
    return this.mdg.funding({ instrument: instrumentId }, config);
  }
  /**
   * Get candlestick data
   */
  async getCandlestick(params, config) {
    return this.mdg.candlestick(params, config);
  }
  /**
   * Get margin rules
   */
  async getMarginRules(config) {
    return this.mdg.marginRules({}, config);
  }
  // ==================== Trading Methods ====================
  /**
   * Create new order
   */
  async createOrder(order, config) {
    const response = await this.tdg.createOrder(order, config);
    this.extractSessionCookieFromResponse(response);
    return response;
  }
  /**
   * Create bulk orders
   */
  async createBulkOrders(orders, config) {
    const response = await this.tdg.createBulkOrders(orders, config);
    this.extractSessionCookieFromResponse(response);
    return response;
  }
  /**
   * Cancel single order
   */
  async cancelOrder(params, config) {
    const response = await this.tdg.cancelOrder(params, config);
    this.extractSessionCookieFromResponse(response);
    return response;
  }
  /**
   * Cancel all orders
   */
  async cancelAllOrders(params, config) {
    const response = await this.tdg.cancelAllOrders(params || {}, config);
    this.extractSessionCookieFromResponse(response);
    return response;
  }
  /**
   * Get single order
   */
  async getOrder(params, config) {
    return this.tdg.order(params, config);
  }
  /**
   * Get open orders
   */
  async getOpenOrders(params, config) {
    return this.tdg.openOrders(params || {}, config);
  }
  /**
   * Get order history (CRITICAL: fixes unimplemented method)
   */
  async getOrderHistory(params, config) {
    return this.tdg.orderHistory(params || {}, config);
  }
  /**
   * Get order group
   */
  async getOrderGroup(params, config) {
    return this.tdg.orderGroup(params, config);
  }
  /**
   * Replace orders (TP/SL)
   */
  async replaceOrders(params, config) {
    const response = await this.tdg.replaceOrders(params, config);
    this.extractSessionCookieFromResponse(response);
    return response;
  }
  /**
   * Pre-order check
   */
  async preOrderCheck(order, config) {
    return this.tdg.preOrderCheck(order, config);
  }
  /**
   * Get price protection bands
   */
  async getPriceProtectionBands(config) {
    return this.tdg.getPriceProtectionBands(config);
  }
  // ==================== Account Methods ====================
  /**
   * Get positions
   */
  async getPositions(params, config) {
    return this.tdg.positions(params || {}, config);
  }
  /**
   * Get sub-account summary (balance)
   */
  async getSubAccountSummary(params, config) {
    return this.tdg.subAccountSummary(params || {}, config);
  }
  /**
   * Get sub-account history
   */
  async getSubAccountHistory(params, config) {
    return this.tdg.subAccountHistory(params || {}, config);
  }
  /**
   * Get fill history (my trades) (CRITICAL: fixes unimplemented method)
   */
  async getFillHistory(params, config) {
    return this.tdg.fillHistory(params || {}, config);
  }
  /**
   * Get aggregated account summary
   */
  async getAggregatedAccountSummary(config) {
    return this.tdg.aggregatedAccountSummary(config);
  }
  /**
   * Get funding account summary
   */
  async getFundingAccountSummary(config) {
    return this.tdg.fundingAccountSummary(config);
  }
  /**
   * Get funding payment history
   */
  async getFundingPaymentHistory(params, config) {
    return this.tdg.fundingPaymentHistory(params || {}, config);
  }
  // ==================== Transfer Methods ====================
  /**
   * Pre-deposit check
   */
  async preDepositCheck(params, config) {
    return this.tdg.preDepositCheck(params, config);
  }
  /**
   * Get deposit history
   */
  async getDepositHistory(params, config) {
    return this.tdg.depositHistory(params || {}, config);
  }
  /**
   * Transfer funds
   */
  async transfer(params, config) {
    const response = await this.tdg.transfer(params, config);
    this.extractSessionCookieFromResponse(response);
    return response;
  }
  /**
   * Get transfer history
   */
  async getTransferHistory(params, config) {
    return this.tdg.transferHistory(params || {}, config);
  }
  /**
   * Request withdrawal
   */
  async withdrawal(params, config) {
    const response = await this.tdg.withdrawal(params, config);
    this.extractSessionCookieFromResponse(response);
    return response;
  }
  /**
   * Get withdrawal history
   */
  async getWithdrawalHistory(params, config) {
    return this.tdg.withdrawalHistory(params || {}, config);
  }
  // ==================== Leverage Methods ====================
  /**
   * Get all initial leverage
   */
  async getAllInitialLeverage(params, config) {
    return this.tdg.getAllInitialLeverage(params || {}, config);
  }
  /**
   * Set initial leverage
   */
  async setInitialLeverage(params, config) {
    const response = await this.tdg.setInitialLeverage(params, config);
    this.extractSessionCookieFromResponse(response);
    return response;
  }
  /**
   * Get margin tiers
   */
  async getMarginTiers(config) {
    return this.tdg.getMarginTiers(config);
  }
  // ==================== Session Management ====================
  /**
   * Extract session cookie from axios response
   */
  extractSessionCookieFromResponse(response) {
    if (!response) return;
    const headers = response.headers || response.config?.headers;
    if (!headers) return;
    const setCookie = headers["set-cookie"] || headers["Set-Cookie"];
    if (!setCookie) return;
    const cookies = Array.isArray(setCookie) ? setCookie : [setCookie];
    const sessionCookie = cookies.find(
      (cookie) => cookie.toLowerCase().includes("session")
    );
    if (sessionCookie) {
      const cookieValue = sessionCookie.split(";")[0];
      this.sessionCookie = cookieValue;
    }
  }
  /**
   * Get current session cookie
   */
  getSessionCookie() {
    return this.sessionCookie;
  }
  /**
   * Set session cookie manually
   */
  setSessionCookie(cookie) {
    this.sessionCookie = cookie;
  }
  /**
   * Check if we have a valid session
   */
  hasSession() {
    return !!this.sessionCookie;
  }
  /**
   * Clear session cookie
   */
  clearSession() {
    this.sessionCookie = void 0;
  }
};

// src/adapters/grvt/constants.ts
var GRVT_API_URLS = {
  mainnet: {
    rest: "https://market-data.grvt.io",
    trading: "https://edge.grvt.io",
    websocket: "wss://market-data.grvt.io/ws"
  },
  testnet: {
    rest: "https://market-data.testnet.grvt.io",
    trading: "https://edge.testnet.grvt.io",
    websocket: "wss://market-data.testnet.grvt.io/ws"
  }
};
var GRVT_RATE_LIMITS = {
  rest: {
    maxRequests: 100,
    windowMs: 1e4
    // 10 seconds
  },
  websocket: {
    maxSubscriptions: 50
  }
};
var GRVT_ENDPOINT_WEIGHTS = {
  fetchMarkets: 1,
  fetchTicker: 1,
  fetchOrderBook: 2,
  fetchTrades: 2,
  fetchFundingRate: 1,
  fetchPositions: 2,
  fetchBalance: 2,
  fetchOpenOrders: 2,
  fetchClosedOrders: 3,
  createOrder: 5,
  cancelOrder: 3,
  createBatchOrders: 10,
  cancelAllOrders: 10,
  modifyOrder: 5,
  fetchOrder: 2,
  fetchMyTrades: 3,
  fetchDeposits: 2,
  fetchWithdrawals: 2,
  transfer: 5
};
var GRVT_EIP712_DOMAIN = {
  name: "GRVT",
  version: "1",
  chainId: 1,
  // Mainnet
  verifyingContract: "0x0000000000000000000000000000000000000000"
  // Placeholder
};
var GRVT_EIP712_ORDER_TYPE = {
  Order: [
    { name: "instrument", type: "string" },
    { name: "orderType", type: "string" },
    { name: "side", type: "string" },
    { name: "size", type: "string" },
    { name: "price", type: "string" },
    { name: "timeInForce", type: "string" },
    { name: "reduceOnly", type: "bool" },
    { name: "postOnly", type: "bool" },
    { name: "nonce", type: "uint256" },
    { name: "expiry", type: "uint256" }
  ]
};
var GRVT_PRECISION = {
  amount: 8,
  price: 8
};
var GRVT_SESSION_DURATION = 36e5;

// src/adapters/grvt/GRVTAuth.ts
var GRVTAuth = class {
  apiKey;
  wallet;
  testnet;
  sessionCookie;
  nonce = 0;
  constructor(config) {
    this.apiKey = config.apiKey;
    this.wallet = config.wallet;
    this.testnet = config.testnet ?? false;
  }
  /**
   * Check if authentication credentials are available
   */
  hasCredentials() {
    return !!(this.apiKey || this.wallet);
  }
  /**
   * Require authentication for private methods
   * @throws {Error} if no credentials are configured
   */
  requireAuth() {
    if (!this.hasCredentials()) {
      throw new Error("Authentication required. Provide apiKey or wallet in config.");
    }
  }
  /**
   * Sign a request with authentication headers
   */
  async sign(request) {
    const headers = {
      "Content-Type": "application/json"
    };
    if (this.apiKey) {
      headers["X-API-KEY"] = this.apiKey;
    }
    if (this.sessionCookie && this.isSessionValid()) {
      headers["Cookie"] = `session=${this.sessionCookie.token}`;
    }
    if (this.requiresSignature(request.method, request.path)) {
      const signature = await this.signRequest(request);
      headers["X-Signature"] = signature;
      headers["X-Timestamp"] = Date.now().toString();
      if (this.wallet) {
        headers["X-Address"] = this.wallet.address;
      }
    }
    return {
      ...request,
      headers
    };
  }
  /**
   * Get authentication headers
   */
  getHeaders() {
    const headers = {
      "Content-Type": "application/json"
    };
    if (this.apiKey) {
      headers["X-API-KEY"] = this.apiKey;
    }
    if (this.sessionCookie && this.isSessionValid()) {
      headers["Cookie"] = `session=${this.sessionCookie.token}`;
    }
    return headers;
  }
  /**
   * Verify authentication credentials
   */
  async verify() {
    try {
      if (this.apiKey && this.apiKey.length > 0) {
        return true;
      }
      if (this.wallet) {
        const address = await this.wallet.getAddress();
        return address.length > 0;
      }
      return false;
    } catch {
      return false;
    }
  }
  /**
   * Get current session cookie
   */
  getSessionCookie() {
    if (this.sessionCookie && this.isSessionValid()) {
      return this.sessionCookie.token;
    }
    return void 0;
  }
  /**
   * Set session cookie from authentication response
   */
  setSessionCookie(token, expiresIn) {
    const duration = expiresIn ?? GRVT_SESSION_DURATION;
    this.sessionCookie = {
      token,
      expiresAt: Date.now() + duration
    };
  }
  /**
   * Clear session cookie
   */
  clearSessionCookie() {
    this.sessionCookie = void 0;
  }
  /**
   * Check if current session is valid
   */
  isSessionValid() {
    if (!this.sessionCookie) {
      return false;
    }
    return Date.now() < this.sessionCookie.expiresAt - 6e4;
  }
  /**
   * Check if request requires signature
   */
  requiresSignature(_method, path) {
    const tradingPaths = [
      "/orders",
      "/orders/batch",
      "/orders/cancel",
      "/positions",
      "/transfer",
      "/withdraw"
    ];
    return tradingPaths.some((tradingPath) => path.includes(tradingPath));
  }
  /**
   * Sign request data with wallet
   */
  async signRequest(request) {
    if (!this.wallet) {
      throw new Error("Wallet required for signing requests");
    }
    const timestamp = Date.now();
    const message = this.createSignatureMessage(request, timestamp);
    const signature = await this.wallet.signMessage(message);
    return signature;
  }
  /**
   * Create message for signing
   */
  createSignatureMessage(request, timestamp) {
    const method = request.method.toUpperCase();
    const path = request.path;
    const body = request.body ? JSON.stringify(request.body) : "";
    return `${method}${path}${timestamp}${body}`;
  }
  /**
   * Sign order using EIP-712
   */
  async signOrder(payload) {
    if (!this.wallet) {
      throw new Error("Wallet required for signing orders");
    }
    const domain = {
      ...GRVT_EIP712_DOMAIN,
      chainId: this.testnet ? 5 : 1
      // Goerli for testnet, mainnet otherwise
    };
    const types = GRVT_EIP712_ORDER_TYPE;
    const value = {
      instrument: payload.instrument,
      orderType: payload.order_type,
      side: payload.side,
      size: payload.size,
      price: payload.price,
      timeInForce: payload.time_in_force,
      reduceOnly: payload.reduce_only,
      postOnly: payload.post_only,
      nonce: payload.nonce,
      expiry: payload.expiry
    };
    const signature = await this.wallet.signTypedData(domain, types, value);
    return signature;
  }
  /**
   * Get next nonce for order signing
   */
  getNextNonce() {
    return ++this.nonce;
  }
  /**
   * Reset nonce (useful after session refresh)
   */
  resetNonce() {
    this.nonce = 0;
  }
  /**
   * Get wallet address
   */
  getAddress() {
    return this.wallet?.address;
  }
  /**
   * Convert ethers signature to GRVT ISignature format
   */
  parseSignature(signature) {
    const sig = signature.startsWith("0x") ? signature.slice(2) : signature;
    if (sig.length !== 130) {
      throw new Error(`Invalid signature length: ${sig.length}, expected 130`);
    }
    const r = "0x" + sig.slice(0, 64);
    const s = "0x" + sig.slice(64, 128);
    const v = parseInt(sig.slice(128, 130), 16);
    return { r, s, v };
  }
  /**
   * Create ISignature object for API requests
   */
  async createSignature(payload) {
    if (!this.wallet) {
      throw new Error("Wallet required for creating signatures");
    }
    const signature = await this.signOrder(payload);
    const { r, s, v } = this.parseSignature(signature);
    return {
      signer: this.wallet.address,
      r,
      s,
      v,
      expiration: payload.expiry.toString(),
      nonce: payload.nonce
    };
  }
};

// src/adapters/grvt/GRVTNormalizer.ts
var GRVTNormalizer = class {
  // ===========================================================================
  // Symbol Conversion
  // ===========================================================================
  /**
   * Convert GRVT symbol to CCXT format
   *
   * @param grvtSymbol - GRVT symbol (e.g., "BTC-PERP", "ETH-PERP")
   * @returns CCXT formatted symbol (e.g., "BTC/USDT:USDT")
   *
   * @example
   * ```typescript
   * normalizer.symbolToCCXT('BTC-PERP');  // "BTC/USDT:USDT"
   * normalizer.symbolToCCXT('ETH-PERP');  // "ETH/USDT:USDT"
   * normalizer.symbolToCCXT('BTC-SPOT');  // "BTC/USDT"
   * ```
   */
  symbolToCCXT(grvtSymbol) {
    if (grvtSymbol.endsWith("_Perp")) {
      const parts = grvtSymbol.replace("_Perp", "").split("_");
      const base = parts[0];
      const quote = parts[1] || "USDT";
      return `${base}/${quote}:${quote}`;
    }
    if (grvtSymbol.endsWith("-PERP")) {
      const base = grvtSymbol.replace("-PERP", "");
      return `${base}/USDT:USDT`;
    }
    if (grvtSymbol.includes("_")) {
      const [base, quote] = grvtSymbol.split("_");
      return `${base}/${quote || "USDT"}`;
    }
    return `${grvtSymbol}/USDT:USDT`;
  }
  /**
   * Convert CCXT symbol to GRVT format
   *
   * @param ccxtSymbol - CCXT formatted symbol (e.g., "BTC/USDT:USDT")
   * @returns GRVT symbol (e.g., "BTC_USDT_Perp")
   *
   * @example
   * ```typescript
   * normalizer.symbolFromCCXT('BTC/USDT:USDT'); // "BTC_USDT_Perp"
   * normalizer.symbolFromCCXT('ETH/USDT:USDT'); // "ETH_USDT_Perp"
   * normalizer.symbolFromCCXT('BTC/USDT');      // "BTC_USDT"
   * ```
   */
  symbolFromCCXT(ccxtSymbol) {
    if (ccxtSymbol.includes(":")) {
      const parts2 = ccxtSymbol.split(":");
      const pair = parts2[0] || "";
      const settle = parts2[1] || "USDT";
      const pairParts = pair.split("/");
      const base2 = pairParts[0] || "";
      const quote2 = pairParts[1] || settle;
      return `${base2}_${quote2}_Perp`;
    }
    const parts = ccxtSymbol.split("/");
    const base = parts[0] || "";
    const quote = parts[1] || "USDT";
    return `${base}_${quote}`;
  }
  // ===========================================================================
  // Precision-Safe Numeric Conversions
  // ===========================================================================
  /**
   * Convert string to number with validation
   *
   * @param value - String value to convert
   * @param decimals - Number of decimal places (default: 8)
   * @returns Number
   *
   * @throws {PerpDEXError} If value is not a valid number
   */
  toNumberSafe(value, decimals = GRVT_PRECISION.price) {
    if (!value || value === "0") {
      return 0;
    }
    const num = parseFloat(value);
    if (!Number.isFinite(num)) {
      throw new PerpDEXError(
        `Invalid number conversion: ${value}`,
        "INVALID_NUMBER",
        "grvt"
      );
    }
    return Math.round(num * Math.pow(10, decimals)) / Math.pow(10, decimals);
  }
  /**
   * Convert number to string with precision
   *
   * @param value - Number to convert
   * @param decimals - Number of decimal places
   * @returns String representation
   */
  // ===========================================================================
  // Market Normalization
  // ===========================================================================
  /**
   * Normalize GRVT market to unified format
   *
   * @param grvtMarket - GRVT market data from SDK
   * @returns Unified market
   */
  normalizeMarket(grvtMarket) {
    return {
      id: grvtMarket.instrument || "",
      symbol: this.symbolToCCXT(grvtMarket.instrument || ""),
      base: grvtMarket.base || "",
      quote: grvtMarket.quote || "",
      settle: grvtMarket.quote || "",
      // GRVT settles in quote currency
      active: true,
      // SDK doesn't provide is_active, assume true
      minAmount: this.toNumberSafe(grvtMarket.min_size || "0"),
      maxAmount: this.toNumberSafe(grvtMarket.max_position_size || "0"),
      minCost: void 0,
      pricePrecision: GRVT_PRECISION.price,
      amountPrecision: GRVT_PRECISION.amount,
      priceTickSize: this.toNumberSafe(grvtMarket.tick_size || "0"),
      amountStepSize: this.toNumberSafe(grvtMarket.min_size || "0"),
      makerFee: 0,
      // SDK doesn't provide fees directly
      takerFee: 0,
      maxLeverage: 100,
      // GRVT supports up to 100x
      fundingIntervalHours: grvtMarket.funding_interval_hours || 8,
      info: grvtMarket
    };
  }
  /**
   * Batch normalize markets
   */
  normalizeMarkets(grvtMarkets) {
    return grvtMarkets.map((m) => this.normalizeMarket(m));
  }
  // ===========================================================================
  // Order Normalization
  // ===========================================================================
  /**
   * Normalize GRVT order to unified format
   */
  normalizeOrder(grvtOrder) {
    const leg = grvtOrder.legs?.[0];
    const amount = this.toNumberSafe(leg?.size || "0");
    const traded = this.toNumberSafe(grvtOrder.state?.traded_size?.[0] || "0");
    const book = this.toNumberSafe(grvtOrder.state?.book_size?.[0] || "0");
    return {
      id: grvtOrder.order_id || "",
      clientOrderId: grvtOrder.metadata?.client_order_id,
      symbol: this.symbolToCCXT(leg?.instrument || ""),
      type: grvtOrder.is_market ? "market" : "limit",
      side: leg?.is_buying_asset ? "buy" : "sell",
      amount,
      price: leg?.limit_price ? this.toNumberSafe(leg.limit_price) : void 0,
      status: this.mapSDKOrderStatus(grvtOrder.state?.status || ""),
      filled: traded,
      remaining: book,
      averagePrice: grvtOrder.state?.avg_fill_price?.[0] ? this.toNumberSafe(grvtOrder.state.avg_fill_price[0]) : void 0,
      timeInForce: this.mapSDKTimeInForce(grvtOrder.time_in_force || ""),
      reduceOnly: grvtOrder.reduce_only || false,
      postOnly: grvtOrder.post_only || false,
      timestamp: grvtOrder.metadata?.create_time ? parseInt(grvtOrder.metadata.create_time) : Date.now(),
      lastUpdateTimestamp: grvtOrder.state?.update_time ? parseInt(grvtOrder.state.update_time) : void 0,
      info: grvtOrder
    };
  }
  /**
   * Map SDK order status to unified format
   */
  mapSDKOrderStatus(status) {
    const statusMap = {
      PENDING: "open",
      OPEN: "open",
      PARTIALLY_FILLED: "partiallyFilled",
      FILLED: "filled",
      CANCELLED: "canceled",
      REJECTED: "rejected"
    };
    return statusMap[status] || "open";
  }
  /**
   * Map SDK time in force to unified format
   */
  mapSDKTimeInForce(tif) {
    const tifMap = {
      GOOD_TIL_CANCEL: "GTC",
      IMMEDIATE_OR_CANCEL: "IOC",
      FILL_OR_KILL: "FOK"
    };
    return tifMap[tif] || "GTC";
  }
  /**
   * Batch normalize orders
   */
  normalizeOrders(grvtOrders) {
    return grvtOrders.map((o) => this.normalizeOrder(o));
  }
  // ===========================================================================
  // Position Normalization
  // ===========================================================================
  /**
   * Normalize GRVT position to unified format
   */
  normalizePosition(grvtPosition) {
    const size = this.toNumberSafe(grvtPosition.size || "0");
    const entryPrice = this.toNumberSafe(grvtPosition.entry_price || "0");
    const markPrice = this.toNumberSafe(grvtPosition.mark_price || "0");
    const leverage = this.toNumberSafe(grvtPosition.leverage || "1", 2);
    const notional = this.toNumberSafe(grvtPosition.notional || "0");
    const margin = leverage > 0 ? notional / leverage : 0;
    return {
      symbol: this.symbolToCCXT(grvtPosition.instrument || ""),
      side: size > 0 ? "long" : "short",
      size: Math.abs(size),
      entryPrice,
      markPrice,
      liquidationPrice: grvtPosition.est_liquidation_price ? this.toNumberSafe(grvtPosition.est_liquidation_price) : 0,
      unrealizedPnl: this.toNumberSafe(grvtPosition.unrealized_pnl || "0"),
      realizedPnl: this.toNumberSafe(grvtPosition.realized_pnl || "0"),
      leverage,
      marginMode: "cross",
      margin,
      maintenanceMargin: margin * 0.5,
      // Estimate
      marginRatio: margin > 0 ? margin / notional * 100 : 0,
      timestamp: grvtPosition.event_time ? parseInt(grvtPosition.event_time) : Date.now(),
      info: grvtPosition
    };
  }
  /**
   * Batch normalize positions
   */
  normalizePositions(grvtPositions) {
    return grvtPositions.map((p) => this.normalizePosition(p));
  }
  // ===========================================================================
  // Balance Normalization
  // ===========================================================================
  /**
   * Normalize GRVT balance to unified format
   */
  normalizeBalance(grvtBalance) {
    const total = this.toNumberSafe(grvtBalance.balance || "0");
    return {
      currency: grvtBalance.currency || "",
      free: total,
      // SDK doesn't separate free/used for spot balances
      used: 0,
      total,
      info: grvtBalance
    };
  }
  /**
   * Batch normalize balances
   */
  normalizeBalances(grvtBalances) {
    return grvtBalances.map((b) => this.normalizeBalance(b));
  }
  // ===========================================================================
  // Trade Normalization
  // ===========================================================================
  /**
   * Normalize GRVT trade to unified format (public trades)
   */
  normalizeTrade(grvtTrade) {
    const price = this.toNumberSafe(grvtTrade.price || "0");
    const amount = this.toNumberSafe(grvtTrade.size || "0");
    return {
      id: grvtTrade.trade_id || "",
      orderId: void 0,
      symbol: this.symbolToCCXT(grvtTrade.instrument || ""),
      side: grvtTrade.is_taker_buyer ? "buy" : "sell",
      price,
      amount,
      cost: price * amount,
      timestamp: grvtTrade.event_time ? parseInt(grvtTrade.event_time) : Date.now(),
      info: grvtTrade
    };
  }
  /**
   * Batch normalize trades
   */
  normalizeTrades(grvtTrades) {
    return grvtTrades.map((t) => this.normalizeTrade(t));
  }
  /**
   * Normalize GRVT fill to unified trade format (user fills)
   */
  normalizeFill(grvtFill) {
    const price = this.toNumberSafe(grvtFill.price || "0");
    const amount = this.toNumberSafe(grvtFill.size || "0");
    return {
      id: grvtFill.trade_id || "",
      orderId: grvtFill.order_id,
      symbol: this.symbolToCCXT(grvtFill.instrument || ""),
      side: grvtFill.is_buyer ? "buy" : "sell",
      price,
      amount,
      cost: price * amount,
      timestamp: grvtFill.event_time ? parseInt(grvtFill.event_time) : Date.now(),
      info: grvtFill
    };
  }
  /**
   * Batch normalize fills
   */
  normalizeFills(grvtFills) {
    return grvtFills.map((f) => this.normalizeFill(f));
  }
  // ===========================================================================
  // Ticker Normalization
  // ===========================================================================
  /**
   * Normalize GRVT ticker to unified format
   */
  normalizeTicker(grvtTicker) {
    const last = this.toNumberSafe(grvtTicker.last_price || "0");
    const high = this.toNumberSafe(grvtTicker.high_price || "0");
    const low = this.toNumberSafe(grvtTicker.low_price || "0");
    const open = this.toNumberSafe(grvtTicker.open_price || "0");
    const change = last - open;
    const buyVolumeB = this.toNumberSafe(grvtTicker.buy_volume_24h_b || "0");
    const sellVolumeB = this.toNumberSafe(grvtTicker.sell_volume_24h_b || "0");
    return {
      symbol: this.symbolToCCXT(grvtTicker.instrument || ""),
      last,
      bid: this.toNumberSafe(grvtTicker.best_bid_price || "0"),
      bidVolume: this.toNumberSafe(grvtTicker.best_bid_size || "0"),
      ask: this.toNumberSafe(grvtTicker.best_ask_price || "0"),
      askVolume: this.toNumberSafe(grvtTicker.best_ask_size || "0"),
      high,
      low,
      open,
      close: last,
      change,
      percentage: open > 0 ? change / open * 100 : 0,
      baseVolume: buyVolumeB + sellVolumeB,
      quoteVolume: 0,
      timestamp: grvtTicker.event_time ? parseInt(grvtTicker.event_time) : Date.now(),
      info: grvtTicker
    };
  }
  /**
   * Batch normalize tickers
   */
  normalizeTickers(grvtTickers) {
    return grvtTickers.map((t) => this.normalizeTicker(t));
  }
  // ===========================================================================
  // Order Book Normalization
  // ===========================================================================
  /**
   * Normalize GRVT order book to unified format
   */
  normalizeOrderBook(grvtOrderBook) {
    return {
      symbol: this.symbolToCCXT(grvtOrderBook.instrument || ""),
      timestamp: grvtOrderBook.event_time ? parseInt(grvtOrderBook.event_time) : Date.now(),
      bids: (grvtOrderBook.bids || []).map((level) => [
        this.toNumberSafe(level.price || "0"),
        this.toNumberSafe(level.size || "0")
      ]),
      asks: (grvtOrderBook.asks || []).map((level) => [
        this.toNumberSafe(level.price || "0"),
        this.toNumberSafe(level.size || "0")
      ]),
      sequenceId: void 0,
      // SDK doesn't provide sequence
      checksum: void 0,
      exchange: "grvt"
    };
  }
};

// src/adapters/grvt/GRVTErrorMapper.ts
var GRVT_CLIENT_ERRORS = {
  // Authentication & Signature
  INVALID_SIGNATURE: "INVALID_SIGNATURE",
  EXPIRED_SESSION: "EXPIRED_SESSION",
  UNAUTHORIZED: "UNAUTHORIZED",
  FORBIDDEN: "FORBIDDEN",
  INVALID_API_KEY: "INVALID_API_KEY",
  // Order Errors
  INVALID_ORDER: "INVALID_ORDER",
  INSUFFICIENT_MARGIN: "INSUFFICIENT_MARGIN",
  INSUFFICIENT_BALANCE: "INSUFFICIENT_BALANCE",
  ORDER_NOT_FOUND: "ORDER_NOT_FOUND",
  ORDER_ALREADY_FILLED: "ORDER_ALREADY_FILLED",
  ORDER_ALREADY_CANCELLED: "ORDER_ALREADY_CANCELLED",
  INVALID_PRICE: "INVALID_PRICE",
  INVALID_SIZE: "INVALID_SIZE",
  MIN_SIZE_NOT_MET: "MIN_SIZE_NOT_MET",
  MAX_SIZE_EXCEEDED: "MAX_SIZE_EXCEEDED",
  PRICE_OUT_OF_RANGE: "PRICE_OUT_OF_RANGE",
  SELF_TRADE: "SELF_TRADE",
  // Market/Instrument Errors
  INVALID_INSTRUMENT: "INVALID_INSTRUMENT",
  INSTRUMENT_NOT_ACTIVE: "INSTRUMENT_NOT_ACTIVE",
  MARKET_CLOSED: "MARKET_CLOSED",
  TRADING_HALTED: "TRADING_HALTED",
  // Position Errors
  POSITION_NOT_FOUND: "POSITION_NOT_FOUND",
  MAX_POSITION_EXCEEDED: "MAX_POSITION_EXCEEDED",
  REDUCE_ONLY_VIOLATION: "REDUCE_ONLY_VIOLATION",
  // Leverage Errors
  INVALID_LEVERAGE: "INVALID_LEVERAGE",
  MAX_LEVERAGE_EXCEEDED: "MAX_LEVERAGE_EXCEEDED",
  // Validation Errors
  INVALID_REQUEST: "INVALID_REQUEST",
  INVALID_PARAMS: "INVALID_PARAMS",
  MISSING_REQUIRED_FIELD: "MISSING_REQUIRED_FIELD",
  INVALID_TIME_IN_FORCE: "INVALID_TIME_IN_FORCE"
};
var GRVT_SERVER_ERRORS = {
  INTERNAL_ERROR: "INTERNAL_ERROR",
  SERVICE_UNAVAILABLE: "SERVICE_UNAVAILABLE",
  GATEWAY_TIMEOUT: "GATEWAY_TIMEOUT",
  DATABASE_ERROR: "DATABASE_ERROR",
  MATCHING_ENGINE_ERROR: "MATCHING_ENGINE_ERROR",
  SEQUENCER_ERROR: "SEQUENCER_ERROR"
};
var GRVT_RATE_LIMIT_ERROR = "RATE_LIMIT_EXCEEDED";
var GRVT_NETWORK_ERRORS = {
  ECONNRESET: "ECONNRESET",
  ETIMEDOUT: "ETIMEDOUT",
  ENOTFOUND: "ENOTFOUND",
  ECONNREFUSED: "ECONNREFUSED",
  NETWORK_ERROR: "NETWORK_ERROR",
  WEBSOCKET_CLOSED: "WEBSOCKET_CLOSED",
  WEBSOCKET_ERROR: "WEBSOCKET_ERROR"
};
function isServerError(errorCode) {
  return Object.values(GRVT_SERVER_ERRORS).includes(errorCode);
}
function isNetworkError(errorCode) {
  return Object.values(GRVT_NETWORK_ERRORS).includes(errorCode);
}
function mapGRVTError(errorCode, message, originalError) {
  const code = errorCode.toString();
  if (code === GRVT_CLIENT_ERRORS.INVALID_SIGNATURE || code === GRVT_CLIENT_ERRORS.INVALID_API_KEY) {
    return new InvalidSignatureError(message, code, "grvt", originalError);
  }
  if (code === GRVT_CLIENT_ERRORS.EXPIRED_SESSION) {
    return new ExpiredAuthError(message, code, "grvt", originalError);
  }
  if (code === GRVT_CLIENT_ERRORS.UNAUTHORIZED || code === GRVT_CLIENT_ERRORS.FORBIDDEN) {
    return new InsufficientPermissionsError(message, code, "grvt", originalError);
  }
  if (code === GRVT_CLIENT_ERRORS.INSUFFICIENT_MARGIN || code === GRVT_CLIENT_ERRORS.INSUFFICIENT_BALANCE) {
    return new InsufficientMarginError(message, code, "grvt", originalError);
  }
  if (code === GRVT_CLIENT_ERRORS.ORDER_NOT_FOUND) {
    return new OrderNotFoundError(message, code, "grvt", originalError);
  }
  if (code === GRVT_CLIENT_ERRORS.INVALID_ORDER || code === GRVT_CLIENT_ERRORS.ORDER_ALREADY_FILLED || code === GRVT_CLIENT_ERRORS.ORDER_ALREADY_CANCELLED || code === GRVT_CLIENT_ERRORS.INVALID_PRICE || code === GRVT_CLIENT_ERRORS.INVALID_SIZE || code === GRVT_CLIENT_ERRORS.MIN_SIZE_NOT_MET || code === GRVT_CLIENT_ERRORS.MAX_SIZE_EXCEEDED || code === GRVT_CLIENT_ERRORS.PRICE_OUT_OF_RANGE || code === GRVT_CLIENT_ERRORS.SELF_TRADE || code === GRVT_CLIENT_ERRORS.INVALID_INSTRUMENT || code === GRVT_CLIENT_ERRORS.INSTRUMENT_NOT_ACTIVE || code === GRVT_CLIENT_ERRORS.MARKET_CLOSED || code === GRVT_CLIENT_ERRORS.TRADING_HALTED || code === GRVT_CLIENT_ERRORS.MAX_POSITION_EXCEEDED || code === GRVT_CLIENT_ERRORS.REDUCE_ONLY_VIOLATION || code === GRVT_CLIENT_ERRORS.INVALID_LEVERAGE || code === GRVT_CLIENT_ERRORS.MAX_LEVERAGE_EXCEEDED || code === GRVT_CLIENT_ERRORS.INVALID_TIME_IN_FORCE) {
    return new InvalidOrderError(message, code, "grvt", originalError);
  }
  if (code === GRVT_RATE_LIMIT_ERROR) {
    const retryAfter = extractRetryAfter(originalError);
    return new RateLimitError(message, code, "grvt", retryAfter, originalError);
  }
  if (isServerError(code) || isNetworkError(code)) {
    return new ExchangeUnavailableError(message, code, "grvt", originalError);
  }
  return new PerpDEXError(message, code, "grvt", originalError);
}
function extractGRVTError(response) {
  if (!response) {
    return { code: "UNKNOWN_ERROR", message: "Unknown error occurred" };
  }
  const errorObj = response.error || response;
  if (typeof errorObj === "string") {
    return { code: "UNKNOWN_ERROR", message: errorObj };
  }
  const code = errorObj.code?.toString() || "UNKNOWN_ERROR";
  const message = errorObj.message || errorObj.error || "Unknown error occurred";
  return { code, message };
}
function mapHttpError(status, statusText, responseData) {
  if (responseData && responseData.error) {
    const { code, message } = extractGRVTError(responseData);
    return mapGRVTError(code, message, responseData);
  }
  if (status === 401) {
    return new InvalidSignatureError(
      `Unauthorized: ${statusText}`,
      "UNAUTHORIZED",
      "grvt"
    );
  }
  if (status === 403) {
    return new InsufficientPermissionsError(
      `Forbidden: ${statusText}`,
      "FORBIDDEN",
      "grvt"
    );
  }
  if (status === 404) {
    return new OrderNotFoundError(
      `Not found: ${statusText}`,
      "NOT_FOUND",
      "grvt"
    );
  }
  if (status === 429) {
    const retryAfter = extractRetryAfter(responseData);
    return new RateLimitError(
      `Rate limit exceeded: ${statusText}`,
      GRVT_RATE_LIMIT_ERROR,
      "grvt",
      retryAfter
    );
  }
  if (status >= 400 && status < 500) {
    return new InvalidOrderError(
      `Client error (${status}): ${statusText}`,
      `HTTP_${status}`,
      "grvt"
    );
  }
  if (status === 503) {
    return new ExchangeUnavailableError(
      `Service unavailable: ${statusText}`,
      "SERVICE_UNAVAILABLE",
      "grvt"
    );
  }
  if (status >= 500) {
    return new ExchangeUnavailableError(
      `Server error (${status}): ${statusText}`,
      `HTTP_${status}`,
      "grvt"
    );
  }
  return new PerpDEXError(
    `HTTP error (${status}): ${statusText}`,
    `HTTP_${status}`,
    "grvt"
  );
}
function mapAxiosError(error) {
  if (error.response) {
    const { status, statusText, data } = error.response;
    return mapHttpError(status, statusText, data);
  }
  if (error.code && isNetworkError(error.code)) {
    return new ExchangeUnavailableError(
      error.message || "Network error occurred",
      error.code,
      "grvt",
      error
    );
  }
  if (error.code === "ECONNABORTED") {
    return new ExchangeUnavailableError(
      "Request timeout",
      "ETIMEDOUT",
      "grvt",
      error
    );
  }
  return new PerpDEXError(
    error.message || "Unknown error occurred",
    error.code || "UNKNOWN_ERROR",
    "grvt",
    error
  );
}
function extractRetryAfter(error) {
  if (!error) return void 0;
  if (error.headers && error.headers["retry-after"]) {
    const value = parseInt(error.headers["retry-after"], 10);
    return isNaN(value) ? void 0 : value;
  }
  if (error.response && error.response.headers && error.response.headers["retry-after"]) {
    const value = parseInt(error.response.headers["retry-after"], 10);
    return isNaN(value) ? void 0 : value;
  }
  if (error.retryAfter) {
    const value = parseInt(error.retryAfter, 10);
    return isNaN(value) ? void 0 : value;
  }
  return void 0;
}

// src/adapters/grvt/GRVTWebSocketWrapper.ts
var import_ws = require("@grvt/client/ws/index.js");
var GRVTWebSocketWrapper = class _GRVTWebSocketWrapper {
  /** Maximum queue size for backpressure */
  static MAX_QUEUE_SIZE = 1e3;
  ws;
  normalizer;
  subAccountId;
  logger = new Logger("GRVTWebSocket");
  isConnected = false;
  /**
   * Push to queue with bounded size (backpressure)
   */
  boundedPush(queue, item, channel) {
    if (queue.length >= _GRVTWebSocketWrapper.MAX_QUEUE_SIZE) {
      queue.shift();
      if (channel) {
        this.logger.warn(`Queue overflow on ${channel}, dropping oldest message`);
      }
    }
    queue.push(item);
  }
  constructor(config = {}) {
    const urls = config.testnet ? GRVT_API_URLS.testnet : GRVT_API_URLS.mainnet;
    this.normalizer = new GRVTNormalizer();
    this.subAccountId = config.subAccountId;
    this.ws = new import_ws.WS({
      url: urls.websocket,
      timeout: config.timeout || 3e4,
      reconnectStrategy: (retries) => {
        const delay = Math.min(1e3 * Math.pow(2, retries), 3e4);
        return delay;
      }
    });
    this.ws.onConnect(() => {
      this.isConnected = true;
    });
    this.ws.onClose(() => {
      this.isConnected = false;
    });
    this.ws.onError((error) => {
      this.logger.error("WebSocket error", error instanceof Error ? error : void 0, { error });
    });
  }
  /**
   * Connect to WebSocket
   */
  async connect() {
    this.ws.connect();
    await this.ws.ready(5e3);
    this.isConnected = true;
  }
  /**
   * Disconnect from WebSocket
   */
  disconnect() {
    this.ws.disconnect();
    this.isConnected = false;
  }
  /**
   * Watch order book updates for a symbol
   *
   * @param symbol - Trading symbol in CCXT format (e.g., "BTC/USDT:USDT")
   * @param depth - Order book depth (default: 50)
   * @returns AsyncGenerator yielding OrderBook updates
   *
   * @example
   * ```typescript
   * for await (const orderBook of wrapper.watchOrderBook('BTC/USDT:USDT')) {
   *   console.log('Bid:', orderBook.bids[0]);
   *   console.log('Ask:', orderBook.asks[0]);
   * }
   * ```
   */
  async *watchOrderBook(symbol, depth = 50) {
    const instrument = this.normalizer.symbolFromCCXT(symbol);
    const queue = [];
    let error = null;
    let subscriptionKey = null;
    let resolver = null;
    let rejecter = null;
    const request = {
      stream: import_ws.EStream.RPI_BOOK_SNAP,
      // Use RPI (Retail Price Improvement) snapshot stream
      params: {
        instrument,
        depth
      },
      onData: (data) => {
        if (resolver) {
          resolver(data);
          resolver = null;
          rejecter = null;
        } else {
          this.boundedPush(queue, data, "orderbook");
        }
      },
      onError: (err2) => {
        error = err2;
        if (rejecter) {
          rejecter(err2);
          resolver = null;
          rejecter = null;
        }
      }
    };
    try {
      subscriptionKey = this.ws.subscribe(request);
      while (true) {
        if (error) {
          throw error;
        }
        let orderBookData;
        if (queue.length > 0) {
          orderBookData = queue.shift();
        } else {
          orderBookData = await new Promise((resolve, reject) => {
            resolver = resolve;
            rejecter = reject;
          });
        }
        if (error) {
          throw error;
        }
        const normalized = this.normalizer.normalizeOrderBook(orderBookData);
        yield normalized;
      }
    } finally {
      if (subscriptionKey) {
        this.ws.unsubscribe(subscriptionKey);
      }
    }
  }
  /**
   * Watch public trades for a symbol
   *
   * @param symbol - Trading symbol in CCXT format
   * @returns AsyncGenerator yielding Trade updates
   *
   * @example
   * ```typescript
   * for await (const trade of wrapper.watchTrades('BTC/USDT:USDT')) {
   *   console.log('Trade:', trade.price, trade.amount, trade.side);
   * }
   * ```
   */
  async *watchTrades(symbol) {
    const instrument = this.normalizer.symbolFromCCXT(symbol);
    const queue = [];
    let error = null;
    let subscriptionKey = null;
    let resolver = null;
    let rejecter = null;
    const request = {
      stream: import_ws.EStream.TRADE,
      params: {
        instrument
      },
      onData: (data) => {
        if (resolver) {
          resolver(data);
          resolver = null;
          rejecter = null;
        } else {
          this.boundedPush(queue, data, "trades");
        }
      },
      onError: (err2) => {
        error = err2;
        if (rejecter) {
          rejecter(err2);
          resolver = null;
          rejecter = null;
        }
      }
    };
    try {
      subscriptionKey = this.ws.subscribe(request);
      while (true) {
        if (error) throw error;
        let tradeData;
        if (queue.length > 0) {
          tradeData = queue.shift();
        } else {
          tradeData = await new Promise((resolve, reject) => {
            resolver = resolve;
            rejecter = reject;
          });
        }
        if (error) throw error;
        const normalized = this.normalizer.normalizeTrade(tradeData);
        yield normalized;
      }
    } finally {
      if (subscriptionKey) {
        this.ws.unsubscribe(subscriptionKey);
      }
    }
  }
  /**
   * Watch position updates for user account
   *
   * @param symbol - Optional symbol filter (watch all positions if not provided)
   * @returns AsyncGenerator yielding Position updates
   *
   * @example
   * ```typescript
   * for await (const position of wrapper.watchPositions()) {
   *   console.log('Position:', position.symbol, position.size, position.unrealizedPnl);
   * }
   * ```
   */
  async *watchPositions(symbol) {
    if (!this.subAccountId) {
      throw new Error("Sub-account ID required for watching positions");
    }
    const instrument = symbol ? this.normalizer.symbolFromCCXT(symbol) : void 0;
    const queue = [];
    let error = null;
    let subscriptionKey = null;
    let resolver = null;
    let rejecter = null;
    const request = {
      stream: import_ws.EStream.POSITION,
      params: {
        sub_account_id: this.subAccountId,
        ...instrument && { instrument }
      },
      onData: (data) => {
        if (resolver) {
          resolver(data);
          resolver = null;
          rejecter = null;
        } else {
          this.boundedPush(queue, data, "positions");
        }
      },
      onError: (err2) => {
        error = err2;
        if (rejecter) {
          rejecter(err2);
          resolver = null;
          rejecter = null;
        }
      }
    };
    try {
      subscriptionKey = this.ws.subscribe(request);
      while (true) {
        if (error) throw error;
        let positionData;
        if (queue.length > 0) {
          positionData = queue.shift();
        } else {
          positionData = await new Promise((resolve, reject) => {
            resolver = resolve;
            rejecter = reject;
          });
        }
        if (error) throw error;
        const normalized = this.normalizer.normalizePosition(positionData);
        yield normalized;
      }
    } finally {
      if (subscriptionKey) {
        this.ws.unsubscribe(subscriptionKey);
      }
    }
  }
  /**
   * Watch order updates for user account
   *
   * @param symbol - Optional symbol filter
   * @returns AsyncGenerator yielding Order updates
   *
   * @example
   * ```typescript
   * for await (const order of wrapper.watchOrders()) {
   *   console.log('Order:', order.id, order.status, order.filled);
   * }
   * ```
   */
  async *watchOrders(symbol) {
    if (!this.subAccountId) {
      throw new Error("Sub-account ID required for watching orders");
    }
    const instrument = symbol ? this.normalizer.symbolFromCCXT(symbol) : void 0;
    const queue = [];
    let error = null;
    let subscriptionKey = null;
    let resolver = null;
    let rejecter = null;
    const request = {
      stream: import_ws.EStream.ORDER,
      params: {
        sub_account_id: this.subAccountId,
        ...instrument && { instrument }
      },
      onData: (data) => {
        if (resolver) {
          resolver(data);
          resolver = null;
          rejecter = null;
        } else {
          this.boundedPush(queue, data, "orders");
        }
      },
      onError: (err2) => {
        error = err2;
        if (rejecter) {
          rejecter(err2);
          resolver = null;
          rejecter = null;
        }
      }
    };
    try {
      subscriptionKey = this.ws.subscribe(request);
      while (true) {
        if (error) throw error;
        let orderData;
        if (queue.length > 0) {
          orderData = queue.shift();
        } else {
          orderData = await new Promise((resolve, reject) => {
            resolver = resolve;
            rejecter = reject;
          });
        }
        if (error) throw error;
        const normalized = this.normalizer.normalizeOrder(orderData);
        yield normalized;
      }
    } finally {
      if (subscriptionKey) {
        this.ws.unsubscribe(subscriptionKey);
      }
    }
  }
  /**
   * Watch balance updates for user account
   *
   * @returns AsyncGenerator yielding Balance array
   *
   * @example
   * ```typescript
   * for await (const balances of wrapper.watchBalance()) {
   *   console.log('Balances:', balances);
   * }
   * ```
   */
  async *watchBalance() {
    if (!this.subAccountId) {
      throw new Error("Sub-account ID required for watching balance");
    }
    for await (const position of this.watchPositions()) {
      const balance = {
        currency: "USDT",
        free: position.margin || 0,
        used: 0,
        total: position.margin || 0,
        info: position.info
      };
      yield [balance];
    }
  }
  /**
   * Watch ticker updates for a symbol
   *
   * GRVT doesn't have a dedicated ticker stream, so we derive ticker
   * from trade stream updates. Each trade update contains price info
   * that can be used to construct ticker-like updates.
   *
   * @param symbol - Trading symbol in CCXT format (e.g., "BTC/USDT:USDT")
   * @returns AsyncGenerator yielding Ticker updates
   *
   * @example
   * ```typescript
   * for await (const ticker of wrapper.watchTicker('BTC/USDT:USDT')) {
   *   console.log('Price:', ticker.last, 'Volume:', ticker.quoteVolume);
   * }
   * ```
   */
  async *watchTicker(symbol) {
    const instrument = this.normalizer.symbolFromCCXT(symbol);
    const queue = [];
    let error = null;
    let subscriptionKey = null;
    let resolver = null;
    let rejecter = null;
    const request = {
      stream: import_ws.EStream.TRADE,
      params: {
        instrument
      },
      onData: (data) => {
        if (resolver) {
          resolver(data);
          resolver = null;
          rejecter = null;
        } else {
          this.boundedPush(queue, data, "ticker");
        }
      },
      onError: (err2) => {
        error = err2;
        if (rejecter) {
          rejecter(err2);
          resolver = null;
          rejecter = null;
        }
      }
    };
    try {
      subscriptionKey = this.ws.subscribe(request);
      while (true) {
        if (error) throw error;
        let tradeData;
        if (queue.length > 0) {
          tradeData = queue.shift();
        } else {
          tradeData = await new Promise((resolve, reject) => {
            resolver = resolve;
            rejecter = reject;
          });
        }
        if (error) throw error;
        const lastPrice = parseFloat(tradeData.price || "0");
        const lastSize = parseFloat(tradeData.size || "0");
        const ticker = {
          symbol: this.normalizer.symbolToCCXT(instrument),
          timestamp: typeof tradeData.event_time === "number" ? tradeData.event_time : Date.now(),
          last: lastPrice,
          bid: 0,
          // Not available from trade stream
          ask: 0,
          // Not available from trade stream
          high: lastPrice,
          // Single trade, same as last
          low: lastPrice,
          // Single trade, same as last
          open: lastPrice,
          // Single trade, same as last
          close: lastPrice,
          change: 0,
          // Requires 24h aggregation
          percentage: 0,
          // Requires 24h aggregation
          baseVolume: lastSize,
          quoteVolume: lastPrice * lastSize,
          info: tradeData
        };
        yield ticker;
      }
    } finally {
      if (subscriptionKey) {
        this.ws.unsubscribe(subscriptionKey);
      }
    }
  }
  /**
   * Watch user trades (fills) in real-time
   *
   * @param symbol - Optional symbol filter
   * @returns AsyncGenerator yielding Trade updates
   *
   * @example
   * ```typescript
   * for await (const trade of wrapper.watchMyTrades()) {
   *   console.log('Fill:', trade.symbol, trade.side, trade.amount, '@', trade.price);
   * }
   * ```
   */
  async *watchMyTrades(symbol) {
    if (!this.subAccountId) {
      throw new Error("Sub-account ID required for watching fills");
    }
    const instrument = symbol ? this.normalizer.symbolFromCCXT(symbol) : void 0;
    const queue = [];
    let error = null;
    let subscriptionKey = null;
    let resolver = null;
    let rejecter = null;
    const request = {
      stream: import_ws.EStream.FILL,
      params: {
        sub_account_id: this.subAccountId,
        ...instrument && { instrument }
      },
      onData: (data) => {
        if (resolver) {
          resolver(data);
          resolver = null;
          rejecter = null;
        } else {
          this.boundedPush(queue, data, "fills");
        }
      },
      onError: (err2) => {
        error = err2;
        if (rejecter) {
          rejecter(err2);
          resolver = null;
          rejecter = null;
        }
      }
    };
    try {
      subscriptionKey = this.ws.subscribe(request);
      while (true) {
        if (error) throw error;
        let data;
        if (queue.length > 0) {
          data = queue.shift();
        } else {
          data = await new Promise((resolve, reject) => {
            resolver = resolve;
            rejecter = reject;
          });
        }
        if (error) throw error;
        const trade = {
          id: data.fill_id || data.id || String(Date.now()),
          symbol: this.normalizer.symbolToCCXT(data.instrument || data.symbol),
          orderId: data.order_id,
          side: data.is_buyer ? "buy" : "sell",
          price: parseFloat(data.price || "0"),
          amount: parseFloat(data.filled || data.quantity || "0"),
          cost: parseFloat(data.price || "0") * parseFloat(data.filled || data.quantity || "0"),
          timestamp: data.event_time || Date.now(),
          info: data
        };
        yield trade;
      }
    } finally {
      if (subscriptionKey) {
        this.ws.unsubscribe(subscriptionKey);
      }
    }
  }
  /**
   * Check if WebSocket is connected
   */
  get connected() {
    return this.isConnected;
  }
};

// src/adapters/grvt/GRVTAdapter.ts
var GRVTAdapter = class extends BaseAdapter {
  id = "grvt";
  name = "GRVT";
  has = {
    fetchMarkets: true,
    fetchTicker: true,
    fetchOrderBook: true,
    fetchTrades: true,
    fetchOHLCV: true,
    fetchFundingRate: true,
    fetchFundingRateHistory: false,
    // GRVT doesn't provide historical funding rates
    fetchPositions: true,
    fetchBalance: true,
    fetchOrderHistory: true,
    // NOW IMPLEMENTED via SDK
    fetchMyTrades: true,
    // NOW IMPLEMENTED via SDK
    createOrder: true,
    createBatchOrders: true,
    cancelOrder: true,
    cancelAllOrders: true,
    watchOrderBook: true,
    watchTrades: true,
    watchTicker: true,
    watchPositions: true,
    watchOrders: true,
    watchBalance: true,
    watchMyTrades: true
  };
  sdk;
  auth;
  normalizer;
  ws;
  rateLimiter;
  testnet;
  constructor(config = {}) {
    super(config);
    this.testnet = config.testnet ?? false;
    const urls = this.testnet ? GRVT_API_URLS.testnet : GRVT_API_URLS.mainnet;
    this.auth = new GRVTAuth(config);
    this.normalizer = new GRVTNormalizer();
    this.sdk = new GRVTSDKWrapper({
      host: urls.rest,
      apiKey: config.apiKey,
      timeout: config.timeout
    });
    this.rateLimiter = new RateLimiter({
      maxTokens: GRVT_RATE_LIMITS.rest.maxRequests,
      refillRate: GRVT_RATE_LIMITS.rest.maxRequests / (GRVT_RATE_LIMITS.rest.windowMs / 1e3),
      windowMs: GRVT_RATE_LIMITS.rest.windowMs,
      weights: GRVT_ENDPOINT_WEIGHTS
    });
  }
  async initialize() {
    if (this.auth.hasCredentials()) {
      const isValid2 = await this.auth.verify();
      if (!isValid2) {
        throw new InvalidSignatureError(
          "Failed to verify GRVT credentials",
          "INVALID_CREDENTIALS",
          "grvt"
        );
      }
    }
    this._isReady = true;
  }
  // ==================== Market Data Methods ====================
  async fetchMarkets(params) {
    await this.rateLimiter.acquire("fetchMarkets");
    try {
      const response = await this.sdk.getAllInstruments();
      if (!response.result) {
        throw new PerpDEXError("Invalid API response", "INVALID_RESPONSE", "grvt");
      }
      let markets = this.normalizer.normalizeMarkets(response.result);
      if (params?.active !== void 0) {
        markets = markets.filter((m) => m.active === params.active);
      }
      return markets;
    } catch (error) {
      throw mapAxiosError(error);
    }
  }
  async fetchTicker(symbol) {
    await this.rateLimiter.acquire("fetchTicker");
    try {
      const grvtSymbol = this.normalizer.symbolFromCCXT(symbol);
      const response = await this.sdk.getTicker(grvtSymbol);
      if (!response.result) {
        throw new PerpDEXError("Invalid API response", "INVALID_RESPONSE", "grvt");
      }
      return this.normalizer.normalizeTicker(response.result);
    } catch (error) {
      throw mapAxiosError(error);
    }
  }
  async fetchOrderBook(symbol, params) {
    await this.rateLimiter.acquire("fetchOrderBook");
    try {
      const grvtSymbol = this.normalizer.symbolFromCCXT(symbol);
      const requestedLimit = params?.limit || 50;
      const depth = requestedLimit <= 10 ? 10 : requestedLimit <= 50 ? 50 : 100;
      const response = await this.sdk.getOrderBook(grvtSymbol, depth);
      if (!response.result) {
        throw new PerpDEXError("Invalid API response", "INVALID_RESPONSE", "grvt");
      }
      return this.normalizer.normalizeOrderBook(response.result);
    } catch (error) {
      throw mapAxiosError(error);
    }
  }
  async fetchTrades(symbol, params) {
    await this.rateLimiter.acquire("fetchTrades");
    try {
      const grvtSymbol = this.normalizer.symbolFromCCXT(symbol);
      const response = await this.sdk.getTradeHistory({
        instrument: grvtSymbol,
        limit: params?.limit || 100
      });
      if (!response.result) {
        throw new PerpDEXError("Invalid API response", "INVALID_RESPONSE", "grvt");
      }
      return this.normalizer.normalizeTrades(response.result);
    } catch (error) {
      throw mapAxiosError(error);
    }
  }
  /**
   * Fetch OHLCV (candlestick) data
   *
   * @param symbol - Symbol in unified format (e.g., "BTC/USDT:USDT")
   * @param timeframe - Candlestick timeframe
   * @param params - Optional parameters (since, until, limit)
   * @returns Array of OHLCV tuples [timestamp, open, high, low, close, volume]
   */
  async fetchOHLCV(symbol, timeframe = "1h", params) {
    await this.rateLimiter.acquire("fetchOHLCV");
    try {
      const grvtSymbol = this.normalizer.symbolFromCCXT(symbol);
      const intervalMap = {
        "1m": 60,
        "3m": 180,
        "5m": 300,
        "15m": 900,
        "30m": 1800,
        "1h": 3600,
        "2h": 7200,
        "4h": 14400,
        "6h": 21600,
        "8h": 28800,
        "12h": 43200,
        "1d": 86400,
        "3d": 259200,
        "1w": 604800,
        "1M": 2592e3
      };
      const interval = intervalMap[timeframe] || 3600;
      const now = Date.now();
      const defaultDuration = this.getDefaultDuration(timeframe);
      const startTime = params?.since ?? now - defaultDuration;
      const endTime = params?.until ?? now;
      const response = await this.sdk.getCandlestick({
        instrument: grvtSymbol,
        interval,
        start_time: startTime,
        end_time: endTime,
        limit: params?.limit
      });
      if (!response.result || !Array.isArray(response.result)) {
        return [];
      }
      return response.result.map((candle) => [
        candle.time || candle.t,
        parseFloat(candle.open || candle.o || "0"),
        parseFloat(candle.high || candle.h || "0"),
        parseFloat(candle.low || candle.l || "0"),
        parseFloat(candle.close || candle.c || "0"),
        parseFloat(candle.volume || candle.v || "0")
      ]);
    } catch (error) {
      throw mapAxiosError(error);
    }
  }
  /**
   * Get default duration based on timeframe for initial data fetch
   */
  getDefaultDuration(timeframe) {
    const durationMap = {
      "1m": 24 * 60 * 60 * 1e3,
      // 24 hours
      "3m": 3 * 24 * 60 * 60 * 1e3,
      // 3 days
      "5m": 5 * 24 * 60 * 60 * 1e3,
      // 5 days
      "15m": 7 * 24 * 60 * 60 * 1e3,
      // 7 days
      "30m": 14 * 24 * 60 * 60 * 1e3,
      // 14 days
      "1h": 30 * 24 * 60 * 60 * 1e3,
      // 30 days
      "2h": 60 * 24 * 60 * 60 * 1e3,
      // 60 days
      "4h": 90 * 24 * 60 * 60 * 1e3,
      // 90 days
      "6h": 120 * 24 * 60 * 60 * 1e3,
      // 120 days
      "8h": 180 * 24 * 60 * 60 * 1e3,
      // 180 days
      "12h": 365 * 24 * 60 * 60 * 1e3,
      // 1 year
      "1d": 365 * 24 * 60 * 60 * 1e3,
      // 1 year
      "3d": 2 * 365 * 24 * 60 * 60 * 1e3,
      // 2 years
      "1w": 3 * 365 * 24 * 60 * 60 * 1e3,
      // 3 years
      "1M": 5 * 365 * 24 * 60 * 60 * 1e3
      // 5 years
    };
    return durationMap[timeframe] || 30 * 24 * 60 * 60 * 1e3;
  }
  async fetchFundingRate(symbol) {
    await this.rateLimiter.acquire("fetchFundingRate");
    try {
      const grvtSymbol = this.normalizer.symbolFromCCXT(symbol);
      const response = await this.sdk.getFunding(grvtSymbol);
      if (!response.result || response.result.length === 0) {
        throw new PerpDEXError("Invalid API response", "INVALID_RESPONSE", "grvt");
      }
      const funding = response.result[0];
      if (!funding) {
        throw new PerpDEXError("No funding data available", "NO_FUNDING_DATA", "grvt");
      }
      const fundingTimestamp = funding.funding_time ? parseInt(funding.funding_time) : Date.now();
      const fundingIntervalHours = funding.funding_interval_hours ?? 8;
      const nextFundingTimestamp = fundingTimestamp + fundingIntervalHours * 60 * 60 * 1e3;
      return {
        symbol,
        fundingRate: parseFloat(funding.funding_rate ?? "0"),
        fundingTimestamp,
        nextFundingTimestamp,
        markPrice: parseFloat(funding.mark_price ?? "0"),
        indexPrice: 0,
        // Not provided in funding API
        fundingIntervalHours,
        info: funding
      };
    } catch (error) {
      throw mapAxiosError(error);
    }
  }
  // ==================== Trading Methods ====================
  async createOrder(request) {
    const validatedRequest = this.validateOrder(request);
    this.auth.requireAuth();
    await this.rateLimiter.acquire("createOrder");
    try {
      const grvtSymbol = this.normalizer.symbolFromCCXT(validatedRequest.symbol);
      const orderRequest = {
        instrument: grvtSymbol,
        order_type: this.mapOrderType(validatedRequest.type),
        side: validatedRequest.side === "buy" ? "BUY" : "SELL",
        size: validatedRequest.amount.toString(),
        price: validatedRequest.price?.toString() || "0",
        time_in_force: this.mapTimeInForce(validatedRequest.timeInForce),
        reduce_only: validatedRequest.reduceOnly || false,
        post_only: validatedRequest.postOnly || false,
        client_order_id: validatedRequest.clientOrderId
      };
      if (this.auth.getAddress()) {
        const payload = {
          instrument: grvtSymbol,
          order_type: orderRequest.order_type,
          side: orderRequest.side,
          size: orderRequest.size,
          price: orderRequest.price,
          time_in_force: orderRequest.time_in_force,
          reduce_only: orderRequest.reduce_only,
          post_only: orderRequest.post_only,
          nonce: this.auth.getNextNonce(),
          expiry: Date.now() + 6e4
          // 1 minute
        };
        const signature = await this.auth.createSignature(payload);
        orderRequest.signature = signature;
      }
      const response = await this.sdk.createOrder(orderRequest);
      if (!response.result) {
        throw new PerpDEXError("Invalid API response", "INVALID_RESPONSE", "grvt");
      }
      const sessionCookie = this.sdk.getSessionCookie();
      if (sessionCookie) {
        this.auth.setSessionCookie(sessionCookie);
      }
      return this.normalizer.normalizeOrder(response.result);
    } catch (error) {
      throw mapAxiosError(error);
    }
  }
  async cancelOrder(orderId, _symbol) {
    this.auth.requireAuth();
    await this.rateLimiter.acquire("cancelOrder");
    try {
      const response = await this.sdk.cancelOrder({ order_id: orderId });
      if (!response.result) {
        throw new PerpDEXError("Invalid API response", "INVALID_RESPONSE", "grvt");
      }
      return this.normalizer.normalizeOrder(response.result);
    } catch (error) {
      throw mapAxiosError(error);
    }
  }
  async cancelAllOrders(symbol) {
    this.auth.requireAuth();
    await this.rateLimiter.acquire("cancelAllOrders");
    try {
      const params = {};
      if (symbol) {
        params.instrument = this.normalizer.symbolFromCCXT(symbol);
      }
      await this.sdk.cancelAllOrders(params);
      return [];
    } catch (error) {
      throw mapAxiosError(error);
    }
  }
  async fetchOpenOrders(symbol) {
    this.auth.requireAuth();
    await this.rateLimiter.acquire("fetchOpenOrders");
    try {
      const params = {};
      if (symbol) {
        params.instrument = this.normalizer.symbolFromCCXT(symbol);
      }
      const response = await this.sdk.getOpenOrders(params);
      if (!response.result) {
        throw new PerpDEXError("Invalid API response", "INVALID_RESPONSE", "grvt");
      }
      return this.normalizer.normalizeOrders(response.result);
    } catch (error) {
      throw mapAxiosError(error);
    }
  }
  /**
   * Fetch order history - NOW IMPLEMENTED via SDK!
   */
  async fetchOrderHistory(symbol, _since, limit) {
    this.auth.requireAuth();
    await this.rateLimiter.acquire("fetchClosedOrders");
    try {
      const params = { limit: limit || 100 };
      if (symbol) {
        params.instrument = this.normalizer.symbolFromCCXT(symbol);
      }
      const response = await this.sdk.getOrderHistory(params);
      if (!response.result) {
        throw new PerpDEXError("Invalid API response", "INVALID_RESPONSE", "grvt");
      }
      return this.normalizer.normalizeOrders(response.result);
    } catch (error) {
      throw mapAxiosError(error);
    }
  }
  /**
   * Fetch user trade history - NOW IMPLEMENTED via SDK!
   */
  async fetchMyTrades(symbol, _since, limit) {
    this.auth.requireAuth();
    await this.rateLimiter.acquire("fetchMyTrades");
    try {
      const params = { limit: limit || 100 };
      if (symbol) {
        params.instrument = this.normalizer.symbolFromCCXT(symbol);
      }
      const response = await this.sdk.getFillHistory(params);
      if (!response.result) {
        throw new PerpDEXError("Invalid API response", "INVALID_RESPONSE", "grvt");
      }
      return this.normalizer.normalizeFills(response.result);
    } catch (error) {
      throw mapAxiosError(error);
    }
  }
  // ==================== Account Methods ====================
  async fetchPositions(symbols) {
    this.auth.requireAuth();
    await this.rateLimiter.acquire("fetchPositions");
    try {
      const response = await this.sdk.getPositions();
      if (!response.result) {
        throw new PerpDEXError("Invalid API response", "INVALID_RESPONSE", "grvt");
      }
      let positions = this.normalizer.normalizePositions(response.result);
      if (symbols && symbols.length > 0) {
        positions = positions.filter((p) => symbols.includes(p.symbol));
      }
      return positions;
    } catch (error) {
      throw mapAxiosError(error);
    }
  }
  async fetchBalance() {
    this.auth.requireAuth();
    await this.rateLimiter.acquire("fetchBalance");
    try {
      const response = await this.sdk.getSubAccountSummary();
      if (!response.result) {
        throw new PerpDEXError("Invalid API response", "INVALID_RESPONSE", "grvt");
      }
      const balances = response.result.spot_balances || [];
      return this.normalizer.normalizeBalances(balances);
    } catch (error) {
      throw mapAxiosError(error);
    }
  }
  // ==================== Helper Methods ====================
  mapOrderType(type) {
    const typeMap = {
      market: "MARKET",
      limit: "LIMIT",
      limitMaker: "LIMIT_MAKER"
    };
    return typeMap[type] || "LIMIT";
  }
  mapTimeInForce(tif) {
    if (!tif) return "GTC";
    const tifMap = {
      GTC: "GTC",
      IOC: "IOC",
      FOK: "FOK",
      PO: "POST_ONLY"
    };
    return tifMap[tif] || "GTC";
  }
  // ==================== Required BaseAdapter Methods ====================
  async fetchFundingRateHistory(_symbol, _since, _limit) {
    throw new PerpDEXError(
      "GRVT does not provide funding rate history via API",
      "NOT_SUPPORTED",
      "grvt"
    );
  }
  async setLeverage(symbol, leverage) {
    await this.rateLimiter.acquire("modifyOrder");
    try {
      const grvtSymbol = this.normalizer.symbolFromCCXT(symbol);
      await this.sdk.setInitialLeverage({
        instrument: grvtSymbol,
        leverage: leverage.toString()
      });
    } catch (error) {
      throw mapAxiosError(error);
    }
  }
  symbolToExchange(symbol) {
    return this.normalizer.symbolFromCCXT(symbol);
  }
  symbolFromExchange(exchangeSymbol) {
    return this.normalizer.symbolToCCXT(exchangeSymbol);
  }
  // ==================== WebSocket Methods ====================
  /**
   * Initialize WebSocket connection if not already initialized
   */
  async ensureWebSocket() {
    if (!this.ws) {
      const subAccountId = this.config.subAccountId;
      this.ws = new GRVTWebSocketWrapper({
        testnet: this.testnet,
        subAccountId,
        timeout: this.config.timeout
      });
      await this.ws.connect();
    }
    return this.ws;
  }
  /**
   * Watch order book updates in real-time
   *
   * @param symbol - Trading symbol (e.g., "BTC/USDT:USDT")
   * @param limit - Order book depth (default: 50)
   * @returns AsyncGenerator yielding OrderBook updates
   *
   * @example
   * ```typescript
   * for await (const orderBook of adapter.watchOrderBook('BTC/USDT:USDT')) {
   *   console.log('Best bid:', orderBook.bids[0]);
   *   console.log('Best ask:', orderBook.asks[0]);
   * }
   * ```
   */
  async *watchOrderBook(symbol, limit) {
    const ws = await this.ensureWebSocket();
    const depth = limit || 50;
    yield* ws.watchOrderBook(symbol, depth);
  }
  /**
   * Watch public trades in real-time
   *
   * @param symbol - Trading symbol
   * @returns AsyncGenerator yielding Trade updates
   *
   * @example
   * ```typescript
   * for await (const trade of adapter.watchTrades('BTC/USDT:USDT')) {
   *   console.log('Trade:', trade.price, trade.amount, trade.side);
   * }
   * ```
   */
  async *watchTrades(symbol) {
    const ws = await this.ensureWebSocket();
    yield* ws.watchTrades(symbol);
  }
  /**
   * Watch position updates in real-time
   *
   * @returns AsyncGenerator yielding Position array updates
   *
   * @example
   * ```typescript
   * for await (const positions of adapter.watchPositions()) {
   *   for (const position of positions) {
   *     console.log('Position:', position.symbol, position.size, position.unrealizedPnl);
   *   }
   * }
   * ```
   */
  async *watchPositions() {
    const ws = await this.ensureWebSocket();
    for await (const position of ws.watchPositions()) {
      yield [position];
    }
  }
  /**
   * Watch order updates in real-time
   *
   * @returns AsyncGenerator yielding Order array updates
   *
   * @example
   * ```typescript
   * for await (const orders of adapter.watchOrders()) {
   *   for (const order of orders) {
   *     console.log('Order update:', order.id, order.status, order.filled);
   *   }
   * }
   * ```
   */
  async *watchOrders() {
    const ws = await this.ensureWebSocket();
    for await (const order of ws.watchOrders()) {
      yield [order];
    }
  }
  /**
   * Watch ticker updates in real-time
   *
   * @param symbol - Trading symbol (e.g., "BTC/USDT:USDT")
   * @returns AsyncGenerator yielding Ticker updates
   *
   * @example
   * ```typescript
   * for await (const ticker of adapter.watchTicker('BTC/USDT:USDT')) {
   *   console.log('Price:', ticker.last);
   * }
   * ```
   */
  async *watchTicker(symbol) {
    const ws = await this.ensureWebSocket();
    yield* ws.watchTicker(symbol);
  }
  /**
   * Watch balance updates in real-time
   *
   * @returns AsyncGenerator yielding Balance array
   *
   * @example
   * ```typescript
   * for await (const balances of adapter.watchBalance()) {
   *   console.log('Balance update:', balances);
   * }
   * ```
   */
  async *watchBalance() {
    const ws = await this.ensureWebSocket();
    yield* ws.watchBalance();
  }
  /**
   * Watch user trades (fills) in real-time
   *
   * @param symbol - Optional symbol filter
   * @returns AsyncGenerator yielding Trade updates
   *
   * @example
   * ```typescript
   * for await (const trade of adapter.watchMyTrades()) {
   *   console.log('Fill:', trade.symbol, trade.side, trade.amount, '@', trade.price);
   * }
   * ```
   */
  async *watchMyTrades(symbol) {
    const ws = await this.ensureWebSocket();
    yield* ws.watchMyTrades(symbol);
  }
  /**
   * Close WebSocket connection
   */
  async disconnect() {
    if (this.ws) {
      this.ws.disconnect();
      this.ws = void 0;
    }
    this.auth.clearSessionCookie();
    this.sdk.clearSession();
    this._isReady = false;
  }
};

// src/adapters/paradex/constants.ts
var PARADEX_API_URLS = {
  mainnet: {
    rest: "https://api.prod.paradex.trade/v1",
    websocket: "wss://ws.prod.paradex.trade/v1"
  },
  testnet: {
    rest: "https://api.testnet.paradex.trade/v1",
    websocket: "wss://ws.testnet.paradex.trade/v1"
  }
};
var PARADEX_RATE_LIMITS = {
  default: {
    maxRequests: 1500,
    windowMs: 6e4
    // 1 minute
  },
  premium: {
    maxRequests: 5e3,
    windowMs: 6e4
    // 1 minute
  }
};
var PARADEX_ENDPOINT_WEIGHTS = {
  fetchMarkets: 1,
  fetchTicker: 1,
  fetchOrderBook: 2,
  fetchTrades: 2,
  fetchFundingRate: 1,
  fetchFundingRateHistory: 3,
  fetchPositions: 3,
  fetchBalance: 2,
  fetchOpenOrders: 3,
  fetchClosedOrders: 5,
  createOrder: 5,
  cancelOrder: 3,
  createBatchOrders: 15,
  cancelAllOrders: 10,
  modifyOrder: 5,
  fetchOrder: 2,
  fetchMyTrades: 5,
  setLeverage: 3
};
var PARADEX_ORDER_TYPES = {
  market: "MARKET",
  limit: "LIMIT",
  limitMaker: "LIMIT_MAKER"
};
var PARADEX_ORDER_SIDES = {
  buy: "BUY",
  sell: "SELL"
};
var PARADEX_TIME_IN_FORCE = {
  GTC: "GTC",
  IOC: "IOC",
  FOK: "FOK",
  POST_ONLY: "POST_ONLY"
};
var PARADEX_JWT_EXPIRY_BUFFER = 60;

// src/adapters/paradex/ParadexAuth.ts
var import_starknet = require("starknet");
var ParadexAuth = class {
  apiKey;
  starkPrivateKey;
  jwtToken;
  logger = new Logger("ParadexAuth");
  constructor(config) {
    this.apiKey = config.apiKey;
    this.starkPrivateKey = config.starkPrivateKey;
  }
  /**
   * Check if any credentials are configured
   */
  hasCredentials() {
    return !!(this.apiKey || this.starkPrivateKey);
  }
  /**
   * Require authentication for private operations
   * @throws Error if no credentials are configured
   */
  requireAuth() {
    if (!this.hasCredentials()) {
      throw new Error(
        "Authentication required. Provide apiKey or starkPrivateKey in config."
      );
    }
  }
  // ===========================================================================
  // IAuthStrategy Implementation
  // ===========================================================================
  /**
   * Sign a request with authentication headers
   *
   * @param request - Request parameters
   * @returns Authenticated request with headers
   */
  async sign(request) {
    const headers = {
      "Content-Type": "application/json"
    };
    if (this.apiKey) {
      headers["X-API-KEY"] = this.apiKey;
    }
    if (this.jwtToken && this.isTokenValid()) {
      headers["Authorization"] = `Bearer ${this.jwtToken.accessToken}`;
    }
    headers["X-Timestamp"] = Date.now().toString();
    if (this.requiresSignature(request.method, request.path)) {
      const signature = await this.signRequest(request);
      headers["X-Signature"] = signature;
    }
    return {
      ...request,
      headers
    };
  }
  /**
   * Verify authentication credentials
   *
   * @returns true if credentials are valid (or no credentials for public API)
   */
  async verify() {
    if (this.apiKey && this.apiKey.length === 0) {
      return false;
    }
    if (this.starkPrivateKey && this.starkPrivateKey.length === 0) {
      return false;
    }
    return true;
  }
  // ===========================================================================
  // JWT Token Management
  // ===========================================================================
  /**
   * Get current JWT token if valid
   *
   * @returns JWT access token or undefined
   */
  getJWTToken() {
    if (this.jwtToken && this.isTokenValid()) {
      return this.jwtToken.accessToken;
    }
    return void 0;
  }
  /**
   * Set JWT token from authentication response
   *
   * @param jwt - JWT response from Paradex API
   */
  setJWTToken(jwt) {
    this.jwtToken = {
      accessToken: jwt.access_token,
      expiresAt: Date.now() + jwt.expires_in * 1e3
    };
  }
  /**
   * Clear stored JWT token
   */
  clearJWTToken() {
    this.jwtToken = void 0;
  }
  // ===========================================================================
  // Header Generation
  // ===========================================================================
  /**
   * Get authentication headers (without signature)
   *
   * @returns Headers object
   */
  getHeaders() {
    const headers = {
      "Content-Type": "application/json"
    };
    if (this.apiKey) {
      headers["X-API-KEY"] = this.apiKey;
    }
    if (this.jwtToken && this.isTokenValid()) {
      headers["Authorization"] = `Bearer ${this.jwtToken.accessToken}`;
    }
    return headers;
  }
  /**
   * Get full authentication headers for a request
   *
   * @param method - HTTP method
   * @param path - API path
   * @param body - Optional request body
   * @returns Headers object with signature if required
   */
  async getAuthHeaders(method, path, body) {
    const request = await this.sign({ method, path, body });
    return request.headers || {};
  }
  // ===========================================================================
  // StarkNet Key Management
  // ===========================================================================
  /**
   * Get StarkNet private key
   *
   * @returns Private key or undefined
   */
  getStarkPrivateKey() {
    return this.starkPrivateKey;
  }
  /**
   * Get StarkNet public key derived from private key
   *
   * @returns Public key (address) or undefined
   */
  deriveStarkPublicKey() {
    return this.getAddress();
  }
  // ===========================================================================
  // Private Helper Methods
  // ===========================================================================
  /**
   * Check if current JWT token is valid
   *
   * @returns true if token exists and not expired
   */
  isTokenValid() {
    if (!this.jwtToken) {
      return false;
    }
    return Date.now() < this.jwtToken.expiresAt - PARADEX_JWT_EXPIRY_BUFFER * 1e3;
  }
  /**
   * Check if request requires StarkNet signature
   *
   * @param method - HTTP method
   * @param path - API path
   * @returns true if signature required
   */
  requiresSignature(_method, path) {
    const tradingPaths = [
      "/orders",
      "/orders/batch",
      "/orders/cancel",
      "/positions",
      "/transfer",
      "/withdraw"
    ];
    return tradingPaths.some((tradingPath) => path.includes(tradingPath));
  }
  /**
   * Sign request data with StarkNet ECDSA
   *
   * @param request - Request parameters
   * @returns Signature in format "0x{r},0x{s}"
   *
   * @throws {Error} If StarkNet private key not available
   */
  async signRequest(request) {
    if (!this.starkPrivateKey) {
      throw new Error("StarkNet private key required for signing requests");
    }
    try {
      const timestamp = Date.now();
      const message = this.createSignatureMessage(request, timestamp);
      const messageHash = import_starknet.hash.computeHashOnElements([message]);
      const signature = import_starknet.ec.starkCurve.sign(messageHash, this.starkPrivateKey);
      return `0x${signature.r.toString(16)},0x${signature.s.toString(16)}`;
    } catch (error) {
      throw new Error(`Failed to sign StarkNet request: ${error instanceof Error ? error.message : String(error)}`);
    }
  }
  /**
   * Create message for StarkNet signing
   *
   * @param request - Request parameters
   * @param timestamp - Request timestamp
   * @returns Message string to sign
   */
  createSignatureMessage(request, timestamp) {
    const method = request.method.toUpperCase();
    const path = request.path;
    const body = request.body ? JSON.stringify(request.body) : "";
    return `${method}${path}${timestamp}${body}`;
  }
  /**
   * Get StarkNet address from private key
   */
  getAddress() {
    if (!this.starkPrivateKey) {
      return void 0;
    }
    try {
      const publicKey = import_starknet.ec.starkCurve.getStarkKey(this.starkPrivateKey);
      return publicKey;
    } catch (error) {
      this.logger.error("Failed to derive StarkNet address", error instanceof Error ? error : void 0);
      return void 0;
    }
  }
};

// src/adapters/paradex/ParadexErrorMapper.ts
var PARADEX_CLIENT_ERRORS = {
  // Order Errors (1xxx)
  INVALID_ORDER: 1001,
  INSUFFICIENT_MARGIN: 1002,
  ORDER_NOT_FOUND: 1003,
  POSITION_NOT_FOUND: 1004,
  INVALID_SIZE: 1005,
  INVALID_PRICE: 1006,
  MIN_SIZE_NOT_MET: 1007,
  MAX_SIZE_EXCEEDED: 1008,
  PRICE_OUT_OF_RANGE: 1009,
  SELF_TRADE: 1010,
  ORDER_ALREADY_FILLED: 1011,
  ORDER_ALREADY_CANCELLED: 1012,
  REDUCE_ONLY_VIOLATION: 1013,
  POST_ONLY_VIOLATION: 1014,
  INVALID_TIME_IN_FORCE: 1015,
  // Market/Instrument Errors (1xxx)
  INVALID_MARKET: 1020,
  MARKET_NOT_ACTIVE: 1021,
  MARKET_CLOSED: 1022,
  TRADING_HALTED: 1023,
  // Leverage/Margin Errors (1xxx)
  INVALID_LEVERAGE: 1030,
  MAX_LEVERAGE_EXCEEDED: 1031,
  INSUFFICIENT_BALANCE: 1032,
  MAX_POSITION_EXCEEDED: 1033,
  // Authentication & Authorization (2xxx)
  INVALID_SIGNATURE: 2001,
  EXPIRED_AUTH: 2002,
  // JWT expired
  INVALID_API_KEY: 2003,
  UNAUTHORIZED: 2004,
  FORBIDDEN: 2005,
  INVALID_REQUEST: 2006,
  // Validation Errors (2xxx)
  INVALID_PARAMS: 2010,
  MISSING_REQUIRED_FIELD: 2011,
  INVALID_TIMESTAMP: 2012,
  NONCE_TOO_LOW: 2013,
  NONCE_TOO_HIGH: 2014
};
var PARADEX_RATE_LIMIT_ERROR = 4001;
var PARADEX_SERVER_ERRORS = {
  INTERNAL_ERROR: 5001,
  SERVICE_UNAVAILABLE: 5002,
  GATEWAY_TIMEOUT: 5003,
  DATABASE_ERROR: 5004,
  MATCHING_ENGINE_ERROR: 5005,
  SEQUENCER_ERROR: 5006,
  MAINTENANCE_MODE: 5007
};
var PARADEX_NETWORK_ERRORS = {
  ECONNRESET: "ECONNRESET",
  ETIMEDOUT: "ETIMEDOUT",
  ENOTFOUND: "ENOTFOUND",
  ECONNREFUSED: "ECONNREFUSED",
  ECONNABORTED: "ECONNABORTED",
  NETWORK_ERROR: "NETWORK_ERROR",
  WEBSOCKET_CLOSED: "WEBSOCKET_CLOSED",
  WEBSOCKET_ERROR: "WEBSOCKET_ERROR"
};
function isServerError2(code) {
  const numericCode = typeof code === "string" ? parseInt(code, 10) : code;
  if (isNaN(numericCode)) return false;
  return Object.values(PARADEX_SERVER_ERRORS).includes(numericCode) || numericCode >= 5e3 && numericCode < 6e3 || numericCode >= 500 && numericCode < 600;
}
function isNetworkError2(code) {
  return Object.values(PARADEX_NETWORK_ERRORS).includes(code);
}
function mapParadexError(errorCode, message, originalError) {
  const numericCode = typeof errorCode === "string" ? parseInt(errorCode, 10) : errorCode;
  const codeStr = errorCode.toString();
  if (numericCode === PARADEX_CLIENT_ERRORS.INVALID_SIGNATURE || numericCode === PARADEX_CLIENT_ERRORS.INVALID_API_KEY) {
    return new InvalidSignatureError(message, codeStr, "paradex", originalError);
  }
  if (numericCode === PARADEX_CLIENT_ERRORS.EXPIRED_AUTH) {
    return new ExpiredAuthError(message, codeStr, "paradex", originalError);
  }
  if (numericCode === PARADEX_CLIENT_ERRORS.UNAUTHORIZED || numericCode === PARADEX_CLIENT_ERRORS.FORBIDDEN) {
    return new InsufficientPermissionsError(message, codeStr, "paradex", originalError);
  }
  if (numericCode === PARADEX_CLIENT_ERRORS.INSUFFICIENT_MARGIN || numericCode === PARADEX_CLIENT_ERRORS.INSUFFICIENT_BALANCE) {
    return new InsufficientMarginError(message, codeStr, "paradex", originalError);
  }
  if (numericCode === PARADEX_CLIENT_ERRORS.ORDER_NOT_FOUND) {
    return new OrderNotFoundError(message, codeStr, "paradex", originalError);
  }
  if (numericCode === PARADEX_CLIENT_ERRORS.POSITION_NOT_FOUND) {
    return new PositionNotFoundError(message, codeStr, "paradex", originalError);
  }
  if (numericCode === PARADEX_CLIENT_ERRORS.INVALID_ORDER || numericCode === PARADEX_CLIENT_ERRORS.INVALID_SIZE || numericCode === PARADEX_CLIENT_ERRORS.INVALID_PRICE || numericCode === PARADEX_CLIENT_ERRORS.MIN_SIZE_NOT_MET || numericCode === PARADEX_CLIENT_ERRORS.MAX_SIZE_EXCEEDED || numericCode === PARADEX_CLIENT_ERRORS.PRICE_OUT_OF_RANGE || numericCode === PARADEX_CLIENT_ERRORS.SELF_TRADE || numericCode === PARADEX_CLIENT_ERRORS.ORDER_ALREADY_FILLED || numericCode === PARADEX_CLIENT_ERRORS.ORDER_ALREADY_CANCELLED || numericCode === PARADEX_CLIENT_ERRORS.REDUCE_ONLY_VIOLATION || numericCode === PARADEX_CLIENT_ERRORS.POST_ONLY_VIOLATION || numericCode === PARADEX_CLIENT_ERRORS.INVALID_TIME_IN_FORCE || numericCode === PARADEX_CLIENT_ERRORS.INVALID_MARKET || numericCode === PARADEX_CLIENT_ERRORS.MARKET_NOT_ACTIVE || numericCode === PARADEX_CLIENT_ERRORS.MARKET_CLOSED || numericCode === PARADEX_CLIENT_ERRORS.TRADING_HALTED || numericCode === PARADEX_CLIENT_ERRORS.INVALID_LEVERAGE || numericCode === PARADEX_CLIENT_ERRORS.MAX_LEVERAGE_EXCEEDED || numericCode === PARADEX_CLIENT_ERRORS.MAX_POSITION_EXCEEDED) {
    return new InvalidOrderError(message, codeStr, "paradex", originalError);
  }
  if (numericCode === PARADEX_RATE_LIMIT_ERROR) {
    const retryAfter = extractRetryAfter2(originalError);
    return new RateLimitError(message, codeStr, "paradex", retryAfter, originalError);
  }
  if (isServerError2(numericCode) || isNetworkError2(codeStr)) {
    return new ExchangeUnavailableError(message, codeStr, "paradex", originalError);
  }
  return new PerpDEXError(message, codeStr, "paradex", originalError);
}
function extractParadexError(response) {
  if (!response) {
    return { code: "UNKNOWN_ERROR", message: "Unknown error occurred" };
  }
  const errorObj = response.error || response;
  if (typeof errorObj === "string") {
    return { code: "UNKNOWN_ERROR", message: errorObj };
  }
  const code = errorObj.code?.toString() || "UNKNOWN_ERROR";
  const message = errorObj.message || errorObj.error || "Unknown error occurred";
  return { code, message };
}
function mapHttpError2(status, statusText, responseData) {
  if (responseData && (responseData.error || responseData.code)) {
    const { code, message } = extractParadexError(responseData);
    return mapParadexError(code, message, responseData);
  }
  if (status === 401) {
    return new InvalidSignatureError(
      `Unauthorized: ${statusText}`,
      "UNAUTHORIZED",
      "paradex"
    );
  }
  if (status === 403) {
    return new InsufficientPermissionsError(
      `Forbidden: ${statusText}`,
      "FORBIDDEN",
      "paradex"
    );
  }
  if (status === 404) {
    return new OrderNotFoundError(`Not found: ${statusText}`, "NOT_FOUND", "paradex");
  }
  if (status === 429) {
    const retryAfter = extractRetryAfter2(responseData);
    return new RateLimitError(
      `Rate limit exceeded: ${statusText}`,
      PARADEX_RATE_LIMIT_ERROR.toString(),
      "paradex",
      retryAfter
    );
  }
  if (status >= 400 && status < 500) {
    return new InvalidOrderError(
      `Client error (${status}): ${statusText}`,
      `HTTP_${status}`,
      "paradex"
    );
  }
  if (status === 503) {
    return new ExchangeUnavailableError(
      `Service unavailable: ${statusText}`,
      "SERVICE_UNAVAILABLE",
      "paradex"
    );
  }
  if (status >= 500) {
    return new ExchangeUnavailableError(
      `Server error (${status}): ${statusText}`,
      `HTTP_${status}`,
      "paradex"
    );
  }
  return new PerpDEXError(
    `HTTP error (${status}): ${statusText}`,
    `HTTP_${status}`,
    "paradex"
  );
}
function mapAxiosError2(error) {
  if (error.response) {
    const { status, statusText, data } = error.response;
    return mapHttpError2(status, statusText, data);
  }
  if (error.code && isNetworkError2(error.code)) {
    return new ExchangeUnavailableError(
      error.message || "Network error occurred",
      error.code,
      "paradex",
      error
    );
  }
  if (error.code === "ECONNABORTED") {
    return new ExchangeUnavailableError(
      "Request timeout",
      "ETIMEDOUT",
      "paradex",
      error
    );
  }
  return new PerpDEXError(
    error.message || "Unknown error occurred",
    error.code || "UNKNOWN_ERROR",
    "paradex",
    error
  );
}
function extractRetryAfter2(error) {
  if (!error) return void 0;
  if (error.headers && error.headers["retry-after"]) {
    const value = parseInt(error.headers["retry-after"], 10);
    return isNaN(value) ? void 0 : value;
  }
  if (error.response && error.response.headers && error.response.headers["retry-after"]) {
    const value = parseInt(error.response.headers["retry-after"], 10);
    return isNaN(value) ? void 0 : value;
  }
  if (error.retryAfter || error.retry_after) {
    const value = parseInt(error.retryAfter || error.retry_after, 10);
    return isNaN(value) ? void 0 : value;
  }
  return void 0;
}

// src/adapters/paradex/ParadexHTTPClient.ts
var ParadexHTTPClient = class {
  baseUrl;
  auth;
  timeout;
  enableLogging;
  logger = new Logger("ParadexHTTPClient");
  constructor(config) {
    this.baseUrl = config.baseUrl;
    this.auth = config.auth;
    this.timeout = config.timeout || 3e4;
    this.enableLogging = config.enableLogging ?? false;
  }
  /**
   * Make GET request
   *
   * @param path - API endpoint path (e.g., "/markets")
   * @param params - Query parameters
   * @returns Response data
   */
  async get(path, params) {
    let fullPath = path;
    if (params) {
      const searchParams = new URLSearchParams();
      Object.entries(params).forEach(([key, value]) => {
        searchParams.append(key, value.toString());
      });
      const queryString = searchParams.toString();
      fullPath = `${path}${queryString ? `?${queryString}` : ""}`;
    }
    return this.request("GET", fullPath);
  }
  /**
   * Make POST request
   *
   * @param path - API endpoint path
   * @param body - Request body
   * @returns Response data
   */
  async post(path, body) {
    return this.request("POST", path, body);
  }
  /**
   * Make PUT request
   *
   * @param path - API endpoint path
   * @param body - Request body
   * @returns Response data
   */
  async put(path, body) {
    return this.request("PUT", path, body);
  }
  /**
   * Make DELETE request
   *
   * @param path - API endpoint path
   * @param params - Query parameters or body
   * @returns Response data
   */
  async delete(path, params) {
    let fullPath = path;
    if (params && Object.values(params).every((v) => typeof v === "string" || typeof v === "number")) {
      const searchParams = new URLSearchParams();
      Object.entries(params).forEach(([key, value]) => {
        searchParams.append(key, String(value));
      });
      const queryString = searchParams.toString();
      fullPath = `${path}${queryString ? `?${queryString}` : ""}`;
      return this.request("DELETE", fullPath);
    }
    return this.request("DELETE", fullPath);
  }
  /**
   * Make HTTP request
   *
   * @param method - HTTP method
   * @param path - API endpoint path
   * @param body - Optional request body
   * @returns Response data
   *
   * @throws {PerpDEXError} On network or API errors
   */
  async request(method, path, body) {
    const url = `${this.baseUrl}${path}`;
    const authenticatedRequest = await this.auth.sign({
      method,
      path,
      body
    });
    const requestInit = {
      method,
      headers: authenticatedRequest.headers,
      body: body ? JSON.stringify(body) : void 0,
      signal: this.createTimeoutSignal(this.timeout)
    };
    if (this.enableLogging) {
      this.logger.debug(`${method} ${path}`, { body: body || void 0 });
    }
    try {
      const response = await fetch(url, requestInit);
      return await this.handleResponse(response);
    } catch (error) {
      if (error instanceof Error && error.name === "AbortError") {
        throw new PerpDEXError(
          `Request timeout after ${this.timeout}ms`,
          "ETIMEDOUT",
          "paradex",
          error
        );
      }
      if (error instanceof Error && "code" in error && typeof error.code === "string") {
        throw mapAxiosError2(error);
      }
      if (error instanceof PerpDEXError) {
        throw error;
      }
      const message = error instanceof Error ? error.message : "Request failed";
      throw new PerpDEXError(
        message,
        "UNKNOWN_ERROR",
        "paradex",
        error
      );
    }
  }
  /**
   * Handle HTTP response
   *
   * @param response - Fetch response
   * @returns Response data
   *
   * @throws {PerpDEXError} On HTTP errors
   */
  async handleResponse(response) {
    let data;
    try {
      data = await response.json();
    } catch {
      data = null;
    }
    if (!response.ok) {
      if (this.enableLogging) {
        this.logger.error(
          `Error ${response.status}: ${response.statusText}`,
          void 0,
          { data }
        );
      }
      throw mapHttpError2(response.status, response.statusText, data);
    }
    if (this.enableLogging) {
      this.logger.debug("Response", { data });
    }
    return data;
  }
  /**
   * Create timeout signal for fetch
   *
   * @param timeout - Timeout in milliseconds
   * @returns AbortSignal
   */
  createTimeoutSignal(timeout) {
    const controller = new AbortController();
    setTimeout(() => controller.abort(), timeout);
    return controller.signal;
  }
  /**
   * Get base URL
   */
  get url() {
    return this.baseUrl;
  }
  /**
   * Get auth strategy
   */
  get authStrategy() {
    return this.auth;
  }
};

// src/adapters/paradex/ParadexNormalizer.ts
var ParadexNormalizer = class {
  // ===========================================================================
  // Symbol Conversion
  // ===========================================================================
  /**
   * Convert Paradex symbol to CCXT format
   *
   * @param paradexSymbol - Paradex symbol (e.g., "BTC-USD-PERP", "ETH-USDC-PERP")
   * @returns CCXT formatted symbol (e.g., "BTC/USD:USD")
   *
   * @example
   * ```typescript
   * normalizer.symbolToCCXT('BTC-USD-PERP');  // "BTC/USD:USD"
   * normalizer.symbolToCCXT('ETH-USDC-PERP'); // "ETH/USDC:USDC"
   * normalizer.symbolToCCXT('BTC-USD');       // "BTC/USD" (spot)
   * ```
   */
  symbolToCCXT(paradexSymbol) {
    const parts = paradexSymbol.split("-");
    if (parts.length === 3 && parts[2] === "PERP") {
      const base = parts[0];
      const quote = parts[1];
      return `${base}/${quote}:${quote}`;
    }
    return paradexSymbol.replace("-", "/");
  }
  /**
   * Convert CCXT symbol to Paradex format
   *
   * @param ccxtSymbol - CCXT formatted symbol (e.g., "BTC/USD:USD")
   * @returns Paradex symbol (e.g., "BTC-USD-PERP")
   *
   * @example
   * ```typescript
   * normalizer.symbolFromCCXT('BTC/USD:USD');    // "BTC-USD-PERP"
   * normalizer.symbolFromCCXT('ETH/USDC:USDC');  // "ETH-USDC-PERP"
   * normalizer.symbolFromCCXT('BTC/USD');        // "BTC-USD" (spot)
   * ```
   */
  symbolFromCCXT(ccxtSymbol) {
    const parts = ccxtSymbol.split(":");
    if (parts.length === 2) {
      const [pair = ""] = parts;
      const [base = "", quote = ""] = pair.split("/");
      return `${base}-${quote}-PERP`;
    }
    return ccxtSymbol.replace("/", "-");
  }
  // ===========================================================================
  // Precision-Safe Numeric Conversions
  // ===========================================================================
  /**
   * Count decimal places in a string number
   *
   * @param value - String number (e.g., "0.001")
   * @returns Number of decimal places (e.g., 3)
   */
  countDecimals(value) {
    const parts = value.split(".");
    return parts.length === 2 && parts[1] ? parts[1].length : 0;
  }
  // ===========================================================================
  // Market Normalization
  // ===========================================================================
  /**
   * Normalize Paradex market to unified format
   *
   * Handles both old SDK type format and actual API response format:
   * - API uses: order_size_increment, price_tick_size, min_notional, fee_config, delta1_cross_margin_params
   * - SDK type uses: step_size, tick_size, min_order_size, maker_fee_rate, taker_fee_rate, max_leverage
   *
   * @param paradexMarket - Paradex market data from API
   * @returns Unified market
   */
  normalizeMarket(paradexMarket) {
    const symbol = this.symbolToCCXT(paradexMarket.symbol);
    const tickSize = paradexMarket.price_tick_size || paradexMarket.tick_size || "0.01";
    const stepSize = paradexMarket.order_size_increment || paradexMarket.step_size || "0.001";
    const minOrderSize = paradexMarket.min_notional || paradexMarket.min_order_size || "100";
    let makerFee = 3e-5;
    let takerFee = 2e-4;
    if (paradexMarket.fee_config?.api_fee) {
      makerFee = parseFloat(paradexMarket.fee_config.api_fee.maker_fee?.fee || "0.00003");
      takerFee = parseFloat(paradexMarket.fee_config.api_fee.taker_fee?.fee || "0.0002");
    } else if (paradexMarket.maker_fee_rate) {
      makerFee = parseFloat(paradexMarket.maker_fee_rate);
      takerFee = parseFloat(paradexMarket.taker_fee_rate);
    }
    let maxLeverage = 50;
    if (paradexMarket.delta1_cross_margin_params?.imf_base) {
      const imfBase = parseFloat(paradexMarket.delta1_cross_margin_params.imf_base);
      if (imfBase > 0) {
        maxLeverage = Math.round(1 / imfBase);
      }
    } else if (paradexMarket.max_leverage) {
      maxLeverage = parseFloat(paradexMarket.max_leverage);
    }
    const isActive = paradexMarket.is_active ?? (paradexMarket.open_at ? paradexMarket.open_at <= Date.now() : true);
    return {
      id: paradexMarket.symbol,
      symbol,
      base: paradexMarket.base_currency,
      quote: paradexMarket.quote_currency,
      settle: paradexMarket.settlement_currency,
      active: isActive,
      minAmount: parseFloat(minOrderSize),
      pricePrecision: this.countDecimals(tickSize),
      amountPrecision: this.countDecimals(stepSize),
      priceTickSize: parseFloat(tickSize),
      amountStepSize: parseFloat(stepSize),
      makerFee,
      takerFee,
      maxLeverage,
      fundingIntervalHours: paradexMarket.funding_period_hours || 8,
      info: paradexMarket
    };
  }
  /**
   * Batch normalize markets
   */
  normalizeMarkets(paradexMarkets) {
    return paradexMarkets.map((m) => this.normalizeMarket(m));
  }
  // ===========================================================================
  // Order Normalization
  // ===========================================================================
  /**
   * Map Paradex order type to unified
   */
  normalizeOrderType(paradexType) {
    switch (paradexType) {
      case "MARKET":
        return "market";
      case "LIMIT":
      case "LIMIT_MAKER":
        return "limit";
      default:
        return "limit";
    }
  }
  /**
   * Map Paradex order side to unified
   */
  normalizeOrderSide(paradexSide) {
    return paradexSide === "BUY" ? "buy" : "sell";
  }
  /**
   * Map Paradex order status to unified
   */
  normalizeOrderStatus(paradexStatus) {
    const statusMap = {
      PENDING: "open",
      OPEN: "open",
      PARTIAL: "partiallyFilled",
      FILLED: "filled",
      CANCELLED: "canceled",
      REJECTED: "rejected"
    };
    return statusMap[paradexStatus] ?? "open";
  }
  /**
   * Map Paradex time in force to unified
   */
  normalizeTimeInForce(paradexTif) {
    switch (paradexTif) {
      case "GTC":
        return "GTC";
      case "IOC":
        return "IOC";
      case "FOK":
        return "FOK";
      case "POST_ONLY":
        return "PO";
      default:
        return "GTC";
    }
  }
  /**
   * Normalize Paradex order to unified format
   */
  normalizeOrder(paradexOrder) {
    const symbol = this.symbolToCCXT(paradexOrder.market);
    return {
      id: paradexOrder.id,
      clientOrderId: paradexOrder.client_id,
      symbol,
      type: this.normalizeOrderType(paradexOrder.type),
      side: this.normalizeOrderSide(paradexOrder.side),
      amount: parseFloat(paradexOrder.size),
      price: paradexOrder.price ? parseFloat(paradexOrder.price) : void 0,
      filled: parseFloat(paradexOrder.filled_size),
      remaining: parseFloat(paradexOrder.size) - parseFloat(paradexOrder.filled_size),
      averagePrice: paradexOrder.avg_fill_price ? parseFloat(paradexOrder.avg_fill_price) : void 0,
      status: this.normalizeOrderStatus(paradexOrder.status),
      timeInForce: this.normalizeTimeInForce(paradexOrder.time_in_force),
      postOnly: paradexOrder.post_only,
      reduceOnly: paradexOrder.reduce_only,
      timestamp: paradexOrder.created_at,
      lastUpdateTimestamp: paradexOrder.updated_at,
      info: paradexOrder
    };
  }
  /**
   * Batch normalize orders
   */
  normalizeOrders(paradexOrders) {
    return paradexOrders.map((o) => this.normalizeOrder(o));
  }
  // ===========================================================================
  // Position Normalization
  // ===========================================================================
  /**
   * Normalize Paradex position to unified format
   */
  normalizePosition(paradexPosition) {
    const symbol = this.symbolToCCXT(paradexPosition.market);
    const size = parseFloat(paradexPosition.size);
    const side = paradexPosition.side === "LONG" ? "long" : "short";
    return {
      symbol,
      side,
      marginMode: "cross",
      // Paradex uses cross margin
      size: Math.abs(size),
      entryPrice: parseFloat(paradexPosition.entry_price),
      markPrice: parseFloat(paradexPosition.mark_price),
      liquidationPrice: paradexPosition.liquidation_price ? parseFloat(paradexPosition.liquidation_price) : 0,
      unrealizedPnl: parseFloat(paradexPosition.unrealized_pnl),
      realizedPnl: parseFloat(paradexPosition.realized_pnl),
      margin: parseFloat(paradexPosition.margin),
      leverage: parseFloat(paradexPosition.leverage),
      maintenanceMargin: parseFloat(paradexPosition.margin) * 0.025,
      // Estimate 2.5%
      marginRatio: 0,
      // Not provided by Paradex
      timestamp: paradexPosition.last_updated,
      info: paradexPosition
    };
  }
  /**
   * Batch normalize positions
   */
  normalizePositions(paradexPositions) {
    return paradexPositions.map((p) => this.normalizePosition(p));
  }
  // ===========================================================================
  // Balance Normalization
  // ===========================================================================
  /**
   * Normalize Paradex balance to unified format
   */
  normalizeBalance(paradexBalance) {
    return {
      currency: paradexBalance.asset,
      total: parseFloat(paradexBalance.total),
      free: parseFloat(paradexBalance.available),
      used: parseFloat(paradexBalance.locked),
      info: paradexBalance
    };
  }
  /**
   * Batch normalize balances
   */
  normalizeBalances(paradexBalances) {
    return paradexBalances.map((b) => this.normalizeBalance(b));
  }
  // ===========================================================================
  // Order Book Normalization
  // ===========================================================================
  /**
   * Normalize Paradex order book to unified format
   */
  normalizeOrderBook(paradexOrderBook) {
    return {
      symbol: this.symbolToCCXT(paradexOrderBook.market),
      exchange: "paradex",
      bids: paradexOrderBook.bids.map(([price, size]) => [
        parseFloat(price),
        parseFloat(size)
      ]),
      asks: paradexOrderBook.asks.map(([price, size]) => [
        parseFloat(price),
        parseFloat(size)
      ]),
      timestamp: paradexOrderBook.timestamp
    };
  }
  // ===========================================================================
  // Trade Normalization
  // ===========================================================================
  /**
   * Normalize Paradex trade to unified format
   */
  normalizeTrade(paradexTrade) {
    const price = parseFloat(paradexTrade.price);
    const amount = parseFloat(paradexTrade.size);
    return {
      id: paradexTrade.id,
      symbol: this.symbolToCCXT(paradexTrade.market),
      side: this.normalizeOrderSide(paradexTrade.side),
      price,
      amount,
      cost: price * amount,
      timestamp: paradexTrade.timestamp,
      info: paradexTrade
    };
  }
  /**
   * Batch normalize trades
   */
  normalizeTrades(paradexTrades) {
    return paradexTrades.map((t) => this.normalizeTrade(t));
  }
  // ===========================================================================
  // Ticker Normalization
  // ===========================================================================
  /**
   * Normalize Paradex ticker to unified format
   */
  normalizeTicker(paradexTicker) {
    const last = parseFloat(paradexTicker.last_price);
    const change = parseFloat(paradexTicker.price_change_24h);
    const percentage = parseFloat(paradexTicker.price_change_percent_24h);
    return {
      symbol: this.symbolToCCXT(paradexTicker.market),
      last,
      open: last - change,
      close: last,
      bid: parseFloat(paradexTicker.bid),
      ask: parseFloat(paradexTicker.ask),
      high: parseFloat(paradexTicker.high_24h),
      low: parseFloat(paradexTicker.low_24h),
      change,
      percentage,
      baseVolume: parseFloat(paradexTicker.volume_24h),
      quoteVolume: 0,
      // Not provided by Paradex
      timestamp: paradexTicker.timestamp,
      info: paradexTicker
    };
  }
  /**
   * Batch normalize tickers
   */
  normalizeTickers(paradexTickers) {
    return paradexTickers.map((t) => this.normalizeTicker(t));
  }
  // ===========================================================================
  // Funding Rate Normalization
  // ===========================================================================
  /**
   * Normalize Paradex funding rate to unified format
   */
  normalizeFundingRate(paradexFunding) {
    return {
      symbol: this.symbolToCCXT(paradexFunding.market),
      fundingRate: parseFloat(paradexFunding.rate),
      fundingTimestamp: paradexFunding.timestamp,
      markPrice: parseFloat(paradexFunding.mark_price),
      indexPrice: parseFloat(paradexFunding.index_price),
      nextFundingTimestamp: paradexFunding.next_funding_time,
      fundingIntervalHours: 8,
      info: paradexFunding
    };
  }
  /**
   * Batch normalize funding rates
   */
  normalizeFundingRates(paradexFundingRates) {
    return paradexFundingRates.map((f) => this.normalizeFundingRate(f));
  }
  // ===========================================================================
  // Reverse Conversion (To Paradex Format)
  // ===========================================================================
  /**
   * Convert unified order type to Paradex format
   *
   * @param type - Unified order type
   * @param postOnly - Post-only flag
   * @returns Paradex order type
   */
  toParadexOrderType(type, postOnly) {
    if (type === "market") {
      return PARADEX_ORDER_TYPES.market;
    }
    if (postOnly) {
      return PARADEX_ORDER_TYPES.limitMaker;
    }
    return PARADEX_ORDER_TYPES.limit;
  }
  /**
   * Convert unified order side to Paradex format
   *
   * @param side - Unified order side
   * @returns Paradex order side
   */
  toParadexOrderSide(side) {
    return side === "buy" ? PARADEX_ORDER_SIDES.buy : PARADEX_ORDER_SIDES.sell;
  }
  /**
   * Convert unified time in force to Paradex format
   *
   * @param tif - Unified time in force
   * @param postOnly - Post-only flag
   * @returns Paradex time in force
   */
  toParadexTimeInForce(tif, postOnly) {
    if (postOnly) {
      return PARADEX_TIME_IN_FORCE.POST_ONLY;
    }
    switch (tif) {
      case "IOC":
        return PARADEX_TIME_IN_FORCE.IOC;
      case "FOK":
        return PARADEX_TIME_IN_FORCE.FOK;
      case "PO":
        return PARADEX_TIME_IN_FORCE.POST_ONLY;
      case "GTC":
      default:
        return PARADEX_TIME_IN_FORCE.GTC;
    }
  }
};

// src/adapters/paradex/ParadexParaclearWrapper.ts
var import_sdk = require("@paradex/sdk");
var ParadexParaclearWrapper = class {
  account;
  config;
  provider;
  testnet;
  constructor(config = {}) {
    this.testnet = config.testnet ?? false;
  }
  /**
   * Initialize Paraclear account from Ethereum signer
   *
   * @param ethersSigner - Ethers.js signer (v5 or v6)
   * @returns void
   *
   * @throws {PerpDEXError} If initialization fails
   *
   * @example
   * ```typescript
   * import { ethers } from 'ethers';
   *
   * const wallet = new ethers.Wallet(privateKey);
   * await paraclear.initializeAccount(wallet);
   * ```
   */
  async initializeAccount(ethersSigner) {
    try {
      const env = this.testnet ? "testnet" : "prod";
      this.config = await import_sdk.Config.fetchConfig(env);
      const signer = import_sdk.Signer.ethersSignerAdapter(ethersSigner);
      this.provider = new import_sdk.ParaclearProvider.DefaultProvider(
        this.config.paradexFullNodeRpcUrl
      );
      this.account = await import_sdk.Account.fromEthSigner({
        provider: this.provider,
        // Safe: just created above
        config: this.config,
        signer
      });
    } catch (error) {
      throw new PerpDEXError(
        `Failed to initialize Paraclear account: ${error instanceof Error ? error.message : String(error)}`,
        "PARACLEAR_INIT_ERROR",
        "paradex",
        error
      );
    }
  }
  /**
   * Get Paraclear account
   *
   * @returns Account or undefined if not initialized
   */
  getAccount() {
    return this.account;
  }
  /**
   * Get token balance from Paraclear
   *
   * @param token - Token symbol (e.g., "USDC", "ETH")
   * @returns Balance as decimal string
   *
   * @throws {PerpDEXError} If account not initialized or query fails
   *
   * @example
   * ```typescript
   * const balance = await paraclear.getTokenBalance('USDC');
   * console.log('Balance:', balance); // "1000.45"
   * ```
   */
  async getTokenBalance(token) {
    this.ensureInitialized();
    try {
      const result = await import_sdk.Paraclear.getTokenBalance({
        config: this.config,
        provider: this.provider,
        account: this.account,
        token
      });
      return result.size;
    } catch (error) {
      throw new PerpDEXError(
        `Failed to get token balance for ${token}: ${error instanceof Error ? error.message : String(error)}`,
        "PARACLEAR_BALANCE_ERROR",
        "paradex",
        error
      );
    }
  }
  /**
   * Get all token balances
   *
   * @returns Record of token symbol to balance
   *
   * @throws {PerpDEXError} If account not initialized
   *
   * @example
   * ```typescript
   * const balances = await paraclear.getAllBalances();
   * // { "USDC": "1000.45", "ETH": "0.5" }
   * ```
   */
  async getAllBalances() {
    this.ensureInitialized();
    const balances = {};
    try {
      const tokens = Object.keys(this.config.bridgedTokens);
      for (const token of tokens) {
        const balance = await this.getTokenBalance(token);
        balances[token] = balance;
      }
      return balances;
    } catch (error) {
      throw new PerpDEXError(
        `Failed to get all balances: ${error instanceof Error ? error.message : String(error)}`,
        "PARACLEAR_BALANCE_ERROR",
        "paradex",
        error
      );
    }
  }
  /**
   * Check socialized loss status
   *
   * Socialized losses occur when Paradex Insurance Fund is bankrupt.
   * When active, withdrawals receive less than the requested amount.
   *
   * @returns Socialized loss factor (0 if not active)
   *
   * @throws {PerpDEXError} If query fails
   *
   * @example
   * ```typescript
   * const { active, factor } = await paraclear.checkSocializedLoss();
   * if (active) {
   *   console.log('Loss factor:', factor); // "0.05" = 5%
   * }
   * ```
   */
  async checkSocializedLoss() {
    this.ensureInitialized();
    try {
      const result = await import_sdk.Paraclear.getSocializedLossFactor({
        config: this.config,
        provider: this.provider
      });
      const factor = parseFloat(result.socializedLossFactor);
      return {
        active: factor > 0,
        factor: result.socializedLossFactor
      };
    } catch (error) {
      throw new PerpDEXError(
        `Failed to check socialized loss: ${error instanceof Error ? error.message : String(error)}`,
        "PARACLEAR_SOCIALIZED_LOSS_ERROR",
        "paradex",
        error
      );
    }
  }
  /**
   * Calculate receivable amount after socialized loss
   *
   * @param token - Token symbol
   * @param amount - Requested withdrawal amount (decimal string)
   * @returns Receivable amount and loss factor
   *
   * @throws {PerpDEXError} If calculation fails
   *
   * @example
   * ```typescript
   * const result = await paraclear.calculateReceivableAmount('USDC', '100.0');
   * console.log('Will receive:', result.receivableAmount); // "95.0" if 5% loss
   * console.log('Loss:', result.socializedLoss); // "0.05"
   * ```
   */
  async calculateReceivableAmount(token, amount) {
    this.ensureInitialized();
    try {
      const result = await import_sdk.Paraclear.getReceivableAmount({
        config: this.config,
        provider: this.provider,
        token,
        amount
      });
      return {
        receivableAmount: result.receivableAmount,
        receivableAmountChain: result.receivableAmountChain,
        socializedLoss: result.socializedLossFactor
      };
    } catch (error) {
      throw new PerpDEXError(
        `Failed to calculate receivable amount: ${error instanceof Error ? error.message : String(error)}`,
        "PARACLEAR_CALCULATION_ERROR",
        "paradex",
        error
      );
    }
  }
  /**
   * Withdraw funds from Paraclear
   *
   * IMPORTANT: This creates an on-chain transaction on StarkNet.
   * You must provide a bridge call to transfer funds to L1.
   *
   * @param token - Token symbol
   * @param amount - Amount to withdraw (decimal string)
   * @param bridgeCall - StarkNet bridge call (or multiple calls)
   * @returns Transaction hash and receivable amount
   *
   * @throws {PerpDEXError} If withdrawal fails
   *
   * @example
   * ```typescript
   * import * as Starknet from 'starknet';
   *
   * // Calculate receivable amount first
   * const { receivableAmountChain } = await paraclear.calculateReceivableAmount(
   *   'USDC',
   *   '100.0'
   * );
   *
   * // Create bridge call
   * const bridgeCall: Starknet.Call = {
   *   contractAddress: config.bridgedTokens['USDC'].l2BridgeAddress,
   *   entrypoint: 'initiate_withdraw',
   *   calldata: [
   *     recipientAddress,
   *     receivableAmountChain,
   *     '0', // Amount high (for uint256)
   *   ],
   * };
   *
   * // Execute withdrawal
   * const tx = await paraclear.withdraw('USDC', '100.0', bridgeCall);
   * console.log('TX Hash:', tx.transactionHash);
   * ```
   */
  async withdraw(token, amount, bridgeCall) {
    this.ensureInitialized();
    try {
      const receivableInfo = await this.calculateReceivableAmount(token, amount);
      const result = await import_sdk.Paraclear.withdraw({
        config: this.config,
        account: this.account,
        token,
        amount,
        bridgeCall
      });
      return {
        transactionHash: result.hash,
        receivableAmount: receivableInfo.receivableAmount
      };
    } catch (error) {
      throw new PerpDEXError(
        `Failed to withdraw ${amount} ${token}: ${error instanceof Error ? error.message : String(error)}`,
        "PARACLEAR_WITHDRAWAL_ERROR",
        "paradex",
        error
      );
    }
  }
  /**
   * Check if account is initialized
   *
   * @throws {PerpDEXError} If not initialized
   */
  ensureInitialized() {
    if (!this.account || !this.config || !this.provider) {
      throw new PerpDEXError(
        "Paraclear account not initialized. Call initializeAccount() first.",
        "PARACLEAR_NOT_INITIALIZED",
        "paradex"
      );
    }
  }
  /**
   * Get Paradex configuration
   *
   * @returns Config or undefined if not initialized
   */
  getConfig() {
    return this.config;
  }
  /**
   * Check if account is initialized
   *
   * @returns true if initialized
   */
  isInitialized() {
    return !!(this.account && this.config && this.provider);
  }
};

// src/adapters/paradex/ParadexWebSocketWrapper.ts
var ParadexWebSocketWrapper = class _ParadexWebSocketWrapper {
  /** Maximum queue size for backpressure */
  static MAX_QUEUE_SIZE = 1e3;
  ws;
  wsUrl;
  timeout;
  maxReconnectAttempts;
  normalizer;
  logger = new Logger("ParadexWebSocket");
  isConnected = false;
  reconnectAttempts = 0;
  subscriptionId = 0;
  subscriptions = /* @__PURE__ */ new Map();
  messageQueue = /* @__PURE__ */ new Map();
  /**
   * Push to queue with bounded size (backpressure)
   */
  boundedPush(queue, item, channel) {
    if (queue.length >= _ParadexWebSocketWrapper.MAX_QUEUE_SIZE) {
      queue.shift();
      if (channel) {
        this.logger.warn(`Queue overflow on ${channel}, dropping oldest message`);
      }
    }
    queue.push(item);
  }
  constructor(config) {
    this.wsUrl = config.wsUrl;
    this.timeout = config.timeout || 3e4;
    this.maxReconnectAttempts = config.maxReconnectAttempts || 10;
    this.normalizer = new ParadexNormalizer();
  }
  /**
   * Connect to WebSocket
   *
   * @throws {PerpDEXError} If connection fails
   */
  async connect() {
    return new Promise((resolve, reject) => {
      try {
        this.ws = new WebSocket(this.wsUrl);
        this.ws.onopen = () => {
          this.isConnected = true;
          this.reconnectAttempts = 0;
          resolve();
        };
        this.ws.onmessage = (event) => {
          this.handleMessage(event.data);
        };
        this.ws.onerror = (error) => {
          this.logger.error("WebSocket error", void 0, { error });
        };
        this.ws.onclose = () => {
          this.isConnected = false;
          this.handleDisconnect();
        };
        setTimeout(() => {
          if (!this.isConnected) {
            reject(
              new PerpDEXError(
                "WebSocket connection timeout",
                "WS_TIMEOUT",
                "paradex"
              )
            );
          }
        }, this.timeout);
      } catch (error) {
        reject(
          new PerpDEXError(
            `Failed to connect WebSocket: ${error instanceof Error ? error.message : String(error)}`,
            "WS_CONNECTION_ERROR",
            "paradex",
            error
          )
        );
      }
    });
  }
  /**
   * Disconnect from WebSocket
   */
  disconnect() {
    if (this.ws) {
      this.ws.close();
      this.ws = void 0;
    }
    this.isConnected = false;
    this.subscriptions.clear();
    this.messageQueue.clear();
  }
  /**
   * Watch order book updates for a symbol
   *
   * @param symbol - Trading symbol in CCXT format (e.g., "BTC/USD:USD")
   * @param depth - Order book depth (default: 50)
   * @returns AsyncGenerator yielding OrderBook updates
   */
  async *watchOrderBook(symbol, depth = 50) {
    const market = this.normalizer.symbolFromCCXT(symbol);
    const channel = `orderbook.${market}`;
    const queue = [];
    let error = null;
    let resolver = null;
    const callback = (data) => {
      if (resolver) {
        resolver(data);
        resolver = null;
      } else {
        this.boundedPush(queue, data, "orderbook");
      }
    };
    try {
      await this.subscribe(channel, { market, depth }, callback);
      while (true) {
        if (error) throw error;
        let data;
        if (queue.length > 0) {
          data = queue.shift();
        } else {
          data = await new Promise((resolve) => {
            resolver = resolve;
          });
        }
        if (error) throw error;
        const normalized = this.normalizer.normalizeOrderBook({
          market: data.market || market,
          bids: data.bids || [],
          asks: data.asks || [],
          timestamp: data.timestamp || Date.now(),
          sequence: data.sequence || 0
        });
        yield normalized;
      }
    } finally {
      this.unsubscribe(channel, callback);
    }
  }
  /**
   * Watch public trades for a symbol
   *
   * @param symbol - Trading symbol in CCXT format
   * @returns AsyncGenerator yielding Trade updates
   */
  async *watchTrades(symbol) {
    const market = this.normalizer.symbolFromCCXT(symbol);
    const channel = `trades.${market}`;
    const queue = [];
    let error = null;
    let resolver = null;
    const callback = (data) => {
      const trades = Array.isArray(data) ? data : [data];
      for (const trade of trades) {
        if (resolver) {
          resolver(trade);
          resolver = null;
        } else {
          this.boundedPush(queue, trade, "trades");
        }
      }
    };
    try {
      await this.subscribe(channel, { market }, callback);
      while (true) {
        if (error) throw error;
        let data;
        if (queue.length > 0) {
          data = queue.shift();
        } else {
          data = await new Promise((resolve) => {
            resolver = resolve;
          });
        }
        if (error) throw error;
        const normalized = this.normalizer.normalizeTrade({
          id: data.id || data.trade_id || String(Date.now()),
          market: data.market || market,
          price: data.price,
          size: data.size || data.amount,
          side: data.side,
          timestamp: data.timestamp || Date.now()
        });
        yield normalized;
      }
    } finally {
      this.unsubscribe(channel, callback);
    }
  }
  /**
   * Watch ticker for a symbol
   *
   * @param symbol - Trading symbol in CCXT format
   * @returns AsyncGenerator yielding Ticker updates
   */
  async *watchTicker(symbol) {
    const market = this.normalizer.symbolFromCCXT(symbol);
    const channel = `ticker.${market}`;
    const queue = [];
    let error = null;
    let resolver = null;
    const callback = (data) => {
      if (resolver) {
        resolver(data);
        resolver = null;
      } else {
        this.boundedPush(queue, data, "ticker");
      }
    };
    try {
      await this.subscribe(channel, { market }, callback);
      while (true) {
        if (error) throw error;
        let data;
        if (queue.length > 0) {
          data = queue.shift();
        } else {
          data = await new Promise((resolve) => {
            resolver = resolve;
          });
        }
        if (error) throw error;
        const normalized = this.normalizer.normalizeTicker({
          market: data.market || market,
          last_price: data.last_price || data.last,
          bid: data.bid || data.best_bid,
          ask: data.ask || data.best_ask,
          high_24h: data.high_24h || data.high,
          low_24h: data.low_24h || data.low,
          volume_24h: data.volume_24h || data.volume,
          price_change_24h: data.price_change_24h || "0",
          price_change_percent_24h: data.price_change_percent_24h || "0",
          timestamp: data.timestamp || Date.now()
        });
        yield normalized;
      }
    } finally {
      this.unsubscribe(channel, callback);
    }
  }
  /**
   * Watch position updates for user account
   *
   * @param symbol - Optional symbol filter
   * @returns AsyncGenerator yielding Position updates
   */
  async *watchPositions(symbol) {
    const channel = symbol ? `positions.${this.normalizer.symbolFromCCXT(symbol)}` : "positions";
    const queue = [];
    let error = null;
    let resolver = null;
    const callback = (data) => {
      const positions = Array.isArray(data) ? data : [data];
      for (const pos of positions) {
        if (resolver) {
          resolver(pos);
          resolver = null;
        } else {
          this.boundedPush(queue, pos, "positions");
        }
      }
    };
    try {
      await this.subscribe(channel, symbol ? { market: this.normalizer.symbolFromCCXT(symbol) } : {}, callback);
      while (true) {
        if (error) throw error;
        let data;
        if (queue.length > 0) {
          data = queue.shift();
        } else {
          data = await new Promise((resolve) => {
            resolver = resolve;
          });
        }
        if (error) throw error;
        const normalized = this.normalizer.normalizePosition({
          market: data.market,
          side: data.side,
          size: data.size,
          entry_price: data.entry_price || data.entryPrice,
          mark_price: data.mark_price || data.markPrice,
          liquidation_price: data.liquidation_price || data.liquidationPrice,
          unrealized_pnl: data.unrealized_pnl || data.unrealizedPnl || "0",
          realized_pnl: data.realized_pnl || data.realizedPnl || "0",
          margin: data.margin || "0",
          leverage: data.leverage || "1",
          last_updated: data.last_updated || data.timestamp || Date.now()
        });
        yield normalized;
      }
    } finally {
      this.unsubscribe(channel, callback);
    }
  }
  /**
   * Watch order updates for user account
   *
   * @param symbol - Optional symbol filter
   * @returns AsyncGenerator yielding Order updates
   */
  async *watchOrders(symbol) {
    const channel = symbol ? `orders.${this.normalizer.symbolFromCCXT(symbol)}` : "orders";
    const queue = [];
    let error = null;
    let resolver = null;
    const callback = (data) => {
      const orders = Array.isArray(data) ? data : [data];
      for (const order of orders) {
        if (resolver) {
          resolver(order);
          resolver = null;
        } else {
          this.boundedPush(queue, order, "orders");
        }
      }
    };
    try {
      await this.subscribe(channel, symbol ? { market: this.normalizer.symbolFromCCXT(symbol) } : {}, callback);
      while (true) {
        if (error) throw error;
        let data;
        if (queue.length > 0) {
          data = queue.shift();
        } else {
          data = await new Promise((resolve) => {
            resolver = resolve;
          });
        }
        if (error) throw error;
        const normalized = this.normalizer.normalizeOrder({
          id: data.id || data.order_id,
          client_id: data.client_id || data.clientOrderId,
          market: data.market,
          type: data.type,
          side: data.side,
          size: data.size || data.amount,
          price: data.price,
          filled_size: data.filled_size || data.filled || "0",
          avg_fill_price: data.avg_fill_price || data.averagePrice,
          status: data.status,
          time_in_force: data.time_in_force || data.timeInForce || "GTC",
          post_only: data.post_only || false,
          reduce_only: data.reduce_only || false,
          created_at: data.created_at || data.timestamp || Date.now(),
          updated_at: data.updated_at || data.timestamp || Date.now()
        });
        yield normalized;
      }
    } finally {
      this.unsubscribe(channel, callback);
    }
  }
  /**
   * Watch balance updates
   *
   * @returns AsyncGenerator yielding Balance array
   */
  async *watchBalance() {
    const channel = "balances";
    const queue = [];
    let error = null;
    let resolver = null;
    const callback = (data) => {
      if (resolver) {
        resolver(data);
        resolver = null;
      } else {
        this.boundedPush(queue, data, "balance");
      }
    };
    try {
      await this.subscribe(channel, {}, callback);
      while (true) {
        if (error) throw error;
        let data;
        if (queue.length > 0) {
          data = queue.shift();
        } else {
          data = await new Promise((resolve) => {
            resolver = resolve;
          });
        }
        if (error) throw error;
        const balances = Array.isArray(data) ? data : [data];
        const normalized = balances.map(
          (bal) => this.normalizer.normalizeBalance({
            asset: bal.asset || bal.currency,
            total: bal.total || bal.balance || "0",
            available: bal.available || bal.free || "0",
            locked: bal.locked || bal.used || "0"
          })
        );
        yield normalized;
      }
    } finally {
      this.unsubscribe(channel, callback);
    }
  }
  /**
   * Watch user trades (fills) in real-time
   *
   * @param symbol - Optional symbol filter
   * @returns AsyncGenerator yielding Trade updates
   */
  async *watchMyTrades(symbol) {
    const channel = symbol ? `fills.${this.normalizer.symbolFromCCXT(symbol)}` : "fills";
    const queue = [];
    let error = null;
    let resolver = null;
    const callback = (data) => {
      const fills = Array.isArray(data) ? data : [data];
      for (const fill of fills) {
        if (resolver) {
          resolver(fill);
          resolver = null;
        } else {
          this.boundedPush(queue, fill, "fills");
        }
      }
    };
    try {
      await this.subscribe(channel, symbol ? { market: this.normalizer.symbolFromCCXT(symbol) } : {}, callback);
      while (true) {
        if (error) throw error;
        let data;
        if (queue.length > 0) {
          data = queue.shift();
        } else {
          data = await new Promise((resolve) => {
            resolver = resolve;
          });
        }
        if (error) throw error;
        const trade = this.normalizer.normalizeTrade({
          id: data.id || data.fill_id || String(Date.now()),
          market: data.market,
          side: data.side,
          price: data.price,
          size: data.size || data.amount,
          timestamp: data.timestamp || data.created_at || Date.now()
        });
        yield trade;
      }
    } finally {
      this.unsubscribe(channel, callback);
    }
  }
  /**
   * Subscribe to a channel
   */
  async subscribe(channel, params, callback) {
    if (!this.isConnected) {
      await this.connect();
    }
    if (!this.subscriptions.has(channel)) {
      this.subscriptions.set(channel, /* @__PURE__ */ new Set());
    }
    this.subscriptions.get(channel).add(callback);
    const request = {
      method: "subscribe",
      params: {
        channel,
        ...params
      },
      id: ++this.subscriptionId
    };
    this.ws.send(JSON.stringify(request));
  }
  /**
   * Unsubscribe from a channel
   */
  unsubscribe(channel, callback) {
    const subscribers = this.subscriptions.get(channel);
    if (subscribers) {
      subscribers.delete(callback);
      if (subscribers.size === 0) {
        this.subscriptions.delete(channel);
        if (this.ws && this.isConnected) {
          this.ws.send(
            JSON.stringify({
              method: "unsubscribe",
              params: { channel },
              id: ++this.subscriptionId
            })
          );
        }
      }
    }
  }
  /**
   * Handle incoming WebSocket message
   */
  handleMessage(rawData) {
    try {
      const message = JSON.parse(rawData);
      if (message.error) {
        this.logger.error("WebSocket error", void 0, { error: message.error });
        return;
      }
      if (message.type === "subscribed") {
        return;
      }
      if (message.channel && message.data) {
        const subscribers = this.subscriptions.get(message.channel);
        if (subscribers) {
          subscribers.forEach((callback) => callback(message.data));
        }
      }
    } catch (error) {
      this.logger.error("Failed to parse message", error instanceof Error ? error : void 0);
    }
  }
  /**
   * Handle disconnection and attempt reconnect
   */
  async handleDisconnect() {
    if (this.reconnectAttempts >= this.maxReconnectAttempts) {
      this.logger.error("Max reconnect attempts reached");
      return;
    }
    this.reconnectAttempts++;
    const delay = Math.min(1e3 * Math.pow(2, this.reconnectAttempts), 3e4);
    this.logger.info(`Reconnecting in ${delay}ms (attempt ${this.reconnectAttempts})...`);
    await new Promise((resolve) => setTimeout(resolve, delay));
    try {
      await this.connect();
      for (const [channel] of this.subscriptions) {
        const params = {};
        this.ws.send(
          JSON.stringify({
            method: "subscribe",
            params: { channel, ...params },
            id: ++this.subscriptionId
          })
        );
      }
    } catch (error) {
      this.logger.error("Reconnect failed", error instanceof Error ? error : void 0);
      this.handleDisconnect();
    }
  }
  /**
   * Check if WebSocket is connected
   */
  get connected() {
    return this.isConnected;
  }
};

// src/adapters/paradex/ParadexAdapter.ts
var ParadexAdapter = class extends BaseAdapter {
  id = "paradex";
  name = "Paradex";
  has = {
    fetchMarkets: true,
    fetchTicker: true,
    fetchOrderBook: true,
    fetchTrades: true,
    fetchFundingRate: true,
    fetchFundingRateHistory: true,
    fetchPositions: true,
    fetchBalance: true,
    fetchOrderHistory: true,
    fetchMyTrades: true,
    createOrder: true,
    cancelOrder: true,
    cancelAllOrders: true,
    setLeverage: true,
    watchOrderBook: true,
    watchTrades: true,
    watchTicker: true,
    watchPositions: true,
    watchOrders: true,
    watchBalance: true,
    watchMyTrades: true
  };
  // Component architecture
  auth;
  client;
  normalizer;
  paraclear;
  ws;
  rateLimiter;
  wsUrl;
  constructor(config = {}) {
    super(config);
    const tier = config.rateLimitTier ?? "default";
    const limits = PARADEX_RATE_LIMITS[tier];
    this.rateLimiter = new RateLimiter({
      maxTokens: limits.maxRequests,
      refillRate: limits.maxRequests / (limits.windowMs / 1e3),
      windowMs: limits.windowMs,
      weights: PARADEX_ENDPOINT_WEIGHTS
    });
    const urls = config.testnet ? PARADEX_API_URLS.testnet : PARADEX_API_URLS.mainnet;
    this.wsUrl = urls.websocket;
    this.auth = new ParadexAuth({
      apiKey: config.apiKey,
      apiSecret: config.apiSecret,
      privateKey: config.privateKey,
      starkPrivateKey: config.starkPrivateKey,
      testnet: config.testnet
    });
    this.normalizer = new ParadexNormalizer();
    this.client = new ParadexHTTPClient({
      baseUrl: urls.rest,
      auth: this.auth
    });
    this.paraclear = new ParadexParaclearWrapper({
      testnet: config.testnet
    });
  }
  /**
   * Initialize the adapter
   * Note: starkPrivateKey is only required for private API operations (trading)
   */
  async initialize() {
    this._isReady = true;
  }
  /**
   * Require authentication for private API operations
   */
  requireAuth() {
    if (!this.auth.hasCredentials()) {
      throw new PerpDEXError(
        "Authentication required. Provide apiKey or starkPrivateKey in config.",
        "MISSING_CREDENTIALS",
        "paradex"
      );
    }
  }
  /**
   * Cleanup resources
   */
  async disconnect() {
    if (this.ws) {
      this.ws.disconnect();
      this.ws = void 0;
    }
    this.auth.clearJWTToken();
    this._isReady = false;
  }
  // ===========================================================================
  // Market Data Methods
  // ===========================================================================
  /**
   * Fetch all available markets
   */
  async fetchMarkets(_params) {
    await this.rateLimiter.acquire("fetchMarkets");
    try {
      const response = await this.client.get("/markets");
      const markets = response.results || response.markets;
      if (!Array.isArray(markets)) {
        throw new PerpDEXError("Invalid markets response", "INVALID_RESPONSE", "paradex");
      }
      return this.normalizer.normalizeMarkets(markets);
    } catch (error) {
      throw mapAxiosError2(error);
    }
  }
  /**
   * Fetch ticker for a symbol
   */
  async fetchTicker(symbol) {
    await this.rateLimiter.acquire("fetchTicker");
    try {
      const market = this.normalizer.symbolFromCCXT(symbol);
      const response = await this.client.get(`/markets/${market}/ticker`);
      return this.normalizer.normalizeTicker(response);
    } catch (error) {
      throw mapAxiosError2(error);
    }
  }
  /**
   * Fetch order book for a symbol
   */
  async fetchOrderBook(symbol, params) {
    await this.rateLimiter.acquire("fetchOrderBook");
    try {
      const market = this.normalizer.symbolFromCCXT(symbol);
      const limit = params?.limit;
      const queryParams = limit ? `?depth=${limit}` : "";
      const response = await this.client.get(`/orderbook/${market}${queryParams}`);
      return this.normalizer.normalizeOrderBook(response);
    } catch (error) {
      throw mapAxiosError2(error);
    }
  }
  /**
   * Fetch recent trades for a symbol
   */
  async fetchTrades(symbol, params) {
    await this.rateLimiter.acquire("fetchTrades");
    try {
      const market = this.normalizer.symbolFromCCXT(symbol);
      const limit = params?.limit ?? 100;
      const response = await this.client.get(`/trades/${market}?limit=${limit}`);
      if (!Array.isArray(response.trades)) {
        throw new PerpDEXError("Invalid trades response", "INVALID_RESPONSE", "paradex");
      }
      return this.normalizer.normalizeTrades(response.trades);
    } catch (error) {
      throw mapAxiosError2(error);
    }
  }
  /**
   * Fetch current funding rate
   */
  async fetchFundingRate(symbol) {
    await this.rateLimiter.acquire("fetchFundingRate");
    try {
      const market = this.normalizer.symbolFromCCXT(symbol);
      const response = await this.client.get(`/markets/${market}/funding`);
      return this.normalizer.normalizeFundingRate(response);
    } catch (error) {
      throw mapAxiosError2(error);
    }
  }
  /**
   * Fetch funding rate history
   */
  async fetchFundingRateHistory(symbol, since, limit) {
    await this.rateLimiter.acquire("fetchFundingRateHistory");
    try {
      const market = this.normalizer.symbolFromCCXT(symbol);
      const params = new URLSearchParams();
      if (since) params.append("start_time", since.toString());
      if (limit) params.append("limit", limit.toString());
      const queryString = params.toString();
      const path = `/markets/${market}/funding/history${queryString ? `?${queryString}` : ""}`;
      const response = await this.client.get(path);
      if (!Array.isArray(response.history)) {
        throw new PerpDEXError("Invalid funding rate history response", "INVALID_RESPONSE", "paradex");
      }
      return this.normalizer.normalizeFundingRates(response.history);
    } catch (error) {
      throw mapAxiosError2(error);
    }
  }
  // ===========================================================================
  // Account Methods
  // ===========================================================================
  /**
   * Fetch all open positions
   */
  async fetchPositions(symbols) {
    this.requireAuth();
    await this.rateLimiter.acquire("fetchPositions");
    try {
      const response = await this.client.get("/positions");
      if (!Array.isArray(response.positions)) {
        throw new PerpDEXError("Invalid positions response", "INVALID_RESPONSE", "paradex");
      }
      let positions = this.normalizer.normalizePositions(response.positions);
      if (symbols && symbols.length > 0) {
        positions = positions.filter((p) => symbols.includes(p.symbol));
      }
      return positions;
    } catch (error) {
      throw mapAxiosError2(error);
    }
  }
  /**
   * Fetch account balance
   */
  async fetchBalance() {
    this.requireAuth();
    await this.rateLimiter.acquire("fetchBalance");
    try {
      const response = await this.client.get("/balance");
      if (!Array.isArray(response.balances)) {
        throw new PerpDEXError("Invalid balance response", "INVALID_RESPONSE", "paradex");
      }
      return this.normalizer.normalizeBalances(response.balances);
    } catch (error) {
      throw mapAxiosError2(error);
    }
  }
  // ===========================================================================
  // Trading Methods
  // ===========================================================================
  /**
   * Create a new order
   */
  async createOrder(request) {
    const validatedRequest = this.validateOrder(request);
    this.requireAuth();
    await this.rateLimiter.acquire("createOrder");
    try {
      const market = this.normalizer.symbolFromCCXT(validatedRequest.symbol);
      const orderType = this.normalizer.toParadexOrderType(validatedRequest.type, validatedRequest.postOnly);
      const side = this.normalizer.toParadexOrderSide(validatedRequest.side);
      const timeInForce = this.normalizer.toParadexTimeInForce(validatedRequest.timeInForce, validatedRequest.postOnly);
      const payload = {
        market,
        side,
        type: orderType,
        size: validatedRequest.amount.toString(),
        price: validatedRequest.price?.toString(),
        time_in_force: timeInForce,
        reduce_only: validatedRequest.reduceOnly ?? false,
        post_only: validatedRequest.postOnly ?? false,
        client_id: validatedRequest.clientOrderId
      };
      const response = await this.client.post("/orders", payload);
      return this.normalizer.normalizeOrder(response);
    } catch (error) {
      throw mapAxiosError2(error);
    }
  }
  /**
   * Cancel an existing order
   */
  async cancelOrder(orderId, _symbol) {
    this.requireAuth();
    await this.rateLimiter.acquire("cancelOrder");
    try {
      const response = await this.client.delete(`/orders/${orderId}`);
      return this.normalizer.normalizeOrder(response);
    } catch (error) {
      throw mapAxiosError2(error);
    }
  }
  /**
   * Cancel all orders
   */
  async cancelAllOrders(symbol) {
    this.requireAuth();
    await this.rateLimiter.acquire("cancelAllOrders");
    try {
      const payload = symbol ? { market: this.normalizer.symbolFromCCXT(symbol) } : void 0;
      const response = await this.client.delete("/orders", payload);
      if (!Array.isArray(response.orders)) {
        throw new PerpDEXError("Invalid cancel all orders response", "INVALID_RESPONSE", "paradex");
      }
      return this.normalizer.normalizeOrders(response.orders);
    } catch (error) {
      throw mapAxiosError2(error);
    }
  }
  /**
   * Fetch open orders
   */
  async fetchOpenOrders(symbol) {
    this.requireAuth();
    await this.rateLimiter.acquire("fetchOpenOrders");
    try {
      const params = symbol ? `?market=${this.normalizer.symbolFromCCXT(symbol)}` : "";
      const response = await this.client.get(`/orders${params}`);
      if (!Array.isArray(response.orders)) {
        throw new PerpDEXError("Invalid open orders response", "INVALID_RESPONSE", "paradex");
      }
      return this.normalizer.normalizeOrders(response.orders);
    } catch (error) {
      throw mapAxiosError2(error);
    }
  }
  /**
   * Fetch a specific order
   */
  async fetchOrder(orderId, _symbol) {
    this.requireAuth();
    await this.rateLimiter.acquire("fetchOrder");
    try {
      const response = await this.client.get(`/orders/${orderId}`);
      return this.normalizer.normalizeOrder(response);
    } catch (error) {
      throw mapAxiosError2(error);
    }
  }
  /**
   * Set leverage for a symbol
   */
  async setLeverage(symbol, leverage) {
    this.requireAuth();
    await this.rateLimiter.acquire("setLeverage");
    try {
      const market = this.normalizer.symbolFromCCXT(symbol);
      await this.client.post("/account/leverage", {
        market,
        leverage: leverage.toString()
      });
    } catch (error) {
      throw mapAxiosError2(error);
    }
  }
  /**
   * Fetch order history
   */
  async fetchOrderHistory(symbol, since, limit) {
    this.requireAuth();
    await this.rateLimiter.acquire("fetchOrderHistory");
    try {
      const params = new URLSearchParams();
      if (symbol) params.append("market", this.normalizer.symbolFromCCXT(symbol));
      if (since) params.append("start_at", since.toString());
      if (limit) params.append("page_size", limit.toString());
      const queryString = params.toString();
      const response = await this.client.get(`/orders/history${queryString ? `?${queryString}` : ""}`);
      if (!Array.isArray(response.results)) {
        throw new PerpDEXError("Invalid order history response", "INVALID_RESPONSE", "paradex");
      }
      return this.normalizer.normalizeOrders(response.results);
    } catch (error) {
      throw mapAxiosError2(error);
    }
  }
  /**
   * Fetch user trade history
   */
  async fetchMyTrades(symbol, since, limit) {
    this.requireAuth();
    await this.rateLimiter.acquire("fetchMyTrades");
    try {
      const params = new URLSearchParams();
      if (symbol) params.append("market", this.normalizer.symbolFromCCXT(symbol));
      if (since) params.append("start_at", since.toString());
      if (limit) params.append("page_size", limit.toString());
      const queryString = params.toString();
      const response = await this.client.get(`/fills${queryString ? `?${queryString}` : ""}`);
      if (!Array.isArray(response.results)) {
        throw new PerpDEXError("Invalid fills response", "INVALID_RESPONSE", "paradex");
      }
      return this.normalizer.normalizeTrades(response.results);
    } catch (error) {
      throw mapAxiosError2(error);
    }
  }
  // ===========================================================================
  // Paraclear Methods (Withdrawal Operations)
  // ===========================================================================
  /**
   * Withdraw funds from Paraclear
   *
   * IMPORTANT: Requires Ethereum signer to be initialized via paraclear.initializeAccount()
   *
   * @param token - Token symbol (e.g., "USDC", "ETH")
   * @param amount - Amount to withdraw (as number)
   * @param bridgeCall - StarkNet bridge call for L1 transfer
   * @returns Transaction hash and actual receivable amount (after socialized loss)
   *
   * @example
   * ```typescript
   * // Initialize Paraclear account first
   * const signer = new ethers.Wallet(privateKey);
   * await adapter.paraclear.initializeAccount(signer);
   *
   * // Withdraw USDC
   * const result = await adapter.withdraw('USDC', 100, bridgeCall);
   * console.log('TX:', result.txHash);
   * console.log('Actual amount:', result.amount); // May be less if socialized loss active
   * ```
   */
  async withdraw(token, amount, bridgeCall) {
    this.requireAuth();
    await this.rateLimiter.acquire("withdraw");
    try {
      const result = await this.paraclear.withdraw(token, amount.toString(), bridgeCall);
      return {
        txHash: result.transactionHash,
        amount: parseFloat(result.receivableAmount)
      };
    } catch (error) {
      throw mapAxiosError2(error);
    }
  }
  /**
   * Fetch Paraclear (on-chain) balance
   *
   * This queries the StarkNet chain directly via Paraclear SDK,
   * which may differ from API balance due to pending operations.
   *
   * @param token - Optional token filter (e.g., "USDC")
   * @returns Balance array
   */
  async fetchParaclearBalance(token) {
    this.requireAuth();
    await this.rateLimiter.acquire("fetchBalance");
    try {
      const balances = await this.paraclear.getAllBalances();
      return Object.entries(balances).filter(([currency]) => !token || currency === token).map(([currency, total]) => ({
        currency,
        total: parseFloat(total),
        free: parseFloat(total),
        used: 0
      }));
    } catch (error) {
      throw mapAxiosError2(error);
    }
  }
  // ===========================================================================
  // WebSocket Methods (Real-time Streams)
  // ===========================================================================
  /**
   * Ensure WebSocket is connected
   */
  async ensureWebSocket() {
    if (!this.ws) {
      this.ws = new ParadexWebSocketWrapper({
        wsUrl: this.wsUrl,
        timeout: 3e4
      });
      await this.ws.connect();
    }
    return this.ws;
  }
  /**
   * Watch order book updates for a symbol
   *
   * @param symbol - Trading symbol in CCXT format
   * @param limit - Order book depth (default: 50)
   * @returns AsyncGenerator yielding OrderBook updates
   */
  async *watchOrderBook(symbol, limit) {
    const ws = await this.ensureWebSocket();
    yield* ws.watchOrderBook(symbol, limit);
  }
  /**
   * Watch public trades for a symbol
   *
   * @param symbol - Trading symbol in CCXT format
   * @returns AsyncGenerator yielding Trade updates
   */
  async *watchTrades(symbol) {
    const ws = await this.ensureWebSocket();
    yield* ws.watchTrades(symbol);
  }
  /**
   * Watch ticker for a symbol
   *
   * @param symbol - Trading symbol in CCXT format
   * @returns AsyncGenerator yielding Ticker updates
   */
  async *watchTicker(symbol) {
    const ws = await this.ensureWebSocket();
    yield* ws.watchTicker(symbol);
  }
  /**
   * Watch position updates for user account
   *
   * @param symbol - Optional symbol filter
   * @returns AsyncGenerator yielding Position updates
   */
  async *watchPositions(symbol) {
    this.requireAuth();
    const ws = await this.ensureWebSocket();
    for await (const position of ws.watchPositions(symbol)) {
      yield [position];
    }
  }
  /**
   * Watch order updates for user account
   *
   * @param symbol - Optional symbol filter
   * @returns AsyncGenerator yielding Order updates
   */
  async *watchOrders(symbol) {
    this.requireAuth();
    const ws = await this.ensureWebSocket();
    for await (const order of ws.watchOrders(symbol)) {
      yield [order];
    }
  }
  /**
   * Watch balance updates
   *
   * @returns AsyncGenerator yielding Balance array
   */
  async *watchBalance() {
    this.requireAuth();
    const ws = await this.ensureWebSocket();
    yield* ws.watchBalance();
  }
  /**
   * Watch user trades (fills) in real-time
   *
   * @param symbol - Optional symbol filter
   * @returns AsyncGenerator yielding Trade updates
   */
  async *watchMyTrades(symbol) {
    this.requireAuth();
    const ws = await this.ensureWebSocket();
    yield* ws.watchMyTrades(symbol);
  }
  // ===========================================================================
  // Symbol Conversion
  // ===========================================================================
  /**
   * Convert unified symbol to exchange format
   */
  symbolToExchange(symbol) {
    return this.normalizer.symbolFromCCXT(symbol);
  }
  /**
   * Convert exchange symbol to unified format
   */
  symbolFromExchange(exchangeSymbol) {
    return this.normalizer.symbolToCCXT(exchangeSymbol);
  }
};

// src/adapters/edgex/constants.ts
var EDGEX_API_URLS = {
  mainnet: {
    rest: "https://pro.edgex.exchange",
    websocket: "wss://quote.edgex.exchange"
  },
  // Note: EdgeX does not provide a public testnet - uses mainnet URLs
  testnet: {
    rest: "https://pro.edgex.exchange",
    websocket: "wss://quote.edgex.exchange"
  }
};
var EDGEX_RATE_LIMITS = {
  rest: {
    maxRequests: 1200,
    windowMs: 6e4
    // 1 minute
  },
  websocket: {
    maxSubscriptions: 100
  }
};
var EDGEX_ENDPOINT_WEIGHTS = {
  fetchMarkets: 1,
  fetchTicker: 1,
  fetchOrderBook: 2,
  fetchTrades: 2,
  fetchFundingRate: 1,
  fetchPositions: 3,
  fetchBalance: 2,
  fetchOpenOrders: 3,
  fetchClosedOrders: 5,
  createOrder: 5,
  cancelOrder: 3,
  createBatchOrders: 15,
  cancelAllOrders: 10,
  modifyOrder: 5,
  fetchOrder: 2,
  fetchMyTrades: 5,
  setLeverage: 3
};
var EDGEX_ORDER_TYPES = {
  market: "MARKET",
  limit: "LIMIT"
};
var EDGEX_ORDER_SIDES = {
  buy: "BUY",
  sell: "SELL"
};
var EDGEX_TIME_IN_FORCE = {
  GTC: "GTC",
  IOC: "IOC",
  FOK: "FOK"
};
var EDGEX_STARK_CONSTANTS = {
  FIELD_PRIME: BigInt("0x800000000000011000000000000000000000000000000000000000000000001"),
  MAX_AMOUNT: BigInt("2") ** BigInt("63") - BigInt("1")
};

// src/adapters/edgex/EdgeXNormalizer.ts
var EdgeXNormalizer = class {
  // Cache for symbol -> contractId mapping
  symbolToContractId = /* @__PURE__ */ new Map();
  contractIdToSymbol = /* @__PURE__ */ new Map();
  /**
   * Initialize mapping from market data
   */
  initializeMappings(contracts) {
    for (const contract of contracts) {
      const name = contract.contractName;
      const base = name.replace(/USD$/, "");
      const quote = "USD";
      const ccxtSymbol = `${base}/${quote}:${quote}`;
      this.symbolToContractId.set(ccxtSymbol, contract.contractId);
      this.contractIdToSymbol.set(contract.contractId, ccxtSymbol);
    }
  }
  /**
   * Normalize EdgeX symbol to unified format
   *
   * Handles multiple formats:
   * - New API format: 'BTCUSD', 'ETHUSD' â†’ 'BTC/USD:USD'
   * - Legacy format: 'BTC-USDC-PERP' â†’ 'BTC/USDC:USDC'
   */
  normalizeSymbol(edgexSymbol) {
    if (edgexSymbol.includes("-")) {
      const parts = edgexSymbol.split("-");
      if (parts.length === 3 && parts[2] === "PERP") {
        const base2 = parts[0];
        const quote = parts[1];
        return `${base2}/${quote}:${quote}`;
      }
      return edgexSymbol.replace("-", "/");
    }
    const base = edgexSymbol.replace(/USD$/, "");
    return `${base}/USD:USD`;
  }
  /**
   * Convert unified symbol to EdgeX format
   *
   * Supports both formats:
   * - New API: 'BTC/USD:USD' â†’ 'BTCUSD'
   * - Legacy: 'BTC/USDC:USDC' â†’ 'BTC-USDC-PERP'
   */
  toEdgeXSymbol(symbol) {
    const parts = symbol.split(":");
    const [pair = ""] = parts;
    const [base = "", quote = ""] = pair.split("/");
    if (quote === "USDC") {
      return parts.length === 2 ? `${base}-${quote}-PERP` : `${base}-${quote}`;
    }
    return `${base}${quote || "USD"}`;
  }
  /**
   * Convert unified symbol to EdgeX contractId
   *
   * @example
   * toEdgeXContractId('BTC/USD:USD') // '10000001'
   */
  toEdgeXContractId(symbol) {
    const cachedId = this.symbolToContractId.get(symbol);
    if (cachedId) {
      return cachedId;
    }
    const symbolToId = {
      "BTC/USD:USD": "10000001",
      "ETH/USD:USD": "10000002",
      "SOL/USD:USD": "10000003",
      "ARB/USD:USD": "10000004",
      "DOGE/USD:USD": "10000005",
      "XRP/USD:USD": "10000006",
      "BNB/USD:USD": "10000007",
      "AVAX/USD:USD": "10000008",
      "LINK/USD:USD": "10000009",
      "LTC/USD:USD": "10000010"
    };
    return symbolToId[symbol] || "10000001";
  }
  /**
   * Normalize EdgeX market to unified format
   * Handles both old test format and new API format
   */
  normalizeMarket(contract) {
    if (contract.contractName) {
      const contractName = contract.contractName;
      const base = contractName.replace(/USD$/, "");
      const symbol2 = `${base}/USD:USD`;
      this.symbolToContractId.set(symbol2, contract.contractId);
      this.contractIdToSymbol.set(contract.contractId, symbol2);
      const maxLeverage = contract.riskTierList?.[0]?.maxLeverage ? parseFloat(contract.riskTierList[0].maxLeverage) : 100;
      return {
        id: contract.contractId,
        symbol: symbol2,
        base,
        quote: "USD",
        settle: "USD",
        active: contract.enableTrade ?? true,
        minAmount: parseFloat(contract.minOrderSize || "0.001"),
        pricePrecision: this.countDecimals(contract.tickSize || "0.1"),
        amountPrecision: this.countDecimals(contract.stepSize || "0.001"),
        priceTickSize: parseFloat(contract.tickSize || "0.1"),
        amountStepSize: parseFloat(contract.stepSize || "0.001"),
        makerFee: parseFloat(contract.defaultMakerFeeRate || "0.0002"),
        takerFee: parseFloat(contract.defaultTakerFeeRate || "0.0005"),
        maxLeverage,
        fundingIntervalHours: 4
        // EdgeX uses 4h funding
      };
    }
    const symbol = this.normalizeSymbol(contract.symbol);
    return {
      id: contract.market_id,
      symbol,
      base: contract.base_asset,
      quote: contract.quote_asset,
      settle: contract.settlement_asset,
      active: contract.is_active,
      minAmount: parseFloat(contract.min_order_size),
      pricePrecision: this.countDecimals(contract.tick_size),
      amountPrecision: this.countDecimals(contract.step_size),
      priceTickSize: parseFloat(contract.tick_size),
      amountStepSize: parseFloat(contract.step_size),
      makerFee: parseFloat(contract.maker_fee),
      takerFee: parseFloat(contract.taker_fee),
      maxLeverage: parseFloat(contract.max_leverage),
      fundingIntervalHours: 8
    };
  }
  /**
   * Normalize EdgeX order to unified format
   */
  normalizeOrder(edgexOrder) {
    const symbol = this.normalizeSymbol(edgexOrder.market);
    return {
      id: edgexOrder.order_id,
      clientOrderId: edgexOrder.client_order_id,
      symbol,
      type: this.normalizeOrderType(edgexOrder.type),
      side: this.normalizeOrderSide(edgexOrder.side),
      amount: parseFloat(edgexOrder.size),
      price: edgexOrder.price ? parseFloat(edgexOrder.price) : void 0,
      filled: parseFloat(edgexOrder.filled_size),
      remaining: parseFloat(edgexOrder.size) - parseFloat(edgexOrder.filled_size),
      averagePrice: edgexOrder.average_price ? parseFloat(edgexOrder.average_price) : void 0,
      status: this.normalizeOrderStatus(edgexOrder.status),
      timeInForce: this.normalizeTimeInForce(edgexOrder.time_in_force),
      postOnly: edgexOrder.post_only,
      reduceOnly: edgexOrder.reduce_only,
      timestamp: edgexOrder.created_at,
      lastUpdateTimestamp: edgexOrder.updated_at,
      info: edgexOrder
    };
  }
  /**
   * Normalize EdgeX position to unified format
   */
  normalizePosition(edgexPosition) {
    const symbol = this.normalizeSymbol(edgexPosition.market);
    const size = parseFloat(edgexPosition.size);
    const side = edgexPosition.side === "LONG" ? "long" : "short";
    return {
      symbol,
      side,
      marginMode: "cross",
      size: Math.abs(size),
      entryPrice: parseFloat(edgexPosition.entry_price),
      markPrice: parseFloat(edgexPosition.mark_price),
      liquidationPrice: edgexPosition.liquidation_price ? parseFloat(edgexPosition.liquidation_price) : 0,
      unrealizedPnl: parseFloat(edgexPosition.unrealized_pnl),
      realizedPnl: parseFloat(edgexPosition.realized_pnl),
      margin: parseFloat(edgexPosition.margin),
      leverage: parseFloat(edgexPosition.leverage),
      maintenanceMargin: parseFloat(edgexPosition.margin) * 0.04,
      marginRatio: 0,
      timestamp: edgexPosition.timestamp,
      info: edgexPosition
    };
  }
  /**
   * Normalize EdgeX balance to unified format
   */
  normalizeBalance(edgexBalance) {
    return {
      currency: edgexBalance.asset,
      total: parseFloat(edgexBalance.total),
      free: parseFloat(edgexBalance.available),
      used: parseFloat(edgexBalance.locked),
      info: edgexBalance
    };
  }
  /**
   * Normalize EdgeX order book to unified format
   * Handles new API format from /api/v1/public/quote/getDepth
   */
  normalizeOrderBook(depthData, symbol) {
    return {
      symbol,
      exchange: "edgex",
      bids: (depthData.bids || []).map((level) => [
        parseFloat(level.price),
        parseFloat(level.size)
      ]),
      asks: (depthData.asks || []).map((level) => [
        parseFloat(level.price),
        parseFloat(level.size)
      ]),
      timestamp: Date.now()
    };
  }
  /**
   * Normalize EdgeX trade to unified format
   */
  normalizeTrade(edgexTrade) {
    const price = parseFloat(edgexTrade.price);
    const amount = parseFloat(edgexTrade.size);
    return {
      id: edgexTrade.trade_id,
      symbol: this.normalizeSymbol(edgexTrade.market),
      side: this.normalizeOrderSide(edgexTrade.side),
      price,
      amount,
      cost: price * amount,
      timestamp: edgexTrade.timestamp,
      info: edgexTrade
    };
  }
  /**
   * Normalize EdgeX ticker to unified format
   * Handles new API format from /api/v1/public/quote/getTicker
   */
  normalizeTicker(tickerData) {
    const last = parseFloat(tickerData.lastPrice || tickerData.close || "0");
    const open = parseFloat(tickerData.open || "0");
    const change = parseFloat(tickerData.priceChange || "0");
    const percentage = parseFloat(tickerData.priceChangePercent || "0");
    const symbol = this.normalizeSymbol(tickerData.contractName || "");
    return {
      symbol,
      last,
      open,
      close: last,
      bid: last,
      // No separate bid in ticker response
      ask: last,
      // No separate ask in ticker response
      high: parseFloat(tickerData.high || "0"),
      low: parseFloat(tickerData.low || "0"),
      change,
      percentage,
      baseVolume: parseFloat(tickerData.size || tickerData.volume || "0"),
      quoteVolume: parseFloat(tickerData.value || "0"),
      timestamp: parseInt(tickerData.endTime || Date.now().toString(), 10),
      info: tickerData
    };
  }
  /**
   * Normalize EdgeX funding rate to unified format
   * Handles new API format from /api/v1/public/funding/getLatestFundingRate
   */
  normalizeFundingRate(fundingData, symbol) {
    return {
      symbol,
      fundingRate: parseFloat(fundingData.fundingRate || "0"),
      fundingTimestamp: parseInt(fundingData.fundingTime || fundingData.fundingTimestamp || "0", 10),
      markPrice: parseFloat(fundingData.markPrice || "0"),
      indexPrice: parseFloat(fundingData.indexPrice || "0"),
      nextFundingTimestamp: parseInt(fundingData.nextFundingTime || "0", 10),
      fundingIntervalHours: 4,
      // EdgeX uses 4h funding intervals
      info: fundingData
    };
  }
  /**
   * Normalize EdgeX order type to unified format
   */
  normalizeOrderType(edgexType) {
    switch (edgexType) {
      case "MARKET":
        return "market";
      case "LIMIT":
        return "limit";
      default:
        return "limit";
    }
  }
  /**
   * Normalize EdgeX order side to unified format
   */
  normalizeOrderSide(edgexSide) {
    return edgexSide === "BUY" ? "buy" : "sell";
  }
  /**
   * Normalize EdgeX order status to unified format
   */
  normalizeOrderStatus(edgexStatus) {
    const statusMap = {
      PENDING: "open",
      OPEN: "open",
      PARTIALLY_FILLED: "partiallyFilled",
      FILLED: "filled",
      CANCELLED: "canceled",
      REJECTED: "rejected"
    };
    return statusMap[edgexStatus] ?? "open";
  }
  /**
   * Normalize EdgeX time in force to unified format
   */
  normalizeTimeInForce(edgexTif) {
    switch (edgexTif) {
      case "GTC":
        return "GTC";
      case "IOC":
        return "IOC";
      case "FOK":
        return "FOK";
      default:
        return "GTC";
    }
  }
  /**
   * Count decimal places in a string number
   */
  countDecimals(value) {
    const parts = value.split(".");
    return parts.length === 2 && parts[1] ? parts[1].length : 0;
  }
};

// src/adapters/edgex/EdgeXAuth.ts
var import_starknet2 = require("starknet");
var EdgeXAuth = class {
  starkPrivateKey;
  constructor(config) {
    this.starkPrivateKey = config.starkPrivateKey;
  }
  /**
   * Sign a request with ECDSA signature using SHA3 hash
   */
  async sign(request) {
    const timestamp = Date.now().toString();
    const signature = await this.signRequest(
      request.method,
      request.path,
      timestamp,
      request.body
    );
    return {
      ...request,
      headers: {
        ...this.getHeaders(),
        "X-edgeX-Api-Timestamp": timestamp,
        "X-edgeX-Api-Signature": signature
      }
    };
  }
  /**
   * Get authentication headers
   */
  getHeaders() {
    return {
      "Content-Type": "application/json"
    };
  }
  /**
   * Sign request with ECDSA signature using SHA3 hash
   *
   * EdgeX authentication process:
   * 1. Create message: {timestamp}{METHOD}{path}{sorted_params}
   * 2. Hash with SHA3-256
   * 3. Sign with ECDSA using private key
   *
   * @see https://edgex-1.gitbook.io/edgeX-documentation/api/authentication
   */
  async signRequest(method, path, timestamp, body) {
    try {
      const [basePath, queryString] = path.split("?");
      let sortedParams = "";
      if (queryString) {
        const params = new URLSearchParams(queryString);
        const sortedKeys = Array.from(params.keys()).sort();
        sortedParams = sortedKeys.map((k) => `${k}=${params.get(k)}`).join("&");
      } else if (body) {
        const sortedKeys = Object.keys(body).sort();
        sortedParams = sortedKeys.map((k) => `${k}=${body[k]}`).join("&");
      }
      const message = `${timestamp}${method.toUpperCase()}${basePath}${sortedParams}`;
      const messageHash = await createSha3HashBuffer(message);
      const signature = import_starknet2.ec.starkCurve.sign(messageHash, this.starkPrivateKey);
      return `0x${signature.r.toString(16).padStart(64, "0")}${signature.s.toString(16).padStart(64, "0")}`;
    } catch (error) {
      throw new PerpDEXError(
        `Failed to sign request: ${error instanceof Error ? error.message : String(error)}`,
        "SIGNATURE_ERROR",
        "edgex"
      );
    }
  }
  /**
   * Verify if credentials are available
   */
  hasCredentials() {
    return !!this.starkPrivateKey;
  }
};

// src/adapters/edgex/utils.ts
function toEdgeXOrderType(type) {
  return type === "market" ? EDGEX_ORDER_TYPES.market : EDGEX_ORDER_TYPES.limit;
}
function toEdgeXOrderSide(side) {
  return side === "buy" ? EDGEX_ORDER_SIDES.buy : EDGEX_ORDER_SIDES.sell;
}
function toEdgeXTimeInForce(tif) {
  switch (tif) {
    case "IOC":
      return EDGEX_TIME_IN_FORCE.IOC;
    case "FOK":
      return EDGEX_TIME_IN_FORCE.FOK;
    case "GTC":
    default:
      return EDGEX_TIME_IN_FORCE.GTC;
  }
}
function mapEdgeXError(error) {
  if (typeof error === "object" && error !== null) {
    const err2 = error;
    switch (err2.code) {
      case 1001:
        return { code: "INVALID_ORDER", message: "Invalid order parameters" };
      case 1002:
        return { code: "INSUFFICIENT_MARGIN", message: "Insufficient margin" };
      case 1003:
        return { code: "ORDER_NOT_FOUND", message: "Order not found" };
      case 1004:
        return { code: "POSITION_NOT_FOUND", message: "Position not found" };
      case 2001:
        return { code: "INVALID_SIGNATURE", message: "Invalid signature" };
      case 2002:
        return { code: "EXPIRED_AUTH", message: "Authentication expired" };
      case 2003:
        return { code: "INVALID_API_KEY", message: "Invalid API key" };
      case 4001:
        return { code: "RATE_LIMIT_EXCEEDED", message: "Rate limit exceeded" };
      case 5001:
        return { code: "EXCHANGE_UNAVAILABLE", message: "Exchange unavailable" };
      default:
        return {
          code: "UNKNOWN_ERROR",
          message: err2.message ?? "Unknown error occurred"
        };
    }
  }
  return { code: "UNKNOWN_ERROR", message: "Unknown error occurred" };
}

// src/adapters/edgex/EdgeXAdapter.ts
var EdgeXAdapter = class extends BaseAdapter {
  id = "edgex";
  name = "EdgeX";
  has = {
    fetchMarkets: true,
    fetchTicker: true,
    fetchOrderBook: true,
    fetchTrades: false,
    // Not available via REST, use watchTrades for WebSocket
    fetchFundingRate: true,
    fetchFundingRateHistory: false,
    fetchPositions: true,
    fetchBalance: true,
    fetchOpenOrders: true,
    fetchOrder: true,
    fetchOrderHistory: true,
    fetchMyTrades: true,
    createOrder: true,
    createBatchOrders: true,
    editOrder: true,
    cancelOrder: true,
    cancelAllOrders: true,
    setLeverage: true,
    watchOrderBook: true,
    watchTrades: true,
    watchTicker: true,
    watchPositions: true,
    watchOrders: true,
    watchBalance: true
  };
  auth;
  baseUrl;
  rateLimiter;
  normalizer;
  constructor(config = {}) {
    super(config);
    if (config.starkPrivateKey) {
      this.auth = new EdgeXAuth({ starkPrivateKey: config.starkPrivateKey });
    }
    this.normalizer = new EdgeXNormalizer();
    this.rateLimiter = new RateLimiter({
      maxTokens: EDGEX_RATE_LIMITS.rest.maxRequests,
      refillRate: EDGEX_RATE_LIMITS.rest.maxRequests / (EDGEX_RATE_LIMITS.rest.windowMs / 1e3),
      windowMs: EDGEX_RATE_LIMITS.rest.windowMs,
      weights: EDGEX_ENDPOINT_WEIGHTS
    });
    const urls = config.testnet ? EDGEX_API_URLS.testnet : EDGEX_API_URLS.mainnet;
    this.baseUrl = urls.rest;
  }
  /**
   * Initialize the adapter
   * Note: starkPrivateKey is only required for private API operations (trading)
   */
  async initialize() {
    this._isReady = true;
  }
  /**
   * Require authentication for private API operations
   */
  requireAuth() {
    if (!this.auth) {
      throw new PerpDEXError(
        "Authentication required. Provide starkPrivateKey in config.",
        "MISSING_CREDENTIALS",
        "edgex"
      );
    }
  }
  /**
   * Cleanup resources
   */
  async disconnect() {
  }
  /**
   * Fetch all available markets
   */
  async fetchMarkets(_params) {
    const response = await this.makeRequest("GET", "/api/v1/public/meta/getMetaData", "fetchMarkets");
    if (response.code === "SUCCESS" && response.data?.contractList) {
      return response.data.contractList.map((market) => this.normalizer.normalizeMarket(market));
    }
    if (Array.isArray(response.markets)) {
      return response.markets.map((market) => this.normalizer.normalizeMarket(market));
    }
    throw new PerpDEXError("Invalid markets response", "INVALID_RESPONSE", "edgex");
  }
  /**
   * Fetch ticker for a symbol
   */
  async fetchTicker(symbol) {
    const contractId = this.normalizer.toEdgeXContractId(symbol);
    const response = await this.makeRequest(
      "GET",
      `/api/v1/public/quote/getTicker?contractId=${contractId}`,
      "fetchTicker"
    );
    if (response.code !== "SUCCESS" || !Array.isArray(response.data) || response.data.length === 0) {
      throw new PerpDEXError("Invalid ticker response", "INVALID_RESPONSE", "edgex");
    }
    return this.normalizer.normalizeTicker(response.data[0]);
  }
  /**
   * Fetch order book for a symbol
   * Note: EdgeX only supports level=15 or level=200 for order book depth
   */
  async fetchOrderBook(symbol, params) {
    const contractId = this.normalizer.toEdgeXContractId(symbol);
    const level = params?.limit && params.limit > 15 ? 200 : 15;
    const response = await this.makeRequest(
      "GET",
      `/api/v1/public/quote/getDepth?contractId=${contractId}&level=${level}`,
      "fetchOrderBook"
    );
    if (response.code !== "SUCCESS" || !Array.isArray(response.data) || response.data.length === 0) {
      throw new PerpDEXError("Invalid order book response", "INVALID_RESPONSE", "edgex");
    }
    return this.normalizer.normalizeOrderBook(response.data[0], symbol);
  }
  /**
   * Fetch recent trades for a symbol
   * Note: EdgeX does not expose public trades via REST API.
   * Use WebSocket (watchTrades) for real-time trade data.
   */
  async fetchTrades(_symbol, _params) {
    throw new PerpDEXError(
      "EdgeX does not support fetchTrades via REST API. Use watchTrades() for WebSocket streaming.",
      "NOT_IMPLEMENTED",
      "edgex"
    );
  }
  /**
   * Fetch current funding rate
   */
  async fetchFundingRate(symbol) {
    const contractId = this.normalizer.toEdgeXContractId(symbol);
    const response = await this.makeRequest(
      "GET",
      `/api/v1/public/funding/getLatestFundingRate?contractId=${contractId}`,
      "fetchFundingRate"
    );
    if (response.code !== "SUCCESS" || !Array.isArray(response.data) || response.data.length === 0) {
      throw new PerpDEXError("Invalid funding rate response", "INVALID_RESPONSE", "edgex");
    }
    return this.normalizer.normalizeFundingRate(response.data[0], symbol);
  }
  /**
   * Fetch funding rate history
   */
  async fetchFundingRateHistory(_symbol, _since, _limit) {
    throw new PerpDEXError(
      "EdgeX does not support funding rate history",
      "NOT_SUPPORTED",
      "edgex"
    );
  }
  /**
   * Fetch all open positions
   */
  async fetchPositions(symbols) {
    this.requireAuth();
    const response = await this.makeRequest("GET", "/api/v1/private/account/getPositionList", "fetchPositions");
    if (!Array.isArray(response.positions)) {
      throw new PerpDEXError("Invalid positions response", "INVALID_RESPONSE", "edgex");
    }
    let positions = response.positions.map((position) => this.normalizer.normalizePosition(position));
    if (symbols && symbols.length > 0) {
      positions = positions.filter((p) => symbols.includes(p.symbol));
    }
    return positions;
  }
  /**
   * Fetch account balance
   */
  async fetchBalance() {
    this.requireAuth();
    const response = await this.makeRequest("GET", "/api/v1/private/account/getCollateralBalance", "fetchBalance");
    if (!Array.isArray(response.balances)) {
      throw new PerpDEXError("Invalid balance response", "INVALID_RESPONSE", "edgex");
    }
    return response.balances.map((balance) => this.normalizer.normalizeBalance(balance));
  }
  /**
   * Create a new order
   */
  async createOrder(request) {
    const validatedRequest = this.validateOrder(request);
    this.requireAuth();
    const market = this.normalizer.toEdgeXSymbol(validatedRequest.symbol);
    const orderType = toEdgeXOrderType(validatedRequest.type);
    const side = toEdgeXOrderSide(validatedRequest.side);
    const timeInForce = toEdgeXTimeInForce(validatedRequest.timeInForce);
    const payload = {
      market,
      side,
      type: orderType,
      size: validatedRequest.amount.toString(),
      price: validatedRequest.price?.toString(),
      time_in_force: timeInForce,
      reduce_only: validatedRequest.reduceOnly ?? false,
      post_only: validatedRequest.postOnly ?? false,
      client_order_id: validatedRequest.clientOrderId
    };
    const response = await this.makeRequest("POST", "/api/v1/private/order/createOrder", "createOrder", payload);
    return this.normalizer.normalizeOrder(response);
  }
  /**
   * Cancel an existing order
   */
  async cancelOrder(orderId, _symbol) {
    this.requireAuth();
    const response = await this.makeRequest("POST", "/api/v1/private/order/cancelOrder", "cancelOrder", { orderId });
    return this.normalizer.normalizeOrder(response);
  }
  /**
   * Cancel all orders
   */
  async cancelAllOrders(symbol) {
    this.requireAuth();
    const contractId = symbol ? this.normalizer.toEdgeXContractId(symbol) : void 0;
    const params = contractId ? `?contractId=${contractId}` : "";
    const response = await this.makeRequest("DELETE", `/api/v1/private/order/cancelAllOrder${params}`, "cancelAllOrders");
    if (!Array.isArray(response.orders)) {
      throw new PerpDEXError("Invalid cancel all orders response", "INVALID_RESPONSE", "edgex");
    }
    return response.orders.map((order) => this.normalizer.normalizeOrder(order));
  }
  /**
   * Create multiple orders in a single request
   *
   * @param orders - Array of order requests
   * @returns Array of created orders
   */
  async createBatchOrders(orders) {
    this.requireAuth();
    const batchPayload = orders.map((order) => {
      const market = this.normalizer.toEdgeXSymbol(order.symbol);
      const orderType = toEdgeXOrderType(order.type);
      const side = toEdgeXOrderSide(order.side);
      const timeInForce = toEdgeXTimeInForce(order.timeInForce);
      return {
        market,
        side,
        type: orderType,
        size: order.amount.toString(),
        price: order.price?.toString(),
        time_in_force: timeInForce,
        reduce_only: order.reduceOnly ?? false,
        post_only: order.postOnly ?? false,
        client_order_id: order.clientOrderId
      };
    });
    const response = await this.makeRequest(
      "POST",
      "/api/v1/private/order/batchCreateOrder",
      "createBatchOrders",
      { orders: batchPayload }
    );
    if (response.code !== "SUCCESS" || !Array.isArray(response.data?.orders)) {
      if (response.code === "NOT_FOUND" || !response.data) {
        throw new PerpDEXError("Batch orders endpoint not available", "NOT_SUPPORTED", "edgex");
      }
      throw new PerpDEXError("Invalid batch orders response", "INVALID_RESPONSE", "edgex");
    }
    return response.data.orders.map((order) => this.normalizer.normalizeOrder(order));
  }
  /**
   * Modify an existing order
   *
   * @param orderId - Order ID to modify
   * @param symbol - Trading symbol
   * @param type - Order type (market/limit)
   * @param side - Order side (buy/sell)
   * @param amount - New order amount (optional)
   * @param price - New order price (optional)
   * @returns Modified order
   */
  async modifyOrder(orderId, _symbol, _type, _side, amount, price) {
    this.requireAuth();
    const payload = {
      orderId
    };
    if (amount !== void 0) {
      payload.size = amount.toString();
    }
    if (price !== void 0) {
      payload.price = price.toString();
    }
    const response = await this.makeRequest(
      "POST",
      "/api/v1/private/order/modifyOrder",
      "modifyOrder",
      payload
    );
    if (response.code !== "SUCCESS" || !response.data) {
      if (response.code === "NOT_FOUND") {
        throw new PerpDEXError("Order not found", "ORDER_NOT_FOUND", "edgex");
      }
      throw new PerpDEXError("Invalid modify order response", "INVALID_RESPONSE", "edgex");
    }
    return this.normalizer.normalizeOrder(response.data);
  }
  /**
   * Fetch open orders
   */
  async fetchOpenOrders(symbol) {
    this.requireAuth();
    const contractId = symbol ? this.normalizer.toEdgeXContractId(symbol) : void 0;
    const params = contractId ? `?contractId=${contractId}` : "";
    const response = await this.makeRequest("GET", `/api/v1/private/order/getOpenOrderList${params}`, "fetchOpenOrders");
    if (!Array.isArray(response.orders)) {
      throw new PerpDEXError("Invalid open orders response", "INVALID_RESPONSE", "edgex");
    }
    return response.orders.map((order) => this.normalizer.normalizeOrder(order));
  }
  /**
   * Fetch a specific order
   */
  async fetchOrder(orderId, _symbol) {
    this.requireAuth();
    const response = await this.makeRequest("GET", `/api/v1/private/order/getOrder?orderId=${orderId}`, "fetchOrder");
    return this.normalizer.normalizeOrder(response);
  }
  /**
   * Set leverage for a symbol
   */
  async setLeverage(symbol, leverage) {
    const market = this.normalizer.toEdgeXSymbol(symbol);
    await this.makeRequest("POST", "/account/leverage", "setLeverage", {
      market,
      leverage: leverage.toString()
    });
  }
  /**
   * Fetch order history
   *
   * Retrieves closed/filled orders from EdgeX.
   * Uses /api/v1/private/order/getOrderFillTransactionPage endpoint.
   *
   * @param symbol - Optional symbol filter
   * @param since - Optional start timestamp
   * @param limit - Optional limit (default 100, max 500)
   * @returns Array of historical orders
   */
  async fetchOrderHistory(symbol, since, limit) {
    this.requireAuth();
    const params = {};
    if (symbol) {
      params.contractId = this.normalizer.toEdgeXContractId(symbol);
    }
    if (since) {
      params.startTime = since.toString();
    }
    if (limit) {
      params.size = Math.min(limit, 500).toString();
    }
    const queryString = Object.entries(params).map(([k, v]) => `${k}=${v}`).join("&");
    const path = `/api/v1/private/order/getOrderFillTransactionPage${queryString ? `?${queryString}` : ""}`;
    const response = await this.makeRequest("GET", path, "fetchOrderHistory");
    if (response.code !== "SUCCESS" || !Array.isArray(response.data?.dataList)) {
      if (response.code === "NOT_FOUND" || !response.data) {
        return [];
      }
      throw new PerpDEXError("Invalid order history response", "INVALID_RESPONSE", "edgex");
    }
    return response.data.dataList.map((order) => this.normalizer.normalizeOrder(order));
  }
  /**
   * Fetch user trade history
   *
   * Retrieves user's executed trades from EdgeX.
   * Uses /api/v1/private/order/getOrderFillTransactionPage endpoint.
   *
   * @param symbol - Optional symbol filter
   * @param since - Optional start timestamp
   * @param limit - Optional limit (default 100, max 500)
   * @returns Array of trades
   */
  async fetchMyTrades(symbol, since, limit) {
    this.requireAuth();
    const params = {};
    if (symbol) {
      params.contractId = this.normalizer.toEdgeXContractId(symbol);
    }
    if (since) {
      params.startTime = since.toString();
    }
    if (limit) {
      params.size = Math.min(limit, 500).toString();
    }
    const queryString = Object.entries(params).map(([k, v]) => `${k}=${v}`).join("&");
    const path = `/api/v1/private/order/getOrderFillTransactionPage${queryString ? `?${queryString}` : ""}`;
    const response = await this.makeRequest("GET", path, "fetchMyTrades");
    if (response.code !== "SUCCESS" || !Array.isArray(response.data?.dataList)) {
      if (response.code === "NOT_FOUND" || !response.data) {
        return [];
      }
      throw new PerpDEXError("Invalid trades response", "INVALID_RESPONSE", "edgex");
    }
    return response.data.dataList.map((trade) => this.normalizer.normalizeTrade(trade));
  }
  /**
   * Convert unified symbol to exchange format
   */
  symbolToExchange(symbol) {
    return this.normalizer.toEdgeXSymbol(symbol);
  }
  /**
   * Convert exchange symbol to unified format
   */
  symbolFromExchange(exchangeSymbol) {
    return this.normalizer.normalizeSymbol(exchangeSymbol);
  }
  /**
   * Make HTTP request
   * Authentication headers are added for private endpoints
   */
  async makeRequest(method, path, endpoint, body) {
    await this.rateLimiter.acquire(endpoint);
    const url = `${this.baseUrl}${path}`;
    const headers = {
      "Content-Type": "application/json"
    };
    const isPrivateEndpoint = path.includes("/private/");
    if (isPrivateEndpoint && this.auth) {
      const timestamp = Date.now().toString();
      headers["X-edgeX-Api-Timestamp"] = timestamp;
      headers["X-edgeX-Api-Signature"] = await this.auth.signRequest(method, path, timestamp, body);
    }
    try {
      const response = await fetch(url, {
        method,
        headers,
        body: body ? JSON.stringify(body) : void 0
      });
      if (!response.ok) {
        const error = await response.json().catch(() => ({}));
        const { code } = mapEdgeXError(error);
        throw new PerpDEXError(`EdgeX API error: ${response.statusText}`, code, "edgex", error);
      }
      return await response.json();
    } catch (error) {
      if (error instanceof PerpDEXError) {
        throw error;
      }
      const { code } = mapEdgeXError(error);
      throw new PerpDEXError("Request failed", code, "edgex", error);
    }
  }
};

// src/adapters/backpack/constants.ts
var BACKPACK_API_URLS = {
  mainnet: {
    rest: "https://api.backpack.exchange",
    websocket: "wss://ws.backpack.exchange"
  },
  testnet: {
    rest: "https://api-testnet.backpack.exchange",
    websocket: "wss://ws-testnet.backpack.exchange"
  }
};
var BACKPACK_RATE_LIMITS = {
  rest: {
    maxRequests: 2e3,
    windowMs: 6e4
    // 1 minute
  },
  websocket: {
    maxSubscriptions: 100
  }
};
var BACKPACK_ENDPOINT_WEIGHTS = {
  fetchMarkets: 1,
  fetchTicker: 1,
  fetchOrderBook: 2,
  fetchTrades: 2,
  fetchFundingRate: 1,
  fetchPositions: 3,
  fetchBalance: 2,
  fetchOpenOrders: 3,
  fetchClosedOrders: 5,
  createOrder: 5,
  cancelOrder: 3,
  createBatchOrders: 15,
  cancelAllOrders: 10,
  modifyOrder: 5,
  fetchOrder: 2,
  fetchMyTrades: 5,
  setLeverage: 3
};
var BACKPACK_ORDER_TYPES = {
  market: "Market",
  limit: "Limit",
  postOnly: "PostOnly"
};
var BACKPACK_ORDER_SIDES = {
  buy: "Bid",
  sell: "Ask"
};
var BACKPACK_TIME_IN_FORCE = {
  GTC: "GTC",
  IOC: "IOC",
  FOK: "FOK",
  POST_ONLY: "POST_ONLY"
};

// src/adapters/backpack/BackpackNormalizer.ts
var BackpackNormalizer = class {
  /**
   * Normalize Backpack symbol to unified format
   *
   * Backpack uses underscore-separated format:
   * - New format: SOL_USDC_PERP, BTC_USDC_PERP (base_quote_perp)
   * - Legacy format: BTCUSDT_PERP, SOLUSDT_PERP (basequote_perp - for test compatibility)
   * - Spot: SOL_USDC, BTC_USDC
   *
   * @example
   * normalizeSymbol('SOL_USDC_PERP') // 'SOL/USDC:USDC'
   * normalizeSymbol('BTCUSDT_PERP') // 'BTC/USDT:USDT' (legacy)
   * normalizeSymbol('SOL_USDC') // 'SOL/USDC'
   */
  normalizeSymbol(backpackSymbol) {
    if (backpackSymbol.endsWith("_PERP")) {
      const withoutPerp = backpackSymbol.replace("_PERP", "");
      const parts2 = withoutPerp.split("_");
      if (parts2.length >= 2) {
        const base = parts2[0];
        const quote = parts2[1];
        return `${base}/${quote}:${quote}`;
      } else {
        const pair = parts2[0] || "";
        const quoteMatch = pair.match(/(USDT|USDC|USD)$/);
        if (quoteMatch && quoteMatch[1]) {
          const quote = quoteMatch[1];
          const base = pair.replace(quote, "");
          return `${base}/${quote}:${quote}`;
        }
      }
    }
    const parts = backpackSymbol.split("_");
    if (parts.length >= 2) {
      const base = parts[0];
      const quote = parts[1];
      return `${base}/${quote}`;
    } else {
      const quoteMatch = backpackSymbol.match(/(USDT|USDC|USD)$/);
      if (quoteMatch && quoteMatch[1]) {
        const quote = quoteMatch[1];
        const base = backpackSymbol.replace(quote, "");
        return `${base}/${quote}`;
      }
    }
    return backpackSymbol;
  }
  /**
   * Convert unified symbol to Backpack format
   *
   * @example
   * toBackpackSymbol('SOL/USDC:USDC') // 'SOL_USDC_PERP'
   * toBackpackSymbol('BTC/USDC:USDC') // 'BTC_USDC_PERP'
   * toBackpackSymbol('SOL/USDC') // 'SOL_USDC'
   */
  toBackpackSymbol(symbol) {
    const parts = symbol.split(":");
    if (parts.length === 2) {
      const [pair = ""] = parts;
      const [base2 = "", quote2 = ""] = pair.split("/");
      return `${base2}_${quote2}_PERP`;
    }
    const [base = "", quote = ""] = symbol.split("/");
    if (base && quote) {
      return `${base}_${quote}`;
    }
    return symbol;
  }
  /**
   * Normalize Backpack market to unified format
   */
  normalizeMarket(backpackMarket) {
    const symbol = this.normalizeSymbol(backpackMarket.symbol);
    const isPerpetual2 = backpackMarket.marketType === "PERP" || backpackMarket.symbol.endsWith("_PERP");
    const priceFilters = backpackMarket.filters?.price ?? { tickSize: "0.01" };
    const quantityFilters = backpackMarket.filters?.quantity ?? { stepSize: "0.001", minQuantity: "0.001" };
    return {
      id: backpackMarket.symbol,
      symbol,
      base: backpackMarket.baseSymbol || symbol.split("/")[0] || "",
      quote: backpackMarket.quoteSymbol || symbol.split("/")[1]?.split(":")[0] || "",
      settle: backpackMarket.quoteSymbol || symbol.split("/")[1]?.split(":")[0] || "",
      active: backpackMarket.visible !== false && backpackMarket.orderBookState !== "Closed",
      minAmount: parseFloat(quantityFilters.minQuantity || "0"),
      pricePrecision: this.countDecimals(priceFilters.tickSize || "0.01"),
      amountPrecision: this.countDecimals(quantityFilters.stepSize || "0.001"),
      priceTickSize: parseFloat(priceFilters.tickSize || "0.01"),
      amountStepSize: parseFloat(quantityFilters.stepSize || "0.001"),
      makerFee: 0,
      // Not provided in market endpoint
      takerFee: 0,
      // Not provided in market endpoint
      maxLeverage: isPerpetual2 ? 20 : 1,
      // Perpetuals support leverage
      fundingIntervalHours: backpackMarket.fundingInterval ? backpackMarket.fundingInterval / 36e5 : 1
    };
  }
  /**
   * Normalize Backpack order to unified format
   */
  normalizeOrder(backpackOrder) {
    const symbol = this.normalizeSymbol(backpackOrder.market);
    return {
      id: backpackOrder.order_id,
      clientOrderId: backpackOrder.client_order_id,
      symbol,
      type: this.normalizeOrderType(backpackOrder.type),
      side: this.normalizeOrderSide(backpackOrder.side),
      amount: parseFloat(backpackOrder.size),
      price: backpackOrder.price ? parseFloat(backpackOrder.price) : void 0,
      filled: parseFloat(backpackOrder.filled_size),
      remaining: parseFloat(backpackOrder.size) - parseFloat(backpackOrder.filled_size),
      averagePrice: backpackOrder.avg_price ? parseFloat(backpackOrder.avg_price) : void 0,
      status: this.normalizeOrderStatus(backpackOrder.status),
      timeInForce: this.normalizeTimeInForce(backpackOrder.time_in_force),
      postOnly: backpackOrder.post_only,
      reduceOnly: backpackOrder.reduce_only,
      timestamp: backpackOrder.created_at,
      lastUpdateTimestamp: backpackOrder.updated_at,
      info: backpackOrder
    };
  }
  /**
   * Normalize Backpack position to unified format
   */
  normalizePosition(backpackPosition) {
    const symbol = this.normalizeSymbol(backpackPosition.market);
    const size = parseFloat(backpackPosition.size);
    const side = backpackPosition.side === "LONG" ? "long" : "short";
    return {
      symbol,
      side,
      marginMode: "cross",
      size: Math.abs(size),
      entryPrice: parseFloat(backpackPosition.entry_price),
      markPrice: parseFloat(backpackPosition.mark_price),
      liquidationPrice: backpackPosition.liquidation_price ? parseFloat(backpackPosition.liquidation_price) : 0,
      unrealizedPnl: parseFloat(backpackPosition.unrealized_pnl),
      realizedPnl: parseFloat(backpackPosition.realized_pnl),
      margin: parseFloat(backpackPosition.margin),
      leverage: parseFloat(backpackPosition.leverage),
      maintenanceMargin: parseFloat(backpackPosition.margin) * 0.05,
      marginRatio: 0,
      timestamp: backpackPosition.timestamp,
      info: backpackPosition
    };
  }
  /**
   * Normalize Backpack balance to unified format
   */
  normalizeBalance(backpackBalance) {
    return {
      currency: backpackBalance.asset,
      total: parseFloat(backpackBalance.total),
      free: parseFloat(backpackBalance.available),
      used: parseFloat(backpackBalance.locked),
      info: backpackBalance
    };
  }
  /**
   * Normalize Backpack order book to unified format
   */
  normalizeOrderBook(backpackOrderBook, symbol) {
    return {
      symbol: symbol || "",
      exchange: "backpack",
      bids: backpackOrderBook.bids.map(([price, size]) => [parseFloat(price), parseFloat(size)]),
      asks: backpackOrderBook.asks.map(([price, size]) => [parseFloat(price), parseFloat(size)]),
      timestamp: Date.now()
    };
  }
  /**
   * Normalize Backpack trade to unified format
   */
  normalizeTrade(backpackTrade, symbol) {
    const price = parseFloat(backpackTrade.price);
    const amount = parseFloat(backpackTrade.quantity);
    return {
      id: backpackTrade.id.toString(),
      symbol: symbol || "",
      // isBuyerMaker = true means the maker was a buyer, so the taker (aggressor) was selling
      side: backpackTrade.isBuyerMaker ? "sell" : "buy",
      price,
      amount,
      cost: parseFloat(backpackTrade.quoteQuantity),
      timestamp: backpackTrade.timestamp,
      info: backpackTrade
    };
  }
  /**
   * Normalize Backpack ticker to unified format
   */
  normalizeTicker(backpackTicker) {
    const last = parseFloat(backpackTicker.lastPrice);
    const first = parseFloat(backpackTicker.firstPrice);
    const change = parseFloat(backpackTicker.priceChange);
    const percentage = parseFloat(backpackTicker.priceChangePercent) * 100;
    return {
      symbol: this.normalizeSymbol(backpackTicker.symbol),
      last,
      open: first,
      close: last,
      bid: 0,
      // Not provided in ticker endpoint
      ask: 0,
      // Not provided in ticker endpoint
      high: parseFloat(backpackTicker.high),
      low: parseFloat(backpackTicker.low),
      change,
      percentage,
      baseVolume: parseFloat(backpackTicker.volume),
      quoteVolume: parseFloat(backpackTicker.quoteVolume),
      timestamp: Date.now(),
      info: backpackTicker
    };
  }
  /**
   * Normalize Backpack funding rate to unified format
   */
  normalizeFundingRate(backpackFunding) {
    const fundingTimestamp = new Date(backpackFunding.intervalEndTimestamp).getTime();
    return {
      symbol: this.normalizeSymbol(backpackFunding.symbol),
      fundingRate: parseFloat(backpackFunding.fundingRate),
      fundingTimestamp,
      nextFundingTimestamp: fundingTimestamp + 36e5,
      // Hourly funding
      // Backpack funding rate endpoint doesn't include mark/index price
      markPrice: 0,
      indexPrice: 0,
      // Hourly funding
      fundingIntervalHours: 1,
      info: backpackFunding
    };
  }
  /**
   * Normalize Backpack order type to unified format
   * Backpack API returns PascalCase: 'Market', 'Limit', 'PostOnly'
   */
  normalizeOrderType(backpackType) {
    switch (backpackType) {
      case "Market":
      case "MARKET":
        return "market";
      case "Limit":
      case "LIMIT":
      case "PostOnly":
      case "POST_ONLY":
        return "limit";
      default:
        return "limit";
    }
  }
  /**
   * Normalize Backpack order side to unified format
   * Backpack API returns 'Bid' (buy) / 'Ask' (sell)
   */
  normalizeOrderSide(backpackSide) {
    return backpackSide === "Bid" || backpackSide === "BUY" ? "buy" : "sell";
  }
  /**
   * Normalize Backpack order status to unified format
   * Backpack API returns PascalCase: 'New', 'Open', 'PartiallyFilled', 'Filled', 'Cancelled'
   */
  normalizeOrderStatus(backpackStatus) {
    const statusMap = {
      // PascalCase (actual API format)
      New: "open",
      Open: "open",
      PartiallyFilled: "partiallyFilled",
      Filled: "filled",
      Cancelled: "canceled",
      Rejected: "rejected",
      // UPPER_CASE (legacy/backward compat)
      PENDING: "open",
      NEW: "open",
      OPEN: "open",
      PARTIAL: "partiallyFilled",
      PARTIALLY_FILLED: "partiallyFilled",
      FILLED: "filled",
      CANCELLED: "canceled",
      REJECTED: "rejected"
    };
    return statusMap[backpackStatus] ?? "open";
  }
  /**
   * Normalize Backpack time in force to unified format
   */
  normalizeTimeInForce(backpackTif) {
    switch (backpackTif) {
      case "GTC":
        return "GTC";
      case "IOC":
        return "IOC";
      case "FOK":
        return "FOK";
      default:
        return "GTC";
    }
  }
  /**
   * Count decimal places in a string number
   */
  countDecimals(value) {
    if (!value) return 0;
    const parts = value.split(".");
    return parts.length === 2 && parts[1] ? parts[1].length : 0;
  }
};

// src/adapters/backpack/BackpackAuth.ts
init_ed25519();

// src/utils/buffer.ts
var isBrowser3 = typeof window !== "undefined";
function toBuffer(data, encoding) {
  if (data instanceof Uint8Array) {
    return data;
  }
  if (encoding === "hex") {
    return hexToBytes3(data);
  }
  if (encoding === "base64") {
    return base64ToBytes(data);
  }
  return new TextEncoder().encode(data);
}
function fromBuffer(data, encoding) {
  if (encoding === "hex") {
    return bytesToHex3(data);
  }
  if (encoding === "base64") {
    return bytesToBase64(data);
  }
  return new TextDecoder().decode(data);
}
function allocBuffer(size) {
  return new Uint8Array(size);
}
function readBigUInt64LE(data, offset = 0) {
  const view = new DataView(data.buffer, data.byteOffset + offset, 8);
  return view.getBigUint64(0, true);
}
function readBigUInt64BE(data, offset = 0) {
  const view = new DataView(data.buffer, data.byteOffset + offset, 8);
  return view.getBigUint64(0, false);
}
function writeBigUInt64LE(data, value, offset = 0) {
  const view = new DataView(data.buffer, data.byteOffset + offset, 8);
  view.setBigUint64(0, value, true);
}
function writeBigUInt64BE(data, value, offset = 0) {
  const view = new DataView(data.buffer, data.byteOffset + offset, 8);
  view.setBigUint64(0, value, false);
}
function concatBuffers(...arrays) {
  const totalLength = arrays.reduce((acc, arr) => acc + arr.length, 0);
  const result = new Uint8Array(totalLength);
  let offset = 0;
  for (const arr of arrays) {
    result.set(arr, offset);
    offset += arr.length;
  }
  return result;
}
function buffersEqual(a, b) {
  if (a.length !== b.length) {
    return false;
  }
  for (let i = 0; i < a.length; i++) {
    if (a[i] !== b[i]) {
      return false;
    }
  }
  return true;
}
function copyBuffer(data) {
  return new Uint8Array(data);
}
function sliceBuffer(data, start = 0, end) {
  return data.slice(start, end);
}
function hexToBytes3(hex) {
  const cleanHex = hex.startsWith("0x") ? hex.slice(2) : hex;
  if (cleanHex.length % 2 !== 0) {
    throw new Error("Invalid hex string: odd length");
  }
  const bytes = new Uint8Array(cleanHex.length / 2);
  for (let i = 0; i < cleanHex.length; i += 2) {
    const byte = parseInt(cleanHex.substr(i, 2), 16);
    if (isNaN(byte)) {
      throw new Error(`Invalid hex character at position ${i}`);
    }
    bytes[i / 2] = byte;
  }
  return bytes;
}
function bytesToHex3(bytes) {
  return Array.from(bytes).map((b) => b.toString(16).padStart(2, "0")).join("");
}
function base64ToBytes(base64) {
  if (isBrowser3) {
    const binary = atob(base64);
    const bytes = new Uint8Array(binary.length);
    for (let i = 0; i < binary.length; i++) {
      bytes[i] = binary.charCodeAt(i);
    }
    return bytes;
  } else {
    return new Uint8Array(Buffer.from(base64, "base64"));
  }
}
function bytesToBase64(bytes) {
  if (isBrowser3) {
    const binary = String.fromCharCode(...bytes);
    return btoa(binary);
  } else {
    return Buffer.from(bytes).toString("base64");
  }
}

// src/adapters/backpack/BackpackAuth.ts
var BackpackAuth = class {
  apiKey;
  apiSecret;
  constructor(config) {
    this.apiKey = config.apiKey;
    this.apiSecret = config.apiSecret;
  }
  /**
   * Sign a request with ED25519 signature
   */
  async sign(request) {
    const timestamp = Date.now().toString();
    const instruction = request.instruction ?? "";
    const signature = await this.signRequest(
      instruction,
      timestamp,
      request.body
    );
    return {
      ...request,
      headers: {
        ...this.getHeaders(),
        "X-API-KEY": this.apiKey,
        "X-Timestamp": timestamp,
        "X-Window": "5000",
        "X-Signature": signature
      }
    };
  }
  /**
   * Get authentication headers
   */
  getHeaders() {
    return {
      "Content-Type": "application/json",
      "X-API-KEY": this.apiKey
    };
  }
  /**
   * Sign request with ED25519 signature
   *
   * Backpack requires alphabetized query/body params with instruction prefix:
   * `instruction=orderExecute&orderType=Limit&price=100&...&timestamp=...&window=5000`
   *
   * Uses cross-platform buffer utilities for browser compatibility
   */
  async signRequest(instruction, timestamp, body) {
    try {
      const params = {};
      if (instruction) {
        params.instruction = instruction;
      }
      if (body) {
        for (const [key, value] of Object.entries(body)) {
          if (value !== void 0 && value !== null) {
            params[key] = String(value);
          }
        }
      }
      params.timestamp = timestamp;
      params.window = "5000";
      const sortedKeys = Object.keys(params).sort();
      const message = sortedKeys.map((k) => `${k}=${params[k]}`).join("&");
      const messageBytes = new TextEncoder().encode(message);
      let privateKey;
      if (this.apiSecret.startsWith("0x")) {
        privateKey = toBuffer(this.apiSecret.slice(2), "hex");
      } else if (/^[0-9a-fA-F]+$/.test(this.apiSecret)) {
        privateKey = toBuffer(this.apiSecret, "hex");
      } else {
        privateKey = toBuffer(this.apiSecret, "base64");
      }
      const signature = await signAsync(messageBytes, privateKey);
      return fromBuffer(new Uint8Array(signature), "base64");
    } catch (error) {
      throw new PerpDEXError(
        `Failed to sign request: ${error instanceof Error ? error.message : String(error)}`,
        "SIGNATURE_ERROR",
        "backpack"
      );
    }
  }
  /**
   * Verify if credentials are available
   */
  hasCredentials() {
    return !!(this.apiKey && this.apiSecret);
  }
  /**
   * Get the API key
   */
  getApiKey() {
    return this.apiKey;
  }
};

// src/adapters/backpack/utils.ts
function toBackpackOrderType(type, postOnly) {
  if (type === "market") {
    return BACKPACK_ORDER_TYPES.market;
  }
  if (postOnly) {
    return BACKPACK_ORDER_TYPES.postOnly;
  }
  return BACKPACK_ORDER_TYPES.limit;
}
function toBackpackOrderSide(side) {
  return side === "buy" ? BACKPACK_ORDER_SIDES.buy : BACKPACK_ORDER_SIDES.sell;
}
function toBackpackTimeInForce(tif, postOnly) {
  if (postOnly) {
    return BACKPACK_TIME_IN_FORCE.POST_ONLY;
  }
  switch (tif) {
    case "IOC":
      return BACKPACK_TIME_IN_FORCE.IOC;
    case "FOK":
      return BACKPACK_TIME_IN_FORCE.FOK;
    case "PO":
      return BACKPACK_TIME_IN_FORCE.POST_ONLY;
    case "GTC":
    default:
      return BACKPACK_TIME_IN_FORCE.GTC;
  }
}
function mapBackpackError(error) {
  if (typeof error === "object" && error !== null) {
    const err2 = error;
    switch (err2.code) {
      case 1001:
        return { code: "INVALID_ORDER", message: "Invalid order parameters" };
      case 1002:
        return { code: "INSUFFICIENT_MARGIN", message: "Insufficient margin" };
      case 1003:
        return { code: "ORDER_NOT_FOUND", message: "Order not found" };
      case 1004:
        return { code: "POSITION_NOT_FOUND", message: "Position not found" };
      case 2001:
        return { code: "INVALID_SIGNATURE", message: "Invalid signature" };
      case 2002:
        return { code: "EXPIRED_AUTH", message: "Authentication expired" };
      case 2003:
        return { code: "INVALID_API_KEY", message: "Invalid API key" };
      case 4001:
        return { code: "RATE_LIMIT_EXCEEDED", message: "Rate limit exceeded" };
      case 5001:
        return { code: "EXCHANGE_UNAVAILABLE", message: "Exchange unavailable" };
      default:
        return {
          code: "UNKNOWN_ERROR",
          message: err2.message ?? "Unknown error occurred"
        };
    }
  }
  return { code: "UNKNOWN_ERROR", message: "Unknown error occurred" };
}

// src/adapters/backpack/BackpackAdapter.ts
var BackpackAdapter = class _BackpackAdapter extends BaseAdapter {
  id = "backpack";
  name = "Backpack";
  has = {
    fetchMarkets: true,
    fetchTicker: true,
    fetchOrderBook: true,
    fetchTrades: true,
    fetchFundingRate: true,
    fetchFundingRateHistory: true,
    fetchPositions: true,
    fetchBalance: true,
    fetchOrderHistory: true,
    fetchMyTrades: true,
    createOrder: true,
    cancelOrder: true,
    cancelAllOrders: true,
    setLeverage: true,
    watchOrderBook: true,
    watchTrades: true,
    watchTicker: true,
    watchPositions: true,
    watchOrders: true,
    watchBalance: true
  };
  auth;
  baseUrl;
  httpClient;
  rateLimiter;
  normalizer;
  constructor(config = {}) {
    super(config);
    if (config.apiKey && config.apiSecret) {
      this.auth = new BackpackAuth({ apiKey: config.apiKey, apiSecret: config.apiSecret });
    }
    this.normalizer = new BackpackNormalizer();
    this.rateLimiter = new RateLimiter({
      maxTokens: BACKPACK_RATE_LIMITS.rest.maxRequests,
      refillRate: BACKPACK_RATE_LIMITS.rest.maxRequests / (BACKPACK_RATE_LIMITS.rest.windowMs / 1e3),
      windowMs: BACKPACK_RATE_LIMITS.rest.windowMs,
      weights: BACKPACK_ENDPOINT_WEIGHTS
    });
    const urls = config.testnet ? BACKPACK_API_URLS.testnet : BACKPACK_API_URLS.mainnet;
    this.baseUrl = urls.rest;
    this.httpClient = new HTTPClient({
      baseUrl: this.baseUrl,
      timeout: config.timeout || 3e4,
      retry: {
        maxAttempts: 3,
        initialDelay: 1e3,
        maxDelay: 1e4,
        multiplier: 2,
        retryableStatuses: [408, 429, 500, 502, 503, 504]
      },
      circuitBreaker: {
        enabled: true,
        failureThreshold: 5,
        successThreshold: 2,
        resetTimeout: 6e4
      },
      exchange: this.id
    });
  }
  /**
   * Initialize the adapter
   * Public API methods work without authentication
   */
  async initialize() {
    this._isReady = true;
  }
  /**
   * Check if credentials are available for private API methods
   */
  hasCredentials() {
    return !!this.auth?.hasCredentials();
  }
  /**
   * Require credentials for private methods
   */
  requireAuth() {
    if (!this.hasCredentials()) {
      throw new PerpDEXError(
        "API key and secret are required for this operation",
        "MISSING_CREDENTIALS",
        "backpack"
      );
    }
  }
  /**
   * Cleanup resources
   */
  async disconnect() {
  }
  /**
   * Fetch all available markets
   */
  async fetchMarkets(_params) {
    const response = await this.makeRequest("GET", "/markets", "fetchMarkets");
    if (!Array.isArray(response)) {
      throw new PerpDEXError("Invalid markets response", "INVALID_RESPONSE", "backpack");
    }
    return response.map((market) => this.normalizer.normalizeMarket(market));
  }
  /**
   * Fetch ticker for a symbol
   */
  async fetchTicker(symbol) {
    const market = this.normalizer.toBackpackSymbol(symbol);
    const response = await this.makeRequest("GET", `/ticker?symbol=${market}`, "fetchTicker");
    return this.normalizer.normalizeTicker(response);
  }
  /**
   * Fetch order book for a symbol
   */
  async fetchOrderBook(symbol, params) {
    const market = this.normalizer.toBackpackSymbol(symbol);
    const queryParts = [`symbol=${market}`];
    if (params?.limit) {
      queryParts.push(`depth=${params.limit}`);
    }
    const response = await this.makeRequest("GET", `/depth?${queryParts.join("&")}`, "fetchOrderBook");
    return this.normalizer.normalizeOrderBook(response, symbol);
  }
  /**
   * Fetch recent trades for a symbol
   */
  async fetchTrades(symbol, params) {
    const market = this.normalizer.toBackpackSymbol(symbol);
    const limit = params?.limit ?? 100;
    const response = await this.makeRequest(
      "GET",
      `/trades?symbol=${market}&limit=${limit}`,
      "fetchTrades"
    );
    if (!Array.isArray(response)) {
      throw new PerpDEXError("Invalid trades response", "INVALID_RESPONSE", "backpack");
    }
    return response.map((trade) => this.normalizer.normalizeTrade(trade, symbol));
  }
  /**
   * Fetch current funding rate
   * Returns the most recent funding rate from history
   */
  async fetchFundingRate(symbol) {
    const market = this.normalizer.toBackpackSymbol(symbol);
    const response = await this.makeRequest("GET", `/fundingRates?symbol=${market}`, "fetchFundingRate");
    if (!Array.isArray(response) || response.length === 0) {
      throw new PerpDEXError("No funding rate data available", "INVALID_RESPONSE", "backpack");
    }
    return this.normalizer.normalizeFundingRate(response[0]);
  }
  /**
   * Fetch funding rate history
   */
  async fetchFundingRateHistory(symbol, since, limit) {
    const market = this.normalizer.toBackpackSymbol(symbol);
    const response = await this.makeRequest("GET", `/fundingRates?symbol=${market}`, "fetchFundingRate");
    if (!Array.isArray(response)) {
      throw new PerpDEXError("Invalid funding rate response", "INVALID_RESPONSE", "backpack");
    }
    let rates = response.map((r) => this.normalizer.normalizeFundingRate(r));
    if (since) {
      rates = rates.filter((r) => r.fundingTimestamp >= since);
    }
    if (limit) {
      rates = rates.slice(0, limit);
    }
    return rates;
  }
  /**
   * Fetch all open positions
   */
  async fetchPositions(symbols) {
    this.requireAuth();
    const response = await this.makeRequest("GET", "/positions", "fetchPositions");
    if (!Array.isArray(response.positions)) {
      throw new PerpDEXError("Invalid positions response", "INVALID_RESPONSE", "backpack");
    }
    let positions = response.positions.map((position) => this.normalizer.normalizePosition(position));
    if (symbols && symbols.length > 0) {
      positions = positions.filter((p) => symbols.includes(p.symbol));
    }
    return positions;
  }
  /**
   * Fetch account balance
   *
   * Backpack balance endpoint: GET /api/v1/capital
   * Response format: { "ASSET": { available: "...", locked: "...", staked: "..." }, ... }
   */
  async fetchBalance() {
    this.requireAuth();
    const response = await this.makeRequest("GET", "/capital", "fetchBalance");
    if (!response || typeof response !== "object") {
      throw new PerpDEXError("Invalid balance response", "INVALID_RESPONSE", "backpack");
    }
    const balances = [];
    for (const [currency, data] of Object.entries(response)) {
      if (data && typeof data === "object") {
        const balanceData = data;
        const free = parseFloat(balanceData.available || "0");
        const used = parseFloat(balanceData.locked || "0");
        const total = free + used;
        balances.push({
          currency,
          total,
          free,
          used
        });
      }
    }
    return balances;
  }
  /**
   * Create a new order
   */
  async createOrder(request) {
    const validatedRequest = this.validateOrder(request);
    this.requireAuth();
    const market = this.normalizer.toBackpackSymbol(validatedRequest.symbol);
    const orderType = toBackpackOrderType(validatedRequest.type, validatedRequest.postOnly);
    const side = toBackpackOrderSide(validatedRequest.side);
    const timeInForce = toBackpackTimeInForce(validatedRequest.timeInForce, validatedRequest.postOnly);
    const payload = {
      market,
      side,
      type: orderType,
      size: validatedRequest.amount.toString(),
      price: validatedRequest.price?.toString(),
      time_in_force: timeInForce,
      reduce_only: validatedRequest.reduceOnly ?? false,
      post_only: validatedRequest.postOnly ?? false,
      client_order_id: validatedRequest.clientOrderId
    };
    const response = await this.makeRequest("POST", "/orders", "createOrder", payload);
    return this.normalizer.normalizeOrder(response);
  }
  /**
   * Cancel an existing order
   */
  async cancelOrder(orderId, _symbol) {
    this.requireAuth();
    const response = await this.makeRequest("DELETE", `/orders/${orderId}`, "cancelOrder");
    return this.normalizer.normalizeOrder(response);
  }
  /**
   * Cancel all orders
   */
  async cancelAllOrders(symbol) {
    this.requireAuth();
    const payload = symbol ? { market: this.normalizer.toBackpackSymbol(symbol) } : {};
    const response = await this.makeRequest("DELETE", "/orders", "cancelAllOrders", payload);
    if (!Array.isArray(response.orders)) {
      throw new PerpDEXError("Invalid cancel all orders response", "INVALID_RESPONSE", "backpack");
    }
    return response.orders.map((order) => this.normalizer.normalizeOrder(order));
  }
  /**
   * Fetch open orders
   */
  async fetchOpenOrders(symbol) {
    this.requireAuth();
    const params = symbol ? `?market=${this.normalizer.toBackpackSymbol(symbol)}` : "";
    const response = await this.makeRequest("GET", `/orders${params}`, "fetchOpenOrders");
    if (!Array.isArray(response.orders)) {
      throw new PerpDEXError("Invalid open orders response", "INVALID_RESPONSE", "backpack");
    }
    return response.orders.map((order) => this.normalizer.normalizeOrder(order));
  }
  /**
   * Fetch a specific order
   */
  async fetchOrder(orderId, _symbol) {
    this.requireAuth();
    const response = await this.makeRequest("GET", `/orders/${orderId}`, "fetchOrder");
    return this.normalizer.normalizeOrder(response);
  }
  /**
   * Set leverage for a symbol
   */
  async setLeverage(symbol, leverage) {
    this.requireAuth();
    const market = this.normalizer.toBackpackSymbol(symbol);
    await this.makeRequest("POST", "/account/leverage", "setLeverage", {
      market,
      leverage: leverage.toString()
    });
  }
  /**
   * Fetch order history
   */
  async fetchOrderHistory(symbol, since, limit) {
    this.requireAuth();
    const params = new URLSearchParams();
    if (symbol) params.append("symbol", this.normalizer.toBackpackSymbol(symbol));
    if (since) params.append("startTime", since.toString());
    if (limit) params.append("limit", limit.toString());
    const queryString = params.toString();
    const response = await this.makeRequest(
      "GET",
      `/history/orders${queryString ? `?${queryString}` : ""}`,
      "fetchOrderHistory"
    );
    if (!Array.isArray(response)) {
      throw new PerpDEXError("Invalid order history response", "INVALID_RESPONSE", "backpack");
    }
    return response.map((order) => this.normalizer.normalizeOrder(order));
  }
  /**
   * Fetch user trade history
   */
  async fetchMyTrades(symbol, since, limit) {
    this.requireAuth();
    const params = new URLSearchParams();
    if (symbol) params.append("symbol", this.normalizer.toBackpackSymbol(symbol));
    if (since) params.append("startTime", since.toString());
    if (limit) params.append("limit", limit.toString());
    const queryString = params.toString();
    const response = await this.makeRequest(
      "GET",
      `/fills${queryString ? `?${queryString}` : ""}`,
      "fetchMyTrades"
    );
    if (!Array.isArray(response)) {
      throw new PerpDEXError("Invalid fills response", "INVALID_RESPONSE", "backpack");
    }
    return response.map((trade) => this.normalizer.normalizeTrade(trade, symbol));
  }
  /**
   * Convert unified symbol to exchange format
   */
  symbolToExchange(symbol) {
    return this.normalizer.toBackpackSymbol(symbol);
  }
  /**
   * Convert exchange symbol to unified format
   */
  symbolFromExchange(exchangeSymbol) {
    return this.normalizer.normalizeSymbol(exchangeSymbol);
  }
  /**
   * Instruction mapping for Backpack API endpoints.
   * The instruction value is required for the ED25519 signature payload.
   */
  static INSTRUCTION_MAP = {
    createOrder: "orderExecute",
    cancelOrder: "orderCancel",
    cancelAllOrders: "orderCancelAll",
    fetchOpenOrders: "orderQuery",
    fetchOrder: "orderQuery",
    fetchOrderHistory: "orderHistoryQuery",
    fetchPositions: "positionQuery",
    fetchBalance: "balanceQuery",
    fetchMyTrades: "fillHistoryQuery",
    setLeverage: "leverageChange"
  };
  /**
   * Make authenticated HTTP request using HTTPClient
   *
   * Backpack API uses /api/v1 prefix for all endpoints.
   */
  async makeRequest(method, path, endpoint, body) {
    await this.rateLimiter.acquire(endpoint);
    const fullPath = `/api/v1${path}`;
    const headers = {};
    if (this.auth) {
      const timestamp = Date.now().toString();
      const instruction = _BackpackAdapter.INSTRUCTION_MAP[endpoint] ?? "";
      headers["X-API-KEY"] = this.auth.getApiKey();
      headers["X-Timestamp"] = timestamp;
      headers["X-Window"] = "5000";
      headers["X-Signature"] = await this.auth.signRequest(instruction, timestamp, body);
    }
    try {
      switch (method) {
        case "GET":
          return await this.httpClient.get(fullPath, { headers });
        case "POST":
          return await this.httpClient.post(fullPath, { headers, body });
        case "PUT":
          return await this.httpClient.put(fullPath, { headers, body });
        case "DELETE":
          return await this.httpClient.delete(fullPath, { headers, body });
        default:
          throw new Error(`Unsupported HTTP method: ${method}`);
      }
    } catch (error) {
      if (error instanceof PerpDEXError) {
        throw error;
      }
      const { code } = mapBackpackError(error);
      throw new PerpDEXError("Request failed", code, "backpack", error);
    }
  }
};

// src/adapters/nado/NadoAdapter.ts
var import_ethers5 = require("ethers");

// src/adapters/nado/constants.ts
var NADO_API_URLS = {
  mainnet: {
    rest: "https://gateway.prod.nado.xyz/v1",
    ws: "wss://gateway.prod.nado.xyz/v1/ws"
  },
  testnet: {
    rest: "https://gateway.test.nado.xyz/v1",
    ws: "wss://gateway.test.nado.xyz/v1/ws"
  }
};
var NADO_CHAIN_ID = {
  mainnet: 57073,
  // Ink L2 mainnet
  testnet: 763373
  // Ink L2 testnet (Sepolia)
};
var NADO_EIP712_DOMAIN = {
  name: "Nado",
  version: "0.0.1"
};
var NADO_RATE_LIMITS = {
  // Requests per minute
  queriesPerMinute: 1200,
  executesPerMinute: 600,
  // WebSocket
  wsMessagePerSecond: 10,
  wsPingInterval: 3e4
  // 30 seconds - required for keep-alive
};
var NADO_WS_CONFIG = {
  pingInterval: 3e4,
  // Required: send ping every 30 seconds
  pongTimeout: 1e4,
  // Timeout for pong response
  reconnectDelay: 1e3,
  // Initial reconnect delay
  maxReconnectDelay: 3e4,
  // Max reconnect delay
  reconnectAttempts: 10
};
var NADO_REQUEST_CONFIG = {
  timeout: 1e4,
  // 10 seconds
  headers: {
    "Content-Type": "application/json",
    "Accept-Encoding": "gzip, br, deflate"
    // Required by Nado API
  }
};
var NADO_ORDER_SIDES = {
  BUY: 0,
  // Nado uses 0 for buy
  SELL: 1
  // Nado uses 1 for sell
};
var NADO_QUERY_TYPES = {
  STATUS: "status",
  CONTRACTS: "contracts",
  NONCES: "nonces",
  ORDER: "order",
  ORDERS: "orders",
  SUBACCOUNT_INFO: "subaccount_info",
  ISOLATED_POSITIONS: "isolated_positions",
  MARKET_LIQUIDITY: "market_liquidity",
  SYMBOLS: "symbols",
  ALL_PRODUCTS: "all_products",
  MARKET_PRICES: "market_prices",
  MAX_ORDER_SIZE: "max_order_size",
  MAX_WITHDRAWABLE: "max_withdrawable",
  FEE_RATES: "fee_rates",
  HEALTH_GROUPS: "health_groups"
};
var NADO_EXECUTE_TYPES = {
  PLACE_ORDER: "place_order",
  CANCEL_ORDERS: "cancel_orders",
  CANCEL_PRODUCT_ORDERS: "cancel_product_orders",
  WITHDRAW_COLLATERAL: "withdraw_collateral",
  LIQUIDATE_SUBACCOUNT: "liquidate_subaccount",
  MINT_NLP: "mint_nlp",
  BURN_NLP: "burn_nlp",
  LINK_SIGNER: "link_signer"
};
var NADO_WS_CHANNELS = {
  ORDERBOOK: "market_liquidity",
  TRADES: "recent_trades",
  POSITIONS: "isolated_positions",
  ORDERS: "orders",
  SUBACCOUNT: "subaccount_info",
  FILLS: "fills"
};

// src/adapters/nado/types.ts
var NadoSymbolSchema = external_exports.object({
  type: external_exports.enum(["perp", "spot"]),
  product_id: external_exports.number(),
  symbol: external_exports.string(),
  price_increment_x18: external_exports.string(),
  size_increment: external_exports.string(),
  min_size: external_exports.string(),
  maker_fee_rate_x18: external_exports.string(),
  taker_fee_rate_x18: external_exports.string(),
  long_weight_initial_x18: external_exports.string(),
  long_weight_maintenance_x18: external_exports.string(),
  max_open_interest_x18: external_exports.string().nullable().optional()
});
var NadoProductSchema = external_exports.object({
  product_id: external_exports.number(),
  symbol: external_exports.string(),
  base_currency: external_exports.string(),
  quote_currency: external_exports.string(),
  contract_size: external_exports.string(),
  tick_size: external_exports.string(),
  min_size: external_exports.string(),
  max_position_size: external_exports.string().optional(),
  maker_fee: external_exports.string(),
  taker_fee: external_exports.string(),
  is_active: external_exports.boolean(),
  product_type: external_exports.enum(["perpetual", "spot", "future"])
});
var NadoOrderBookSchema = external_exports.object({
  bids: external_exports.array(external_exports.tuple([external_exports.string(), external_exports.string()])),
  asks: external_exports.array(external_exports.tuple([external_exports.string(), external_exports.string()]))
});
var NadoOrderSchema = external_exports.object({
  order_id: external_exports.string(),
  digest: external_exports.string(),
  product_id: external_exports.number(),
  sender: external_exports.string(),
  price_x18: external_exports.string(),
  amount: external_exports.string(),
  side: external_exports.union([external_exports.literal(0), external_exports.literal(1)]),
  expiration: external_exports.number(),
  nonce: external_exports.number(),
  status: external_exports.enum(["open", "filled", "cancelled", "expired", "rejected"]),
  filled_amount: external_exports.string(),
  remaining_amount: external_exports.string(),
  avg_fill_price: external_exports.string().optional(),
  timestamp: external_exports.number(),
  is_reduce_only: external_exports.boolean().optional(),
  post_only: external_exports.boolean().optional(),
  time_in_force: external_exports.enum(["gtc", "ioc", "fok"]).optional()
});
var NadoPositionSchema = external_exports.object({
  product_id: external_exports.number(),
  subaccount: external_exports.string(),
  size: external_exports.string(),
  entry_price: external_exports.string(),
  mark_price: external_exports.string(),
  liquidation_price: external_exports.string().optional(),
  unrealized_pnl: external_exports.string(),
  realized_pnl: external_exports.string(),
  leverage: external_exports.string(),
  margin: external_exports.string(),
  timestamp: external_exports.number()
});
var NadoBalanceSchema = external_exports.object({
  subaccount: external_exports.string(),
  quote_balance: external_exports.string(),
  total_equity: external_exports.string(),
  used_margin: external_exports.string(),
  free_margin: external_exports.string(),
  unrealized_pnl: external_exports.string(),
  health: external_exports.string(),
  timestamp: external_exports.number()
});
var NadoTradeSchema = external_exports.object({
  trade_id: external_exports.string(),
  product_id: external_exports.number(),
  price: external_exports.string(),
  size: external_exports.string(),
  side: external_exports.union([external_exports.literal(0), external_exports.literal(1)]),
  timestamp: external_exports.number(),
  is_maker: external_exports.boolean()
});
var NadoTickerSchema = external_exports.object({
  product_id: external_exports.number(),
  bid_x18: external_exports.string(),
  ask_x18: external_exports.string()
});
var NadoContractsSchema = external_exports.object({
  chain_id: external_exports.string(),
  endpoint_addr: external_exports.string(),
  products: external_exports.record(
    external_exports.string(),
    external_exports.object({
      address: external_exports.string(),
      symbol: external_exports.string()
    })
  ).optional()
});

// src/adapters/nado/NadoAuth.ts
var import_ethers3 = require("ethers");
var EIP712_ORDER_TYPES = {
  Order: [
    { name: "sender", type: "address" },
    { name: "priceX18", type: "uint256" },
    { name: "amount", type: "uint256" },
    { name: "expiration", type: "uint64" },
    { name: "nonce", type: "uint64" },
    { name: "appendix", type: "OrderAppendix" }
  ],
  OrderAppendix: [
    { name: "productId", type: "uint32" },
    { name: "side", type: "uint8" },
    { name: "reduceOnly", type: "bool" },
    { name: "postOnly", type: "bool" }
  ]
};
var EIP712_CANCELLATION_TYPES = {
  Cancellation: [
    { name: "sender", type: "address" },
    { name: "productIds", type: "uint32[]" },
    { name: "digests", type: "bytes32[]" },
    { name: "nonce", type: "uint64" }
  ]
};
var EIP712_STREAM_AUTH_TYPES = {
  StreamAuthentication: [
    { name: "sender", type: "address" },
    { name: "expiration", type: "uint64" }
  ]
};
var NadoAuth = class {
  wallet;
  chainId;
  currentNonce = 0n;
  /**
   * Creates a new NadoAuth instance
   *
   * @param wallet - ethers.Wallet instance for signing
   * @param chainId - Nado chain ID (57073 mainnet, 763373 testnet)
   */
  constructor(wallet, chainId) {
    this.wallet = wallet;
    this.chainId = chainId;
  }
  // ===========================================================================
  // Public Signing Methods
  // ===========================================================================
  /**
   * Sign an EIP-712 order for Nado
   *
   * @param order - Order data to sign
   * @param productId - Product ID for verifying contract derivation
   * @returns EIP-712 signature (0x-prefixed hex string)
   *
   * @throws {PerpDEXError} If signing fails
   *
   * @example
   * ```typescript
   * const order: NadoEIP712Order = {
   *   sender: wallet.address,
   *   priceX18: '80000000000000000000000',
   *   amount: '10000000000000000',
   *   expiration: nowInSeconds() + 3600,
   *   nonce: auth.getNextNonce(),
   *   appendix: {
   *     productId: 2,
   *     side: 0, // buy
   *     reduceOnly: false,
   *     postOnly: true,
   *   },
   * };
   *
   * const signature = await auth.signOrder(order, 2);
   * ```
   */
  async signOrder(order, productId) {
    try {
      const verifyingContract = this.productIdToVerifyingContract(productId);
      const domain = this.createDomain(verifyingContract);
      return await this.wallet.signTypedData(domain, EIP712_ORDER_TYPES, order);
    } catch (error) {
      throw new PerpDEXError(
        `Failed to sign order: ${error instanceof Error ? error.message : "Unknown error"}`,
        "SIGNING_FAILED",
        "nado",
        error
      );
    }
  }
  /**
   * Sign an EIP-712 cancellation for Nado
   *
   * @param cancellation - Cancellation data to sign
   * @param endpointAddress - Nado endpoint contract address
   * @returns EIP-712 signature (0x-prefixed hex string)
   *
   * @throws {PerpDEXError} If signing fails
   *
   * @example
   * ```typescript
   * const cancellation: NadoEIP712Cancellation = {
   *   sender: wallet.address,
   *   productIds: [2, 3],
   *   digests: ['0x...', '0x...'],
   *   nonce: auth.getNextNonce(),
   * };
   *
   * const signature = await auth.signCancellation(
   *   cancellation,
   *   contractsInfo.endpoint_addr
   * );
   * ```
   */
  async signCancellation(cancellation, endpointAddress) {
    try {
      const domain = this.createDomain(endpointAddress);
      return await this.wallet.signTypedData(domain, EIP712_CANCELLATION_TYPES, cancellation);
    } catch (error) {
      throw new PerpDEXError(
        `Failed to sign cancellation: ${error instanceof Error ? error.message : "Unknown error"}`,
        "SIGNING_FAILED",
        "nado",
        error
      );
    }
  }
  /**
   * Sign an EIP-712 stream authentication for Nado WebSocket
   *
   * @param streamAuth - Stream auth data to sign
   * @param endpointAddress - Nado endpoint contract address
   * @returns EIP-712 signature (0x-prefixed hex string)
   *
   * @throws {PerpDEXError} If signing fails
   *
   * @example
   * ```typescript
   * const streamAuth: NadoEIP712StreamAuth = {
   *   sender: wallet.address,
   *   expiration: nowInSeconds() + 3600, // 1 hour
   * };
   *
   * const signature = await auth.signStreamAuth(
   *   streamAuth,
   *   contractsInfo.endpoint_addr
   * );
   * ```
   */
  async signStreamAuth(streamAuth, endpointAddress) {
    try {
      const domain = this.createDomain(endpointAddress);
      return await this.wallet.signTypedData(domain, EIP712_STREAM_AUTH_TYPES, streamAuth);
    } catch (error) {
      throw new PerpDEXError(
        `Failed to sign stream auth: ${error instanceof Error ? error.message : "Unknown error"}`,
        "SIGNING_FAILED",
        "nado",
        error
      );
    }
  }
  // ===========================================================================
  // Nonce Management
  // ===========================================================================
  /**
   * Get the current nonce without incrementing
   *
   * @returns Current nonce value as bigint
   */
  getCurrentNonce() {
    return this.currentNonce;
  }
  /**
   * Get the next nonce and increment the counter
   *
   * @returns Next nonce value (before increment) as bigint
   *
   * @example
   * ```typescript
   * const nonce1 = auth.getNextNonce(); // 0n
   * const nonce2 = auth.getNextNonce(); // 1n
   * const nonce3 = auth.getNextNonce(); // 2n
   * ```
   */
  getNextNonce() {
    return this.currentNonce++;
  }
  /**
   * Set the nonce to a specific value
   *
   * Useful for synchronizing with on-chain nonce or recovering from errors.
   * Accepts bigint, number, or string representation of the nonce.
   *
   * @param nonce - New nonce value (bigint, number, or string)
   *
   * @example
   * ```typescript
   * // Sync with on-chain nonce (from API as string)
   * const onChainNonce = await fetchNonceFromAPI();
   * auth.setNonce(onChainNonce); // "1854600042563764224"
   * ```
   */
  setNonce(nonce) {
    let nonceValue;
    if (typeof nonce === "bigint") {
      nonceValue = nonce;
    } else if (typeof nonce === "number") {
      if (nonce < 0 || !Number.isInteger(nonce)) {
        throw new PerpDEXError("Nonce must be a non-negative integer", "INVALID_NONCE", "nado");
      }
      nonceValue = BigInt(nonce);
    } else if (typeof nonce === "string") {
      try {
        nonceValue = BigInt(nonce);
      } catch {
        throw new PerpDEXError("Nonce must be a valid integer string", "INVALID_NONCE", "nado");
      }
    } else {
      throw new PerpDEXError("Nonce must be a bigint, number, or string", "INVALID_NONCE", "nado");
    }
    if (nonceValue < 0n) {
      throw new PerpDEXError("Nonce must be non-negative", "INVALID_NONCE", "nado");
    }
    this.currentNonce = nonceValue;
  }
  /**
   * Increment nonce by a specific amount
   *
   * @param amount - Amount to increment (default: 1n)
   */
  incrementNonce(amount = 1n) {
    const amountBigInt = typeof amount === "bigint" ? amount : BigInt(amount);
    if (amountBigInt < 0n) {
      throw new PerpDEXError("Increment amount must be non-negative", "INVALID_NONCE", "nado");
    }
    this.currentNonce += amountBigInt;
  }
  // ===========================================================================
  // Utility Methods
  // ===========================================================================
  /**
   * Get wallet address
   *
   * @returns Wallet address (0x-prefixed)
   */
  getAddress() {
    return this.wallet.address;
  }
  /**
   * Get chain ID
   *
   * @returns Nado chain ID
   */
  getChainId() {
    return this.chainId;
  }
  // ===========================================================================
  // Private Helper Methods
  // ===========================================================================
  /**
   * Create EIP-712 domain for Nado
   *
   * @param verifyingContract - Contract address for domain
   * @returns EIP-712 domain object
   */
  createDomain(verifyingContract) {
    return {
      name: NADO_EIP712_DOMAIN.name,
      version: NADO_EIP712_DOMAIN.version,
      chainId: this.chainId,
      verifyingContract
    };
  }
  /**
   * Convert product ID to verifying contract address
   *
   * Nado uses a special encoding where product ID is embedded in the last 8 bytes
   * of a 20-byte address.
   *
   * @param productId - Nado product ID
   * @returns Verifying contract address (0x-prefixed hex)
   *
   * @example
   * ```typescript
   * // Product ID 2 -> 0x0000000000000000000000000000000000000002
   * const contract = productIdToVerifyingContract(2);
   * ```
   */
  productIdToVerifyingContract(productId) {
    if (productId < 0 || !Number.isInteger(productId)) {
      throw new PerpDEXError(
        `Invalid product ID: ${productId}`,
        "INVALID_PRODUCT_ID",
        "nado"
      );
    }
    return import_ethers3.ethers.zeroPadValue(import_ethers3.ethers.toBeHex(productId), 20);
  }
};

// src/adapters/nado/error-codes.ts
var NADO_CLIENT_ERRORS = {
  // Authentication & Signature
  INVALID_SIGNATURE: "invalid_signature",
  INVALID_NONCE: "invalid_nonce",
  EXPIRED_SIGNATURE: "expired_signature",
  // Order Errors
  INVALID_ORDER: "invalid_order",
  INSUFFICIENT_MARGIN: "insufficient_margin",
  ORDER_NOT_FOUND: "order_not_found",
  ORDER_EXPIRED: "order_expired",
  INVALID_PRICE: "invalid_price",
  INVALID_AMOUNT: "invalid_amount",
  MIN_SIZE_NOT_MET: "min_size_not_met",
  MAX_SIZE_EXCEEDED: "max_size_exceeded",
  // Product/Market Errors
  INVALID_PRODUCT: "invalid_product",
  PRODUCT_NOT_ACTIVE: "product_not_active",
  MARKET_CLOSED: "market_closed",
  // Subaccount Errors
  SUBACCOUNT_NOT_FOUND: "subaccount_not_found",
  INVALID_SUBACCOUNT: "invalid_subaccount",
  // Validation Errors
  INVALID_PARAMS: "invalid_params",
  MISSING_REQUIRED_FIELD: "missing_required_field"
};
var NADO_SERVER_ERRORS = {
  INTERNAL_ERROR: "internal_error",
  SERVICE_UNAVAILABLE: "service_unavailable",
  TIMEOUT: "timeout",
  DATABASE_ERROR: "database_error",
  SEQUENCER_ERROR: "sequencer_error"
};
var NADO_RATE_LIMIT_ERROR = "rate_limit_exceeded";
var NADO_NETWORK_ERRORS = {
  ECONNRESET: "ECONNRESET",
  ETIMEDOUT: "ETIMEDOUT",
  ENOTFOUND: "ENOTFOUND",
  ECONNREFUSED: "ECONNREFUSED",
  NETWORK_ERROR: "NETWORK_ERROR"
};
function isServerError3(errorCode) {
  return Object.values(NADO_SERVER_ERRORS).includes(errorCode);
}
function isNetworkError3(errorCode) {
  return Object.values(NADO_NETWORK_ERRORS).includes(errorCode);
}
function isRetryableError(errorCode) {
  return isServerError3(errorCode) || isNetworkError3(errorCode) || errorCode === NADO_RATE_LIMIT_ERROR;
}
function mapNadoError(errorCode, message, originalError) {
  const code = errorCode.toString();
  if (code === NADO_CLIENT_ERRORS.INVALID_SIGNATURE || code === NADO_CLIENT_ERRORS.EXPIRED_SIGNATURE) {
    return new InvalidSignatureError(message, code, "nado", originalError);
  }
  if (code === NADO_CLIENT_ERRORS.INSUFFICIENT_MARGIN) {
    return new InsufficientMarginError(message, code, "nado", originalError);
  }
  if (code === NADO_CLIENT_ERRORS.ORDER_NOT_FOUND) {
    return new OrderNotFoundError(message, code, "nado", originalError);
  }
  if (code === NADO_CLIENT_ERRORS.INVALID_ORDER || code === NADO_CLIENT_ERRORS.ORDER_EXPIRED || code === NADO_CLIENT_ERRORS.INVALID_PRICE || code === NADO_CLIENT_ERRORS.INVALID_AMOUNT || code === NADO_CLIENT_ERRORS.MIN_SIZE_NOT_MET || code === NADO_CLIENT_ERRORS.MAX_SIZE_EXCEEDED || code === NADO_CLIENT_ERRORS.INVALID_NONCE) {
    return new InvalidOrderError(message, code, "nado", originalError);
  }
  if (code === NADO_RATE_LIMIT_ERROR) {
    return new RateLimitError(message, code, "nado", void 0, originalError);
  }
  if (isServerError3(code) || isNetworkError3(code)) {
    return new ExchangeUnavailableError(message, code, "nado", originalError);
  }
  return new PerpDEXError(message, code, "nado", originalError);
}
function extractNadoError(response) {
  const code = response.error_code?.toString() || "UNKNOWN_ERROR";
  const message = response.error || response.message || "Unknown error occurred";
  return { code, message };
}
function mapHttpError3(status, statusText) {
  if (status === 429) {
    return new RateLimitError(
      `Rate limit exceeded: ${statusText}`,
      NADO_RATE_LIMIT_ERROR,
      "nado",
      void 0
      // retryAfter parameter
    );
  }
  if (status >= 400 && status < 500) {
    return new InvalidOrderError(
      `Client error (${status}): ${statusText}`,
      `HTTP_${status}`,
      "nado"
    );
  }
  if (status >= 500) {
    return new ExchangeUnavailableError(
      `Server error (${status}): ${statusText}`,
      `HTTP_${status}`,
      "nado"
    );
  }
  return new PerpDEXError(
    `HTTP error (${status}): ${statusText}`,
    `HTTP_${status}`,
    "nado"
  );
}

// src/adapters/nado/NadoAPIClient.ts
var DEFAULT_RETRY_CONFIG = {
  maxAttempts: 3,
  initialDelay: 1e3,
  // 1 second
  maxDelay: 5e3,
  // 5 seconds
  multiplier: 2
};
var NadoAPIClient = class {
  apiUrl;
  rateLimiter;
  timeout;
  retryConfig;
  abortControllers = /* @__PURE__ */ new Set();
  constructor(config) {
    this.apiUrl = config.apiUrl;
    this.rateLimiter = config.rateLimiter;
    this.timeout = config.timeout || NADO_REQUEST_CONFIG.timeout;
    this.retryConfig = {
      ...DEFAULT_RETRY_CONFIG,
      ...config.retryConfig
    };
  }
  // ===========================================================================
  // Public API Methods
  // ===========================================================================
  /**
   * Execute a query request to Nado API
   *
   * Query endpoints are read-only and don't require signatures.
   *
   * @param type - Query type (e.g., 'all_products', 'market_liquidity')
   * @param params - Query parameters (optional)
   * @returns Parsed response data
   *
   * @throws {PerpDEXError} On API or network errors
   *
   * @example
   * ```typescript
   * // Get all products
   * const products = await client.query('all_products');
   *
   * // Get market liquidity for product 2
   * const liquidity = await client.query('market_liquidity', {
   *   product_id: 2,
   * });
   * ```
   */
  async query(type, params = {}) {
    await this.rateLimiter.acquire("query", 1);
    return this.retryRequest(async () => {
      const response = await this.request("/query", {
        type,
        ...params
      });
      return response;
    });
  }
  /**
   * Execute a signed request to Nado API
   *
   * Execute endpoints modify state and require EIP-712 signatures.
   *
   * @param type - Execute type (e.g., 'place_order', 'cancel_orders')
   * @param payload - Request payload
   * @param signature - EIP-712 signature (0x-prefixed hex)
   * @returns Parsed response data
   *
   * @throws {PerpDEXError} On API or network errors
   *
   * @example
   * ```typescript
   * const order = {
   *   sender: '0x...',
   *   priceX18: '...',
   *   amount: '...',
   *   // ...
   * };
   *
   * const signature = await auth.signOrder(order, productId);
   * const result = await client.execute('place_order', order, signature);
   * ```
   */
  async execute(type, payload, signature) {
    await this.rateLimiter.acquire("execute", 2);
    return this.retryRequest(async () => {
      const response = await this.request("/execute", {
        type,
        payload,
        signature
      });
      return response;
    });
  }
  /**
   * Cancel all pending requests
   *
   * Useful when shutting down the adapter or on critical errors.
   */
  cancelAllRequests() {
    this.abortControllers.forEach((controller) => {
      controller.abort();
    });
    this.abortControllers.clear();
  }
  // ===========================================================================
  // Private HTTP Methods
  // ===========================================================================
  /**
   * Execute HTTP request with timeout and error handling
   *
   * @param endpoint - API endpoint path (e.g., '/query', '/execute')
   * @param body - Request body
   * @returns Parsed response data
   */
  async request(endpoint, body) {
    const controller = new AbortController();
    this.abortControllers.add(controller);
    const timeoutId = setTimeout(() => controller.abort(), this.timeout);
    try {
      const response = await fetch(`${this.apiUrl}${endpoint}`, {
        method: "POST",
        headers: NADO_REQUEST_CONFIG.headers,
        body: JSON.stringify(body),
        signal: controller.signal
      });
      if (!response.ok) {
        throw mapHttpError3(response.status, response.statusText);
      }
      const data = await response.json();
      if (data.status === "failure") {
        const { code, message } = extractNadoError(data);
        throw mapNadoError(code, message, data);
      }
      return data.data;
    } catch (error) {
      throw this.mapRequestError(error);
    } finally {
      clearTimeout(timeoutId);
      this.abortControllers.delete(controller);
    }
  }
  // ===========================================================================
  // Retry Logic
  // ===========================================================================
  /**
   * Execute request with automatic retry logic
   *
   * Retries only on transient errors (network, server, rate limit).
   * Client errors are thrown immediately.
   *
   * @param fn - Request function to retry
   * @returns Result of successful request
   */
  async retryRequest(fn) {
    let lastError;
    let delay = this.retryConfig.initialDelay;
    for (let attempt = 1; attempt <= this.retryConfig.maxAttempts; attempt++) {
      try {
        return await fn();
      } catch (error) {
        lastError = error;
        if (!this.shouldRetry(error, attempt)) {
          throw error;
        }
        if (attempt < this.retryConfig.maxAttempts) {
          await this.sleep(delay);
          delay = Math.min(delay * this.retryConfig.multiplier, this.retryConfig.maxDelay);
        }
      }
    }
    throw new ExchangeUnavailableError(
      `Request failed after ${this.retryConfig.maxAttempts} attempts: ${lastError?.message}`,
      "MAX_RETRIES_EXCEEDED",
      "nado",
      lastError
    );
  }
  /**
   * Determine if error should be retried
   *
   * @param error - Error to check
   * @param attempt - Current attempt number
   * @returns true if should retry
   */
  shouldRetry(error, attempt) {
    if (attempt >= this.retryConfig.maxAttempts) {
      return false;
    }
    if (error instanceof PerpDEXError) {
      if (error.code && typeof error.code === "string" && error.code.startsWith("HTTP_5")) {
        return true;
      }
      return isRetryableError(error.code);
    }
    return this.isRetryableNetworkError(error) || this.isRetryableNetworkError(error.originalError);
  }
  /**
   * Check if error is a retryable network error
   * @param err - Error to check
   * @returns true if retryable
   */
  isRetryableNetworkError(err2) {
    if (!err2) return false;
    if (err2.name === "AbortError" || err2.name === "TimeoutError") {
      return true;
    }
    if (err2.code && typeof err2.code === "string" && err2.code.startsWith("HTTP_5")) {
      return true;
    }
    if (err2.code && isRetryableError(err2.code)) {
      return true;
    }
    return false;
  }
  // ===========================================================================
  // Error Mapping
  // ===========================================================================
  /**
   * Map request errors to unified error types
   *
   * @param error - Error to map
   * @returns Mapped PerpDEXError
   */
  mapRequestError(error) {
    if (error instanceof PerpDEXError) {
      return error;
    }
    if (error.name === "AbortError" || error.name === "TimeoutError") {
      return new ExchangeUnavailableError(
        `Request timeout after ${this.timeout}ms`,
        "TIMEOUT",
        "nado",
        error
      );
    }
    if (error.code === "ECONNRESET" || error.code === "ETIMEDOUT" || error.code === "ENOTFOUND" || error.code === "ECONNREFUSED") {
      return new ExchangeUnavailableError(
        `Network error: ${error.message}`,
        error.code,
        "nado",
        error
      );
    }
    return new PerpDEXError(
      error.message || "Unknown error",
      "UNKNOWN_ERROR",
      "nado",
      error
    );
  }
  // ===========================================================================
  // Utilities
  // ===========================================================================
  /**
   * Sleep for specified milliseconds
   *
   * @param ms - Milliseconds to sleep
   */
  sleep(ms) {
    return new Promise((resolve) => setTimeout(resolve, ms));
  }
};

// src/adapters/nado/NadoNormalizer.ts
var import_ethers4 = require("ethers");
var NadoNormalizer = class {
  logger = new Logger("NadoNormalizer");
  // ===========================================================================
  // Symbol Conversion
  // ===========================================================================
  /**
   * Convert Nado symbol to CCXT format
   *
   * @param nadoSymbol - Nado symbol (e.g., "BTC-PERP", "BTC-USDT")
   * @param quoteAsset - Quote asset (default: USDT)
   * @returns CCXT formatted symbol (e.g., "BTC/USDT:USDT")
   *
   * @example
   * ```typescript
   * normalizer.symbolToCCXT('BTC-PERP');        // "BTC/USDT:USDT"
   * normalizer.symbolToCCXT('ETH-PERP');        // "ETH/USDT:USDT"
   * normalizer.symbolToCCXT('BTC-USDC', 'USDC'); // "BTC/USDC"
   * ```
   */
  symbolToCCXT(nadoSymbol, quoteAsset = "USDT") {
    if (nadoSymbol.endsWith("-PERP")) {
      const base = nadoSymbol.replace("-PERP", "");
      return `${base}/${quoteAsset}:${quoteAsset}`;
    }
    if (nadoSymbol.includes("-")) {
      const [base, quote] = nadoSymbol.split("-");
      return `${base}/${quote}`;
    }
    return `${nadoSymbol}/${quoteAsset}:${quoteAsset}`;
  }
  /**
   * Convert CCXT symbol to Nado format
   *
   * @param ccxtSymbol - CCXT formatted symbol (e.g., "BTC/USDT:USDT")
   * @returns Nado symbol (e.g., "BTC-PERP")
   *
   * @example
   * ```typescript
   * normalizer.symbolFromCCXT('BTC/USDT:USDT'); // "BTC-PERP"
   * normalizer.symbolFromCCXT('ETH/USDT:USDT'); // "ETH-PERP"
   * normalizer.symbolFromCCXT('BTC/USDC');      // "BTC-USDC"
   * ```
   */
  symbolFromCCXT(ccxtSymbol) {
    if (ccxtSymbol.includes(":")) {
      const base2 = ccxtSymbol.split("/")[0];
      return `${base2}-PERP`;
    }
    const [base, quote] = ccxtSymbol.split("/");
    return `${base}-${quote}`;
  }
  // ===========================================================================
  // Precision-Safe Numeric Conversions
  // ===========================================================================
  /**
   * Convert from x18 format to number with precision safety
   *
   * @param value - x18 formatted string
   * @returns Parsed number
   *
   * @throws {PerpDEXError} If value is invalid or results in NaN
   */
  fromX18Safe(value) {
    try {
      const formatted = import_ethers4.ethers.formatUnits(value, 18);
      const parsed = parseFloat(formatted);
      if (!Number.isFinite(parsed)) {
        throw new PerpDEXError(
          `Invalid x18 value resulted in non-finite number: ${value}`,
          "INVALID_NUMBER",
          "nado"
        );
      }
      if (Math.abs(parsed) > Number.MAX_SAFE_INTEGER) {
        this.logger.warn("Precision loss detected for value", { value });
      }
      return parsed;
    } catch (error) {
      if (error instanceof PerpDEXError) {
        throw error;
      }
      throw new PerpDEXError(
        `Failed to convert from x18: ${value}`,
        "CONVERSION_ERROR",
        "nado",
        error
      );
    }
  }
  // ===========================================================================
  // Single Entity Normalization
  // ===========================================================================
  /**
   * Normalize Nado symbol (from /query?type=symbols) to unified Market format
   *
   * @param symbolData - Nado symbol data from symbols endpoint
   * @returns Normalized market
   */
  normalizeSymbol(symbolData) {
    const validated = NadoSymbolSchema.parse(symbolData);
    const isPerp = validated.type === "perp";
    let base;
    let quote;
    if (isPerp && validated.symbol.endsWith("-PERP")) {
      base = validated.symbol.replace("-PERP", "");
      quote = "USDC";
    } else {
      base = validated.symbol;
      quote = "USDC";
    }
    const priceIncrement = this.fromX18Safe(validated.price_increment_x18);
    const sizeIncrement = this.fromX18Safe(validated.size_increment);
    const minSize = this.fromX18Safe(validated.min_size);
    const makerFee = this.fromX18Safe(validated.maker_fee_rate_x18);
    const takerFee = this.fromX18Safe(validated.taker_fee_rate_x18);
    const pricePrecision = this.getPrecisionFromIncrement(priceIncrement);
    const amountPrecision = this.getPrecisionFromIncrement(sizeIncrement);
    const symbol = isPerp ? `${base}/${quote}:${quote}` : `${base}/${quote}`;
    return {
      id: validated.product_id.toString(),
      symbol,
      base,
      quote,
      settle: quote,
      active: true,
      // Nado doesn't have an is_active field in symbols
      minAmount: minSize,
      pricePrecision,
      amountPrecision,
      priceTickSize: priceIncrement,
      amountStepSize: sizeIncrement,
      makerFee,
      takerFee,
      maxLeverage: 50,
      // Nado typical max leverage
      fundingIntervalHours: 8
    };
  }
  /**
   * Calculate decimal precision from increment value
   */
  getPrecisionFromIncrement(increment) {
    if (increment >= 1) return 0;
    const str = increment.toString();
    const decimalPart = str.split(".")[1];
    return decimalPart ? decimalPart.replace(/0+$/, "").length : 0;
  }
  /**
   * Normalize Nado product to unified Market format
   *
   * @deprecated Use normalizeSymbol instead
   * @param product - Nado product data
   * @returns Normalized market
   */
  normalizeProduct(product) {
    const validated = NadoProductSchema.parse(product);
    const symbol = this.symbolToCCXT(validated.symbol, validated.quote_currency);
    return {
      id: validated.product_id.toString(),
      symbol,
      base: validated.base_currency,
      quote: validated.quote_currency,
      settle: validated.quote_currency,
      active: validated.is_active,
      minAmount: parseFloat(validated.min_size),
      maxAmount: validated.max_position_size ? parseFloat(validated.max_position_size) : void 0,
      pricePrecision: 8,
      amountPrecision: 8,
      priceTickSize: parseFloat(validated.tick_size),
      amountStepSize: parseFloat(validated.min_size),
      makerFee: parseFloat(validated.maker_fee),
      takerFee: parseFloat(validated.taker_fee),
      maxLeverage: 50,
      // Nado typical max leverage
      fundingIntervalHours: 8
    };
  }
  /**
   * Normalize Nado order to unified Order format
   *
   * @param order - Nado order data
   * @param productMapping - Product mapping for symbol resolution
   * @returns Normalized order
   */
  normalizeOrder(order, productMapping) {
    const validated = NadoOrderSchema.parse(order);
    const price = this.fromX18Safe(validated.price_x18);
    const amount = this.fromX18Safe(validated.amount);
    const filled = this.fromX18Safe(validated.filled_amount);
    const remaining = this.fromX18Safe(validated.remaining_amount);
    return {
      id: validated.order_id,
      clientOrderId: validated.digest,
      timestamp: validated.timestamp,
      lastUpdateTimestamp: void 0,
      symbol: productMapping.ccxtSymbol,
      type: price > 0 ? "limit" : "market",
      timeInForce: validated.time_in_force?.toUpperCase(),
      postOnly: validated.post_only || false,
      reduceOnly: validated.is_reduce_only || false,
      side: validated.side === NADO_ORDER_SIDES.BUY ? "buy" : "sell",
      price,
      amount,
      remaining,
      filled,
      status: this.mapOrderStatus(validated.status),
      info: validated
    };
  }
  /**
   * Normalize Nado position to unified Position format
   *
   * @param position - Nado position data
   * @param productMapping - Product mapping for symbol resolution
   * @returns Normalized position or null if size is zero
   */
  normalizePosition(position, productMapping) {
    const validated = NadoPositionSchema.parse(position);
    const size = this.fromX18Safe(validated.size);
    if (size === 0) {
      return null;
    }
    const entryPrice = this.fromX18Safe(validated.entry_price);
    const markPrice = this.fromX18Safe(validated.mark_price);
    const unrealizedPnl = this.fromX18Safe(validated.unrealized_pnl);
    const realizedPnl = this.fromX18Safe(validated.realized_pnl);
    const margin = this.fromX18Safe(validated.margin);
    const side = size > 0 ? "long" : "short";
    return {
      symbol: productMapping.ccxtSymbol,
      side,
      size: Math.abs(size),
      unrealizedPnl,
      realizedPnl,
      leverage: parseFloat(validated.leverage),
      marginMode: "cross",
      margin,
      maintenanceMargin: margin * 0.05,
      // Typical 5% maintenance margin
      marginRatio: margin > 0 ? margin / (Math.abs(size) * markPrice) : 0,
      markPrice,
      entryPrice,
      liquidationPrice: validated.liquidation_price ? this.fromX18Safe(validated.liquidation_price) : 0,
      timestamp: validated.timestamp,
      info: validated
    };
  }
  /**
   * Normalize Nado balance to unified Balance format
   *
   * @param balance - Nado balance data
   * @returns Array of normalized balances
   */
  normalizeBalance(balance) {
    const validated = NadoBalanceSchema.parse(balance);
    const free = this.fromX18Safe(validated.free_margin);
    const used = this.fromX18Safe(validated.used_margin);
    const total = this.fromX18Safe(validated.total_equity);
    return [
      {
        currency: "USDT",
        // Nado uses USDT as main collateral
        free,
        used,
        total,
        info: validated
      }
    ];
  }
  /**
   * Normalize Nado trade to unified Trade format
   *
   * @param trade - Nado trade data
   * @param productMapping - Product mapping for symbol resolution
   * @returns Normalized trade
   */
  normalizeTrade(trade, productMapping) {
    const validated = NadoTradeSchema.parse(trade);
    const price = this.fromX18Safe(validated.price);
    const amount = this.fromX18Safe(validated.size);
    return {
      id: validated.trade_id,
      orderId: void 0,
      timestamp: validated.timestamp,
      symbol: productMapping.ccxtSymbol,
      side: validated.side === NADO_ORDER_SIDES.BUY ? "buy" : "sell",
      price,
      amount,
      cost: price * amount,
      info: validated
    };
  }
  /**
   * Normalize Nado ticker to unified Ticker format
   *
   * @param ticker - Nado ticker data (bid/ask from market_prices endpoint)
   * @param symbol - CCXT symbol (required since API doesn't return symbol)
   * @returns Normalized ticker
   */
  normalizeTicker(ticker, symbol) {
    const validated = NadoTickerSchema.parse(ticker);
    const bid = this.fromX18Safe(validated.bid_x18);
    const ask = this.fromX18Safe(validated.ask_x18);
    const last = (bid + ask) / 2;
    return {
      symbol,
      timestamp: Date.now(),
      high: 0,
      low: 0,
      bid,
      bidVolume: 0,
      ask,
      askVolume: 0,
      open: 0,
      close: last,
      last,
      change: 0,
      percentage: 0,
      baseVolume: 0,
      quoteVolume: 0,
      info: validated
    };
  }
  /**
   * Normalize Nado order book to unified OrderBook format
   *
   * @param orderBook - Nado order book data
   * @param symbol - CCXT formatted symbol
   * @returns Normalized order book
   */
  normalizeOrderBook(orderBook, symbol) {
    const validated = NadoOrderBookSchema.parse(orderBook);
    return {
      symbol,
      bids: validated.bids.map(([price, size]) => [
        this.fromX18Safe(price),
        this.fromX18Safe(size)
      ]),
      asks: validated.asks.map(([price, size]) => [
        this.fromX18Safe(price),
        this.fromX18Safe(size)
      ]),
      timestamp: Date.now(),
      exchange: "nado"
    };
  }
  // ===========================================================================
  // Batch Processing Optimization
  // ===========================================================================
  /**
   * Normalize multiple orders in batch
   *
   * More efficient than calling normalizeOrder() multiple times.
   * Filters out orders without valid product mappings.
   *
   * @param orders - Array of Nado orders
   * @param mappings - Map of product ID to ProductMapping
   * @returns Array of normalized orders
   *
   * @example
   * ```typescript
   * const orders = await apiClient.query('orders', {...});
   * const normalized = normalizer.normalizeOrders(orders, productMappings);
   * ```
   */
  normalizeOrders(orders, mappings) {
    return orders.map((order) => {
      const mapping = mappings.get(order.product_id.toString());
      if (!mapping) {
        this.logger.warn("No mapping found for product ID", { productId: order.product_id });
        return null;
      }
      try {
        return this.normalizeOrder(order, mapping);
      } catch (error) {
        this.logger.error("Failed to normalize order", error instanceof Error ? error : void 0, { orderId: order.order_id });
        return null;
      }
    }).filter((o) => o !== null);
  }
  /**
   * Normalize multiple positions in batch
   *
   * More efficient than calling normalizePosition() multiple times.
   * Filters out positions with zero size and invalid mappings.
   *
   * @param positions - Array of Nado positions
   * @param mappings - Map of product ID to ProductMapping
   * @returns Array of normalized positions
   *
   * @example
   * ```typescript
   * const positions = await apiClient.query('isolated_positions', {...});
   * const normalized = normalizer.normalizePositions(positions, productMappings);
   * ```
   */
  normalizePositions(positions, mappings) {
    return positions.map((position) => {
      const mapping = mappings.get(position.product_id.toString());
      if (!mapping) {
        this.logger.warn("No mapping found for product ID", { productId: position.product_id });
        return null;
      }
      try {
        return this.normalizePosition(position, mapping);
      } catch (error) {
        this.logger.error("Failed to normalize position", error instanceof Error ? error : void 0, { productId: position.product_id });
        return null;
      }
    }).filter((p) => p !== null);
  }
  /**
   * Normalize multiple trades in batch
   *
   * @param trades - Array of Nado trades
   * @param mappings - Map of product ID to ProductMapping
   * @returns Array of normalized trades
   */
  normalizeTrades(trades, mappings) {
    return trades.map((trade) => {
      const mapping = mappings.get(trade.product_id.toString());
      if (!mapping) {
        this.logger.warn("No mapping found for product ID", { productId: trade.product_id });
        return null;
      }
      try {
        return this.normalizeTrade(trade, mapping);
      } catch (error) {
        this.logger.error("Failed to normalize trade", error instanceof Error ? error : void 0, { tradeId: trade.trade_id });
        return null;
      }
    }).filter((t) => t !== null);
  }
  // ===========================================================================
  // Helper Methods
  // ===========================================================================
  /**
   * Map Nado order status to unified format
   *
   * @param status - Nado order status
   * @returns Unified order status
   */
  mapOrderStatus(status) {
    switch (status) {
      case "open":
        return "open";
      case "filled":
        return "closed";
      case "cancelled":
        return "canceled";
      // Note: CCXT uses 'canceled' not 'cancelled'
      case "expired":
        return "expired";
      case "rejected":
        return "rejected";
      default:
        return "rejected";
    }
  }
};

// src/adapters/nado/subscriptions.ts
var NadoSubscriptionBuilder = class {
  /**
   * Subscribe to order book updates for a product
   *
   * @param productId - Nado product ID
   * @returns Subscription payload
   *
   * @example
   * ```typescript
   * const sub = NadoSubscriptionBuilder.orderBook(2);
   * const channelId = NadoSubscriptionBuilder.channelId(NADO_WS_CHANNELS.ORDERBOOK, 2);
   * ```
   */
  static orderBook(productId) {
    return {
      type: "subscribe",
      channel: NADO_WS_CHANNELS.ORDERBOOK,
      product_id: productId
    };
  }
  /**
   * Subscribe to position updates for a subaccount
   *
   * @param subaccount - Wallet address (0x-prefixed)
   * @returns Subscription payload
   *
   * @example
   * ```typescript
   * const sub = NadoSubscriptionBuilder.positions('0x123...');
   * const channelId = NadoSubscriptionBuilder.channelId(NADO_WS_CHANNELS.POSITIONS, '0x123...');
   * ```
   */
  static positions(subaccount) {
    return {
      type: "subscribe",
      channel: NADO_WS_CHANNELS.POSITIONS,
      subaccount
    };
  }
  /**
   * Subscribe to order updates for a subaccount
   *
   * @param subaccount - Wallet address (0x-prefixed)
   * @returns Subscription payload
   *
   * @example
   * ```typescript
   * const sub = NadoSubscriptionBuilder.orders('0x123...');
   * const channelId = NadoSubscriptionBuilder.channelId(NADO_WS_CHANNELS.ORDERS, '0x123...');
   * ```
   */
  static orders(subaccount) {
    return {
      type: "subscribe",
      channel: NADO_WS_CHANNELS.ORDERS,
      subaccount
    };
  }
  /**
   * Subscribe to trade updates for a product
   *
   * @param productId - Nado product ID
   * @returns Subscription payload
   *
   * @example
   * ```typescript
   * const sub = NadoSubscriptionBuilder.trades(2);
   * const channelId = NadoSubscriptionBuilder.channelId(NADO_WS_CHANNELS.TRADES, 2);
   * ```
   */
  static trades(productId) {
    return {
      type: "subscribe",
      channel: NADO_WS_CHANNELS.TRADES,
      product_id: productId
    };
  }
  /**
   * Subscribe to balance updates for a subaccount
   *
   * @param subaccount - Wallet address (0x-prefixed)
   * @returns Subscription payload
   *
   * @example
   * ```typescript
   * const sub = NadoSubscriptionBuilder.balance('0x123...');
   * const channelId = NadoSubscriptionBuilder.channelId(NADO_WS_CHANNELS.SUBACCOUNT, '0x123...');
   * ```
   */
  static balance(subaccount) {
    return {
      type: "subscribe",
      channel: NADO_WS_CHANNELS.SUBACCOUNT,
      subaccount
    };
  }
  /**
   * Generate a unique channel ID for WebSocket subscription
   *
   * Channel IDs are used to identify specific data streams in the WebSocket manager.
   * Format: `channel:identifier` (e.g., "orderbook:2", "positions:0x123...")
   *
   * @param channel - Channel name (e.g., 'orderbook', 'positions')
   * @param identifier - Product ID (number) or subaccount address (string)
   * @returns Channel ID string
   *
   * @example
   * ```typescript
   * // Product-based channel
   * const obChannelId = NadoSubscriptionBuilder.channelId('orderbook', 2);
   * // 'orderbook:2'
   *
   * // Address-based channel
   * const posChannelId = NadoSubscriptionBuilder.channelId('positions', '0x123...');
   * // 'positions:0x123...'
   * ```
   */
  static channelId(channel, identifier) {
    return `${channel}:${identifier}`;
  }
  /**
   * Build an unsubscribe payload
   *
   * @param channel - Channel name
   * @param params - Additional parameters (e.g., product_id, subaccount)
   * @returns Unsubscribe payload
   *
   * @example
   * ```typescript
   * const unsub = NadoSubscriptionBuilder.unsubscribe('orderbook', { product_id: 2 });
   * // { type: 'unsubscribe', channel: 'orderbook', product_id: 2 }
   * ```
   */
  static unsubscribe(channel, params = {}) {
    return {
      type: "unsubscribe",
      channel,
      ...params
    };
  }
};

// src/adapters/nado/NadoAdapter.ts
var NadoAdapter = class extends BaseAdapter {
  id = "nado";
  name = "Nado";
  has = {
    // Market Data
    fetchMarkets: true,
    fetchTicker: true,
    fetchOrderBook: true,
    fetchTrades: false,
    // REST API not available, use watchTrades for WebSocket
    fetchFundingRate: true,
    fetchFundingRateHistory: false,
    // Trading
    createOrder: true,
    cancelOrder: true,
    cancelAllOrders: true,
    createBatchOrders: false,
    cancelBatchOrders: true,
    editOrder: false,
    // Account History
    fetchOrderHistory: true,
    fetchMyTrades: false,
    fetchDeposits: false,
    fetchWithdrawals: false,
    // Positions & Balance
    fetchPositions: true,
    fetchBalance: true,
    setLeverage: false,
    // Unified margin system
    setMarginMode: false,
    // WebSocket
    watchOrderBook: true,
    watchTrades: true,
    watchTicker: false,
    watchPositions: true,
    watchOrders: true,
    watchBalance: true,
    watchFundingRate: false,
    // Advanced
    twapOrders: false,
    vaultTrading: false,
    // Additional Info
    fetchUserFees: true,
    fetchPortfolio: false,
    fetchRateLimitStatus: false
  };
  apiUrl;
  wsUrl;
  wsManager;
  rateLimiter;
  // New component instances
  auth;
  apiClient;
  normalizer;
  // Nado-specific state
  chainId;
  contractsInfo;
  productMappings = /* @__PURE__ */ new Map();
  constructor(config = {}) {
    super(config);
    const urls = config.testnet ? NADO_API_URLS.testnet : NADO_API_URLS.mainnet;
    this.apiUrl = urls.rest;
    this.wsUrl = urls.ws;
    this.chainId = config.testnet ? NADO_CHAIN_ID.testnet : NADO_CHAIN_ID.mainnet;
    this.rateLimiter = new RateLimiter({
      maxTokens: NADO_RATE_LIMITS.queriesPerMinute,
      windowMs: 6e4,
      // 1 minute
      weights: {
        query: 1,
        execute: 2
      },
      exchange: "nado"
    });
    if (config.wallet || config.privateKey) {
      const wallet = config.wallet || new import_ethers5.Wallet(config.privateKey);
      this.auth = new NadoAuth(wallet, this.chainId);
    }
    this.apiClient = new NadoAPIClient({
      apiUrl: this.apiUrl,
      rateLimiter: this.rateLimiter,
      timeout: NADO_REQUEST_CONFIG.timeout
    });
    this.normalizer = new NadoNormalizer();
  }
  // ===========================================================================
  // Connection Management
  // ===========================================================================
  async initialize() {
    if (this._isReady) {
      this.debug("Already initialized");
      return;
    }
    try {
      this.debug("Initializing Nado adapter...");
      this.contractsInfo = await this.fetchContracts();
      this.debug("Contracts info fetched", {
        chainId: this.contractsInfo.chain_id,
        endpoint: this.contractsInfo.endpoint_addr
      });
      if (this.auth) {
        await this.fetchCurrentNonce();
        this.debug("Current nonce fetched", { nonce: this.auth.getCurrentNonce() });
      } else {
        this.debug("Skipping nonce fetch (no auth credentials)");
      }
      await this.preloadMarkets();
      this.debug("Markets preloaded", { count: this.productMappings.size });
      this.wsManager = new WebSocketManager({
        url: this.wsUrl,
        reconnect: {
          enabled: true,
          initialDelay: NADO_WS_CONFIG.reconnectDelay,
          maxDelay: NADO_WS_CONFIG.maxReconnectDelay,
          maxAttempts: NADO_WS_CONFIG.reconnectAttempts,
          multiplier: 2,
          jitter: 0.1
        },
        heartbeat: {
          enabled: true,
          interval: NADO_WS_CONFIG.pingInterval,
          timeout: NADO_WS_CONFIG.pongTimeout
        }
      });
      this._isReady = true;
      this.debug("Nado adapter initialized successfully");
    } catch (error) {
      this.error("Failed to initialize Nado adapter", error);
      throw new ExchangeUnavailableError(
        `Nado initialization failed: ${error instanceof Error ? error.message : "Unknown error"}`,
        "INIT_FAILED",
        this.id,
        error
      );
    }
  }
  async disconnect() {
    this.debug("Disconnecting from Nado...");
    if (this.wsManager) {
      await this.wsManager.disconnect();
      this.wsManager = void 0;
    }
    this.productMappings.clear();
    await super.disconnect();
    this.debug("Disconnected from Nado");
  }
  /**
   * Connect to Nado exchange
   * Alias for initialize() to maintain consistency with other adapters
   */
  async connect() {
    return this.initialize();
  }
  // ===========================================================================
  // Private Helper Methods
  // ===========================================================================
  /**
   * Fetch contracts information
   */
  async fetchContracts() {
    const data = await this.apiClient.query(NADO_QUERY_TYPES.CONTRACTS);
    return NadoContractsSchema.parse(data);
  }
  /**
   * Fetch current nonce for the wallet
   *
   * Nado returns two nonce types as strings (64-bit integers):
   * - tx_nonce: For non-order executions (withdraw, liquidate, etc.)
   * - order_nonce: For place_order executions
   */
  async fetchCurrentNonce() {
    if (!this.auth) return;
    const data = await this.apiClient.query(
      NADO_QUERY_TYPES.NONCES,
      {
        address: this.auth.getAddress()
      }
    );
    this.auth.setNonce(data.order_nonce);
  }
  /**
   * Get product mapping by symbol
   */
  getProductMapping(symbol) {
    const mapping = this.productMappings.get(symbol);
    if (!mapping) {
      throw new InvalidOrderError(
        `Product mapping not found for ${symbol}`,
        "MAPPING_NOT_FOUND",
        this.id
      );
    }
    return mapping;
  }
  /**
   * Require authentication for private methods
   * @throws {PerpDEXError} if auth is not configured
   */
  requireAuth() {
    if (!this.auth) {
      throw new PerpDEXError(
        "Authentication required. Provide wallet or privateKey in config.",
        "MISSING_CREDENTIALS",
        this.id
      );
    }
    return this.auth;
  }
  // ===========================================================================
  // Market Data - Public Methods
  // ===========================================================================
  async fetchMarkets(params) {
    const cached = this.getPreloadedMarkets();
    if (cached) {
      this.debug("Returning cached markets", { count: cached.length });
      return cached;
    }
    return this.fetchMarketsFromAPI(params);
  }
  /**
   * Internal method to fetch markets from API (bypasses cache)
   *
   * Uses the /query?type=symbols endpoint which returns market metadata
   */
  async fetchMarketsFromAPI(_params) {
    this.debug("Fetching markets from API...");
    const response = await this.apiClient.query(NADO_QUERY_TYPES.SYMBOLS);
    this.productMappings.clear();
    const markets = [];
    for (const [_symbolKey, symbolData] of Object.entries(response.symbols || {})) {
      const market = this.normalizer.normalizeSymbol(symbolData);
      markets.push(market);
      const mapping = {
        productId: symbolData.product_id,
        symbol: symbolData.symbol,
        ccxtSymbol: market.symbol
      };
      this.productMappings.set(market.symbol, mapping);
    }
    this.debug("Markets fetched", { count: markets.length });
    return markets;
  }
  async fetchTicker(symbol) {
    const mapping = this.getProductMapping(symbol);
    const response = await this.apiClient.query(
      NADO_QUERY_TYPES.MARKET_PRICES,
      {
        product_ids: [mapping.productId]
      }
    );
    const ticker = response.market_prices?.[0];
    if (!ticker) {
      throw new PerpDEXError(`No ticker data for ${symbol}`, "NO_DATA", this.id);
    }
    return this.normalizer.normalizeTicker(NadoTickerSchema.parse(ticker), symbol);
  }
  async fetchOrderBook(symbol, params) {
    const mapping = this.getProductMapping(symbol);
    const depth = params?.limit || 20;
    const orderBook = await this.apiClient.query(NADO_QUERY_TYPES.MARKET_LIQUIDITY, {
      product_id: mapping.productId,
      depth
    });
    return this.normalizer.normalizeOrderBook(NadoOrderBookSchema.parse(orderBook), symbol);
  }
  async fetchTrades(_symbol, _params) {
    throw new PerpDEXError(
      "fetchTrades not supported via REST API on Nado. Use watchTrades() for WebSocket streaming.",
      "NOT_SUPPORTED",
      this.id
    );
  }
  async fetchFundingRate(symbol) {
    const ticker = await this.fetchTicker(symbol);
    if (!ticker.info?.fundingRate) {
      throw new PerpDEXError(
        "Funding rate not available for this symbol",
        "NO_FUNDING_RATE",
        this.id
      );
    }
    const info = ticker.info;
    return {
      symbol,
      fundingRate: parseFloat(info.fundingRate),
      fundingTimestamp: Date.now(),
      nextFundingTimestamp: info.nextFundingTime || Date.now() + 8 * 3600 * 1e3,
      markPrice: parseFloat(info.markPrice),
      indexPrice: parseFloat(info.indexPrice),
      fundingIntervalHours: 8
    };
  }
  // ===========================================================================
  // Trading - Private Methods (Require Authentication)
  // ===========================================================================
  async createOrder(request) {
    const auth = this.requireAuth();
    if (!this.contractsInfo) {
      throw new PerpDEXError("Contracts info not loaded", "NO_CONTRACTS", this.id);
    }
    const mapping = this.getProductMapping(request.symbol);
    const priceX18 = import_ethers5.ethers.parseUnits((request.price || 0).toString(), 18).toString();
    const amount = import_ethers5.ethers.parseUnits(request.amount.toString(), 18).toString();
    const expiration = Math.floor(Date.now() / 1e3) + 86400;
    const nonce = auth.getNextNonce();
    const orderData = {
      sender: auth.getAddress(),
      priceX18,
      amount,
      expiration,
      nonce,
      appendix: {
        productId: mapping.productId,
        side: request.side === "buy" ? NADO_ORDER_SIDES.BUY : NADO_ORDER_SIDES.SELL,
        reduceOnly: request.reduceOnly || false,
        postOnly: request.postOnly || false
      }
    };
    const signature = await auth.signOrder(orderData, mapping.productId);
    const response = await this.apiClient.execute(
      NADO_EXECUTE_TYPES.PLACE_ORDER,
      orderData,
      signature
    );
    return this.normalizer.normalizeOrder(NadoOrderSchema.parse(response), mapping);
  }
  async cancelOrder(orderId, _symbol) {
    const auth = this.requireAuth();
    if (!this.contractsInfo) {
      throw new PerpDEXError("Contracts info not loaded", "NO_CONTRACTS", this.id);
    }
    const order = await this.apiClient.query(NADO_QUERY_TYPES.ORDER, {
      order_id: orderId
    });
    const mapping = Array.from(this.productMappings.values()).find(
      (m) => m.productId === order.product_id
    );
    if (!mapping) {
      throw new InvalidOrderError("Product mapping not found", "MAPPING_NOT_FOUND", this.id);
    }
    const cancellationData = {
      sender: auth.getAddress(),
      productIds: [order.product_id],
      digests: [order.digest],
      nonce: auth.getNextNonce()
    };
    const signature = await auth.signCancellation(
      cancellationData,
      this.contractsInfo.endpoint_addr
    );
    await this.apiClient.execute(
      NADO_EXECUTE_TYPES.CANCEL_ORDERS,
      cancellationData,
      signature
    );
    return this.normalizer.normalizeOrder(NadoOrderSchema.parse(order), mapping);
  }
  async cancelAllOrders(symbol) {
    const auth = this.requireAuth();
    if (!this.contractsInfo) {
      throw new PerpDEXError("Contracts info not loaded", "NO_CONTRACTS", this.id);
    }
    const orders = await this.apiClient.query(NADO_QUERY_TYPES.ORDERS, {
      subaccount: auth.getAddress(),
      status: "open"
    });
    if (orders.length === 0) {
      return [];
    }
    let ordersToCancel = orders;
    if (symbol) {
      const mapping = this.getProductMapping(symbol);
      ordersToCancel = orders.filter((o) => o.product_id === mapping.productId);
    }
    const cancellationData = {
      sender: auth.getAddress(),
      productIds: ordersToCancel.map((o) => o.product_id),
      digests: ordersToCancel.map((o) => o.digest),
      nonce: auth.getNextNonce()
    };
    const signature = await auth.signCancellation(
      cancellationData,
      this.contractsInfo.endpoint_addr
    );
    await this.apiClient.execute(
      NADO_EXECUTE_TYPES.CANCEL_ORDERS,
      cancellationData,
      signature
    );
    const mappingsArray = Array.from(this.productMappings.values());
    return ordersToCancel.map((order) => {
      const mapping = mappingsArray.find((m) => m.productId === order.product_id);
      return this.normalizer.normalizeOrder(order, mapping);
    });
  }
  async fetchPositions(_symbols) {
    const auth = this.requireAuth();
    const positions = await this.apiClient.query(
      NADO_QUERY_TYPES.ISOLATED_POSITIONS,
      {
        subaccount: auth.getAddress()
      }
    );
    const mappingsArray = Array.from(this.productMappings.values());
    const normalized = [];
    for (const position of positions) {
      const mapping = mappingsArray.find((m) => m.productId === position.product_id);
      if (!mapping) {
        this.warn(`Product mapping not found for product ID ${position.product_id}`);
        continue;
      }
      const normalizedPosition = this.normalizer.normalizePosition(
        NadoPositionSchema.parse(position),
        mapping
      );
      if (normalizedPosition) {
        normalized.push(normalizedPosition);
      }
    }
    return normalized;
  }
  async fetchBalance() {
    const auth = this.requireAuth();
    const balance = await this.apiClient.query(NADO_QUERY_TYPES.SUBACCOUNT_INFO, {
      subaccount: auth.getAddress()
    });
    return this.normalizer.normalizeBalance(NadoBalanceSchema.parse(balance));
  }
  /**
   * Fetch open orders
   *
   * Retrieves all open (unfilled) orders for the authenticated wallet.
   * Can be filtered by symbol to get orders for a specific trading pair.
   *
   * @param symbol - Optional symbol to filter orders (e.g., "BTC/USDT:USDT")
   * @returns Array of open orders
   * @throws {PerpDEXError} If wallet is not initialized
   *
   * @example
   * ```typescript
   * // Get all open orders
   * const allOrders = await adapter.fetchOpenOrders();
   *
   * // Get open orders for specific symbol
   * const btcOrders = await adapter.fetchOpenOrders('BTC/USDT:USDT');
   * ```
   */
  async fetchOpenOrders(symbol) {
    const auth = this.requireAuth();
    const orders = await this.apiClient.query(NADO_QUERY_TYPES.ORDERS, {
      subaccount: auth.getAddress(),
      status: "open"
    });
    if (orders.length === 0) {
      return [];
    }
    let filteredOrders = orders;
    if (symbol) {
      const mapping = this.getProductMapping(symbol);
      filteredOrders = orders.filter((o) => o.product_id === mapping.productId);
    }
    const mappingsArray = Array.from(this.productMappings.values());
    return filteredOrders.map((order) => {
      const mapping = mappingsArray.find((m) => m.productId === order.product_id);
      if (!mapping) return null;
      return this.normalizer.normalizeOrder(order, mapping);
    }).filter((o) => o !== null);
  }
  // ===========================================================================
  // WebSocket Streaming
  // ===========================================================================
  async *watchOrderBook(symbol) {
    if (!this.wsManager) {
      throw new PerpDEXError("WebSocket not initialized", "NO_WEBSOCKET", this.id);
    }
    const mapping = this.getProductMapping(symbol);
    const subscription = NadoSubscriptionBuilder.orderBook(mapping.productId);
    const channelId = NadoSubscriptionBuilder.channelId(NADO_WS_CHANNELS.ORDERBOOK, mapping.productId);
    for await (const update of this.wsManager.watch(channelId, subscription)) {
      yield this.normalizer.normalizeOrderBook(update, symbol);
    }
  }
  async *watchPositions() {
    const auth = this.requireAuth();
    if (!this.wsManager) {
      throw new PerpDEXError("WebSocket not initialized", "NO_WEBSOCKET", this.id);
    }
    const walletAddress = auth.getAddress();
    const subscription = NadoSubscriptionBuilder.positions(walletAddress);
    const channelId = NadoSubscriptionBuilder.channelId(NADO_WS_CHANNELS.POSITIONS, walletAddress);
    for await (const positions of this.wsManager.watch(channelId, subscription)) {
      const mappingsArray = Array.from(this.productMappings.values());
      const normalized = [];
      for (const position of positions) {
        const mapping = mappingsArray.find((m) => m.productId === position.product_id);
        if (!mapping) continue;
        const normalizedPos = this.normalizer.normalizePosition(position, mapping);
        if (normalizedPos) normalized.push(normalizedPos);
      }
      yield normalized;
    }
  }
  async *watchOrders() {
    const auth = this.requireAuth();
    if (!this.wsManager) {
      throw new PerpDEXError("WebSocket not initialized", "NO_WEBSOCKET", this.id);
    }
    const walletAddress = auth.getAddress();
    const subscription = NadoSubscriptionBuilder.orders(walletAddress);
    const channelId = NadoSubscriptionBuilder.channelId(NADO_WS_CHANNELS.ORDERS, walletAddress);
    for await (const orders of this.wsManager.watch(channelId, subscription)) {
      const mappingsArray = Array.from(this.productMappings.values());
      const normalized = [];
      for (const order of orders) {
        const mapping = mappingsArray.find((m) => m.productId === order.product_id);
        if (!mapping) continue;
        normalized.push(this.normalizer.normalizeOrder(order, mapping));
      }
      yield normalized;
    }
  }
  async *watchTrades(symbol) {
    if (!this.wsManager) {
      throw new PerpDEXError("WebSocket not initialized", "NO_WEBSOCKET", this.id);
    }
    const mapping = this.getProductMapping(symbol);
    const subscription = NadoSubscriptionBuilder.trades(mapping.productId);
    const channelId = NadoSubscriptionBuilder.channelId(NADO_WS_CHANNELS.TRADES, mapping.productId);
    for await (const trade of this.wsManager.watch(channelId, subscription)) {
      yield this.normalizer.normalizeTrade(trade, mapping);
    }
  }
  /**
   * Watch balance updates in real-time via WebSocket
   *
   * Streams balance changes for the authenticated wallet's subaccount.
   * Updates are pushed whenever deposits, withdrawals, or P&L changes occur.
   *
   * @returns Async generator yielding balance arrays
   * @throws {PerpDEXError} If WebSocket is not initialized
   *
   * @example
   * ```typescript
   * for await (const balances of adapter.watchBalance()) {
   *   console.log('Balances updated:', balances);
   *   // [{ asset: 'USDT', free: 1000, used: 200, total: 1200 }]
   * }
   * ```
   */
  async *watchBalance() {
    const auth = this.requireAuth();
    if (!this.wsManager) {
      throw new PerpDEXError("WebSocket not initialized", "NO_WEBSOCKET", this.id);
    }
    const walletAddress = auth.getAddress();
    const subscription = NadoSubscriptionBuilder.balance(walletAddress);
    const channelId = NadoSubscriptionBuilder.channelId(NADO_WS_CHANNELS.SUBACCOUNT, walletAddress);
    for await (const balance of this.wsManager.watch(channelId, subscription)) {
      yield this.normalizer.normalizeBalance(balance);
    }
  }
  // ===========================================================================
  // Symbol Conversion (Required by BaseAdapter)
  // ===========================================================================
  symbolToExchange(symbol) {
    return this.normalizer.symbolFromCCXT(symbol);
  }
  symbolFromExchange(exchangeSymbol) {
    return this.normalizer.symbolToCCXT(exchangeSymbol);
  }
  // ===========================================================================
  // Not Implemented Methods (Return empty/throw)
  // ===========================================================================
  async fetchFundingRateHistory(_symbol, _since, _limit) {
    throw new PerpDEXError(
      "fetchFundingRateHistory not supported on Nado",
      "NOT_SUPPORTED",
      this.id
    );
  }
  async fetchOrderHistory(_symbol, _since, _limit) {
    const auth = this.requireAuth();
    const orders = await this.apiClient.query(NADO_QUERY_TYPES.ORDERS, {
      subaccount: auth.getAddress()
    });
    const mappingsArray = Array.from(this.productMappings.values());
    return orders.map((order) => {
      const mapping = mappingsArray.find((m) => m.productId === order.product_id);
      if (!mapping) return null;
      return this.normalizer.normalizeOrder(order, mapping);
    }).filter((o) => o !== null);
  }
  async fetchMyTrades(_symbol, _since, _limit) {
    throw new PerpDEXError(
      "fetchMyTrades not supported on Nado (use WebSocket fills channel)",
      "NOT_SUPPORTED",
      this.id
    );
  }
  async setLeverage(_symbol, _leverage) {
    throw new PerpDEXError(
      "setLeverage not supported on Nado (unified cross-margin system)",
      "NOT_SUPPORTED",
      this.id
    );
  }
};

// src/adapters/variational/constants.ts
var VARIATIONAL_API_URLS = {
  mainnet: {
    rest: "https://omni-client-api.prod.ap-northeast-1.variational.io",
    websocket: "wss://ws.variational.io"
    // TODO: Update when WebSocket available
  },
  testnet: {
    rest: "https://omni-client-api.testnet.variational.io",
    // TODO: Update when testnet available
    websocket: "wss://ws-testnet.variational.io"
  }
};
var VARIATIONAL_ENDPOINTS = {
  // Market Data (Public) - Currently Available
  METADATA_STATS: "/metadata/stats",
  // Returns platform-wide and per-listing statistics
  // Market Data (Public) - Planned/Expected
  MARKETS: "/api/v1/markets",
  TICKER: "/api/v1/ticker/{symbol}",
  ORDERBOOK: "/api/v1/orderbook/{symbol}",
  TRADES: "/api/v1/trades/{symbol}",
  FUNDING_RATE: "/api/v1/funding/{symbol}",
  FUNDING_HISTORY: "/api/v1/funding/{symbol}/history",
  // RFQ Specific - Under Development
  REQUEST_QUOTE: "/api/v1/rfq/request",
  ACCEPT_QUOTE: "/api/v1/rfq/accept/{quoteId}",
  QUOTES_HISTORY: "/api/v1/rfq/history",
  // Trading (Private) - Under Development
  CREATE_ORDER: "/api/v1/orders",
  CANCEL_ORDER: "/api/v1/orders/{orderId}",
  CANCEL_ALL_ORDERS: "/api/v1/orders/cancel-all",
  OPEN_ORDERS: "/api/v1/orders/open",
  ORDER_HISTORY: "/api/v1/orders/history",
  ORDER_STATUS: "/api/v1/orders/{orderId}",
  // Account & Positions - Under Development
  POSITIONS: "/api/v1/positions",
  BALANCE: "/api/v1/balance",
  USER_TRADES: "/api/v1/trades/user",
  USER_FEES: "/api/v1/fees",
  PORTFOLIO: "/api/v1/portfolio",
  // Rate Limit Status
  RATE_LIMIT_STATUS: "/api/v1/rate-limit"
};
var VARIATIONAL_RATE_LIMITS = {
  perIp: {
    maxRequests: 10,
    windowMs: 1e4
    // 10 seconds
  },
  global: {
    maxRequests: 1e3,
    windowMs: 6e4
    // 1 minute
  },
  // Conservative default (use per-IP limit)
  default: {
    maxRequests: 10,
    windowMs: 1e4
    // 10 seconds
  }
};
var VARIATIONAL_ENDPOINT_WEIGHTS = {
  [VARIATIONAL_ENDPOINTS.METADATA_STATS]: 1,
  [VARIATIONAL_ENDPOINTS.MARKETS]: 1,
  [VARIATIONAL_ENDPOINTS.TICKER]: 1,
  [VARIATIONAL_ENDPOINTS.ORDERBOOK]: 2,
  [VARIATIONAL_ENDPOINTS.TRADES]: 1,
  [VARIATIONAL_ENDPOINTS.FUNDING_RATE]: 1,
  [VARIATIONAL_ENDPOINTS.REQUEST_QUOTE]: 5,
  [VARIATIONAL_ENDPOINTS.ACCEPT_QUOTE]: 10,
  [VARIATIONAL_ENDPOINTS.CREATE_ORDER]: 10,
  [VARIATIONAL_ENDPOINTS.CANCEL_ORDER]: 5,
  [VARIATIONAL_ENDPOINTS.POSITIONS]: 2,
  [VARIATIONAL_ENDPOINTS.BALANCE]: 2
};
var VARIATIONAL_DEFAULTS = {
  timeout: 3e4,
  // 30 seconds
  rateLimitTier: "default",
  orderBookDepth: 50,
  tradesLimit: 100,
  orderHistoryLimit: 500,
  quoteExpirationMs: 1e4
  // 10 seconds for RFQ quotes
};

// src/adapters/variational/error-codes.ts
var VARIATIONAL_CLIENT_ERRORS = {
  INSUFFICIENT_MARGIN: "INSUFFICIENT_MARGIN",
  INVALID_SIGNATURE: "INVALID_SIGNATURE",
  INVALID_ORDER: "INVALID_ORDER",
  INVALID_SYMBOL: "INVALID_SYMBOL",
  INVALID_AMOUNT: "INVALID_AMOUNT",
  INVALID_PRICE: "INVALID_PRICE",
  ORDER_NOT_FOUND: "ORDER_NOT_FOUND",
  POSITION_NOT_FOUND: "POSITION_NOT_FOUND",
  QUOTE_NOT_FOUND: "QUOTE_NOT_FOUND",
  QUOTE_EXPIRED: "QUOTE_EXPIRED",
  INVALID_API_KEY: "INVALID_API_KEY",
  UNAUTHORIZED: "UNAUTHORIZED",
  FORBIDDEN: "FORBIDDEN"
};
var VARIATIONAL_SERVER_ERRORS = {
  INTERNAL_ERROR: "INTERNAL_ERROR",
  SERVICE_UNAVAILABLE: "SERVICE_UNAVAILABLE",
  TIMEOUT: "TIMEOUT",
  MATCHING_ENGINE_ERROR: "MATCHING_ENGINE_ERROR"
};
var VARIATIONAL_RATE_LIMIT_ERROR = "RATE_LIMIT_EXCEEDED";
var VARIATIONAL_HTTP_ERROR_CODES = {
  400: VARIATIONAL_CLIENT_ERRORS.INVALID_ORDER,
  401: VARIATIONAL_CLIENT_ERRORS.UNAUTHORIZED,
  403: VARIATIONAL_CLIENT_ERRORS.FORBIDDEN,
  404: VARIATIONAL_CLIENT_ERRORS.ORDER_NOT_FOUND,
  429: VARIATIONAL_RATE_LIMIT_ERROR,
  500: VARIATIONAL_SERVER_ERRORS.INTERNAL_ERROR,
  502: VARIATIONAL_SERVER_ERRORS.SERVICE_UNAVAILABLE,
  503: VARIATIONAL_SERVER_ERRORS.SERVICE_UNAVAILABLE,
  504: VARIATIONAL_SERVER_ERRORS.TIMEOUT
};
var VARIATIONAL_ERROR_MESSAGES = {
  "insufficient margin": VARIATIONAL_CLIENT_ERRORS.INSUFFICIENT_MARGIN,
  "insufficient balance": VARIATIONAL_CLIENT_ERRORS.INSUFFICIENT_MARGIN,
  "invalid signature": VARIATIONAL_CLIENT_ERRORS.INVALID_SIGNATURE,
  "signature verification failed": VARIATIONAL_CLIENT_ERRORS.INVALID_SIGNATURE,
  "invalid order": VARIATIONAL_CLIENT_ERRORS.INVALID_ORDER,
  "invalid symbol": VARIATIONAL_CLIENT_ERRORS.INVALID_SYMBOL,
  "invalid amount": VARIATIONAL_CLIENT_ERRORS.INVALID_AMOUNT,
  "invalid price": VARIATIONAL_CLIENT_ERRORS.INVALID_PRICE,
  "order not found": VARIATIONAL_CLIENT_ERRORS.ORDER_NOT_FOUND,
  "quote not found": VARIATIONAL_CLIENT_ERRORS.QUOTE_NOT_FOUND,
  "quote expired": VARIATIONAL_CLIENT_ERRORS.QUOTE_EXPIRED,
  "rate limit exceeded": VARIATIONAL_RATE_LIMIT_ERROR,
  "too many requests": VARIATIONAL_RATE_LIMIT_ERROR,
  "internal server error": VARIATIONAL_SERVER_ERRORS.INTERNAL_ERROR,
  "service unavailable": VARIATIONAL_SERVER_ERRORS.SERVICE_UNAVAILABLE,
  "timeout": VARIATIONAL_SERVER_ERRORS.TIMEOUT,
  "matching engine error": VARIATIONAL_SERVER_ERRORS.MATCHING_ENGINE_ERROR
};
function extractErrorCodeFromStatus(status) {
  return VARIATIONAL_HTTP_ERROR_CODES[status] || "UNKNOWN_ERROR";
}
function mapVariationalError(code, message, context) {
  const errorCode = typeof code === "number" ? extractErrorCodeFromStatus(code) : code;
  switch (errorCode) {
    case VARIATIONAL_CLIENT_ERRORS.INSUFFICIENT_MARGIN:
      return new InsufficientMarginError(message, errorCode, "variational", context);
    case VARIATIONAL_CLIENT_ERRORS.INVALID_SIGNATURE:
    case VARIATIONAL_CLIENT_ERRORS.INVALID_API_KEY:
    case VARIATIONAL_CLIENT_ERRORS.UNAUTHORIZED:
      return new InvalidSignatureError(message, errorCode, "variational", context);
    case VARIATIONAL_CLIENT_ERRORS.INVALID_ORDER:
    case VARIATIONAL_CLIENT_ERRORS.INVALID_SYMBOL:
    case VARIATIONAL_CLIENT_ERRORS.INVALID_AMOUNT:
    case VARIATIONAL_CLIENT_ERRORS.INVALID_PRICE:
    case VARIATIONAL_CLIENT_ERRORS.QUOTE_EXPIRED:
      return new InvalidOrderError(message, errorCode, "variational", context);
    case VARIATIONAL_CLIENT_ERRORS.ORDER_NOT_FOUND:
    case VARIATIONAL_CLIENT_ERRORS.QUOTE_NOT_FOUND:
      return new OrderNotFoundError(message, errorCode, "variational", context);
    case VARIATIONAL_RATE_LIMIT_ERROR:
      return new RateLimitError(message, errorCode, "variational", void 0, context);
    case VARIATIONAL_SERVER_ERRORS.SERVICE_UNAVAILABLE:
    case VARIATIONAL_SERVER_ERRORS.TIMEOUT:
      return new ExchangeUnavailableError(message, errorCode, "variational", context);
    case VARIATIONAL_SERVER_ERRORS.INTERNAL_ERROR:
    case VARIATIONAL_SERVER_ERRORS.MATCHING_ENGINE_ERROR:
      return new NetworkError(message, errorCode, "variational", context);
    default:
      return new PerpDEXError(message, errorCode, "variational", context);
  }
}

// src/adapters/variational/utils.ts
function convertOrderRequest3(request) {
  return {
    symbol: request.symbol,
    type: request.type,
    side: request.side,
    amount: request.amount.toString(),
    price: request.price?.toString(),
    clientOrderId: request.clientOrderId,
    postOnly: request.postOnly,
    reduceOnly: request.reduceOnly
  };
}
function mapError3(error) {
  if (error instanceof PerpDEXError) {
    return error;
  }
  const message = error?.message || error?.error || String(error);
  const code = error?.code || error?.status || "UNKNOWN_ERROR";
  const context = {
    originalError: error
  };
  return mapVariationalError(code, message, context);
}
function countDecimals(value) {
  if (!value || !value.includes(".")) {
    return 0;
  }
  return value.split(".")[1]?.length || 0;
}
function validateOrderRequest2(request) {
  if (!request.symbol) {
    throw new PerpDEXError("Symbol is required", "INVALID_SYMBOL", "variational");
  }
  if (!request.type) {
    throw new PerpDEXError("Order type is required", "INVALID_ORDER_TYPE", "variational");
  }
  if (!request.side) {
    throw new PerpDEXError("Order side is required", "INVALID_ORDER_SIDE", "variational");
  }
  if (!request.amount || request.amount <= 0) {
    throw new PerpDEXError("Amount must be greater than 0", "INVALID_AMOUNT", "variational");
  }
  if (request.type === "limit" && (!request.price || request.price <= 0)) {
    throw new PerpDEXError("Price is required for limit orders", "INVALID_PRICE", "variational");
  }
}
function generateClientOrderId() {
  return `var_${Date.now()}_${Math.random().toString(36).substring(2, 11)}`;
}
function safeParseFloat(value) {
  if (value === void 0 || value === null || value === "") {
    return 0;
  }
  const parsed = typeof value === "string" ? parseFloat(value) : value;
  return isNaN(parsed) ? 0 : parsed;
}

// src/adapters/variational/VariationalNormalizer.ts
var VariationalNormalizer = class {
  /**
   * Convert Variational symbol to unified CCXT format
   * "BTC-USDT-PERP" â†’ "BTC/USDT:USDT"
   */
  symbolToCCXT(variationalSymbol) {
    const parts = variationalSymbol.split("-");
    if (parts.length === 3 && parts[2] === "PERP") {
      const [base, quote] = parts;
      return `${base}/${quote}:${quote}`;
    }
    return variationalSymbol;
  }
  /**
   * Convert unified CCXT symbol to Variational format
   * "BTC/USDT:USDT" â†’ "BTC-USDT-PERP"
   */
  symbolFromCCXT(ccxtSymbol) {
    const [pair] = ccxtSymbol.split(":");
    if (!pair) {
      return ccxtSymbol;
    }
    const [base, quote] = pair.split("/");
    if (!base || !quote) {
      return ccxtSymbol;
    }
    return `${base}-${quote}-PERP`;
  }
  /**
   * Normalize market data from listing (from /metadata/stats)
   */
  normalizeMarketFromListing(listing) {
    const unifiedSymbol = `${listing.ticker}/USDC:USDC`;
    return {
      id: listing.ticker,
      symbol: unifiedSymbol,
      base: listing.ticker,
      quote: "USDC",
      settle: "USDC",
      contractSize: 1,
      active: true,
      // Listed markets are active
      minAmount: 1e-3,
      // Default, actual value from RFQ
      maxAmount: void 0,
      pricePrecision: 2,
      amountPrecision: 3,
      priceTickSize: 0.01,
      amountStepSize: 1e-3,
      makerFee: 0,
      // RFQ model, spreads included in quotes
      takerFee: 0,
      maxLeverage: 50,
      // Default leverage
      fundingIntervalHours: listing.funding_interval_s / 3600,
      info: listing
    };
  }
  /**
   * Normalize market data
   */
  normalizeMarket(market) {
    const unifiedSymbol = this.symbolToCCXT(market.symbol);
    return {
      id: market.symbol,
      symbol: unifiedSymbol,
      base: market.baseAsset,
      quote: market.quoteAsset,
      settle: market.quoteAsset,
      contractSize: safeParseFloat(market.contractSize || "1"),
      active: market.status === "active",
      minAmount: safeParseFloat(market.minOrderSize),
      maxAmount: market.maxOrderSize ? safeParseFloat(market.maxOrderSize) : void 0,
      pricePrecision: countDecimals(market.tickSize),
      amountPrecision: countDecimals(market.minOrderSize),
      priceTickSize: safeParseFloat(market.tickSize),
      amountStepSize: safeParseFloat(market.minOrderSize),
      makerFee: 2e-4,
      takerFee: 5e-4,
      maxLeverage: market.maxLeverage ? safeParseFloat(market.maxLeverage) : 50,
      fundingIntervalHours: 8,
      info: market
    };
  }
  /**
   * Normalize ticker data from listing (from /metadata/stats)
   */
  normalizeTickerFromListing(listing) {
    const unifiedSymbol = `${listing.ticker}/USDC:USDC`;
    const timestamp = Date.now();
    const markPrice = safeParseFloat(listing.mark_price);
    return {
      symbol: unifiedSymbol,
      timestamp,
      high: markPrice,
      // Not available from /metadata/stats
      low: markPrice,
      // Not available from /metadata/stats
      bid: safeParseFloat(listing.quotes.size_100k.bid),
      ask: safeParseFloat(listing.quotes.size_100k.ask),
      last: markPrice,
      open: markPrice,
      // Not available from /metadata/stats
      close: markPrice,
      baseVolume: safeParseFloat(listing.volume_24h),
      quoteVolume: safeParseFloat(listing.volume_24h),
      change: 0,
      // Not available from /metadata/stats
      percentage: 0,
      // Not available from /metadata/stats
      info: listing
    };
  }
  /**
   * Normalize ticker data
   */
  normalizeTicker(ticker) {
    const unifiedSymbol = this.symbolToCCXT(ticker.symbol);
    return {
      symbol: unifiedSymbol,
      timestamp: ticker.timestamp,
      high: safeParseFloat(ticker.high24h),
      low: safeParseFloat(ticker.low24h),
      bid: safeParseFloat(ticker.bidPrice),
      ask: safeParseFloat(ticker.askPrice),
      last: safeParseFloat(ticker.lastPrice),
      open: safeParseFloat(ticker.lastPrice),
      close: safeParseFloat(ticker.lastPrice),
      baseVolume: safeParseFloat(ticker.volume24h),
      quoteVolume: 0,
      change: safeParseFloat(ticker.priceChange24h),
      percentage: safeParseFloat(ticker.priceChangePercent24h),
      info: ticker
    };
  }
  /**
   * Normalize order book data
   */
  normalizeOrderBook(orderbook) {
    const unifiedSymbol = this.symbolToCCXT(orderbook.symbol);
    return {
      exchange: "variational",
      symbol: unifiedSymbol,
      bids: orderbook.bids.map(([price, amount]) => [
        safeParseFloat(price),
        safeParseFloat(amount)
      ]),
      asks: orderbook.asks.map(([price, amount]) => [
        safeParseFloat(price),
        safeParseFloat(amount)
      ]),
      timestamp: orderbook.timestamp
    };
  }
  /**
   * Normalize trade data
   */
  normalizeTrade(trade) {
    const unifiedSymbol = this.symbolToCCXT(trade.symbol);
    return {
      id: trade.id,
      orderId: void 0,
      symbol: unifiedSymbol,
      side: trade.side,
      price: safeParseFloat(trade.price),
      amount: safeParseFloat(trade.amount),
      cost: safeParseFloat(trade.price) * safeParseFloat(trade.amount),
      timestamp: trade.timestamp,
      info: trade
    };
  }
  /**
   * Normalize funding rate data
   */
  normalizeFundingRate(fundingRate) {
    const unifiedSymbol = this.symbolToCCXT(fundingRate.symbol);
    return {
      symbol: unifiedSymbol,
      fundingRate: safeParseFloat(fundingRate.fundingRate),
      fundingTimestamp: fundingRate.fundingTime,
      nextFundingTimestamp: fundingRate.nextFundingTime || 0,
      markPrice: fundingRate.markPrice ? safeParseFloat(fundingRate.markPrice) : 0,
      indexPrice: fundingRate.indexPrice ? safeParseFloat(fundingRate.indexPrice) : 0,
      fundingIntervalHours: 8,
      info: fundingRate
    };
  }
  /**
   * Normalize order data
   */
  normalizeOrder(order) {
    const unifiedSymbol = this.symbolToCCXT(order.symbol);
    const filled = safeParseFloat(order.filledAmount || "0");
    const amount = safeParseFloat(order.amount);
    const remaining = safeParseFloat(order.remainingAmount || String(amount - filled));
    return {
      id: order.orderId,
      clientOrderId: order.clientOrderId,
      symbol: unifiedSymbol,
      type: order.type === "rfq" ? "market" : order.type,
      side: order.side,
      price: order.price ? safeParseFloat(order.price) : void 0,
      amount,
      filled,
      remaining,
      reduceOnly: false,
      postOnly: false,
      status: this.normalizeOrderStatus(order.status),
      timestamp: order.timestamp,
      lastUpdateTimestamp: order.updateTime,
      info: order
    };
  }
  /**
   * Normalize order status
   */
  normalizeOrderStatus(status) {
    switch (status) {
      case "pending":
      case "open":
        return "open";
      case "filled":
        return "closed";
      case "cancelled":
        return "canceled";
      case "expired":
        return "expired";
      case "rejected":
        return "rejected";
      case "partially_filled":
        return "open";
      default:
        return "open";
    }
  }
  /**
   * Normalize position data
   */
  normalizePosition(position) {
    const unifiedSymbol = this.symbolToCCXT(position.symbol);
    const size = safeParseFloat(position.size);
    const entryPrice = safeParseFloat(position.entryPrice);
    return {
      symbol: unifiedSymbol,
      side: position.side,
      size,
      entryPrice,
      markPrice: safeParseFloat(position.markPrice),
      leverage: safeParseFloat(position.leverage),
      liquidationPrice: position.liquidationPrice ? safeParseFloat(position.liquidationPrice) : 0,
      unrealizedPnl: safeParseFloat(position.unrealizedPnl),
      realizedPnl: 0,
      margin: safeParseFloat(position.margin),
      maintenanceMargin: 0,
      marginRatio: 0,
      marginMode: "cross",
      timestamp: position.timestamp,
      info: position
    };
  }
  /**
   * Normalize balance data
   */
  normalizeBalance(balance) {
    return {
      currency: balance.asset,
      free: safeParseFloat(balance.free),
      used: safeParseFloat(balance.locked),
      total: safeParseFloat(balance.total)
    };
  }
  /**
   * Normalize RFQ quote data (Variational-specific)
   * This is not part of the standard unified format, but useful for RFQ trading
   */
  normalizeQuote(quote) {
    const unifiedSymbol = this.symbolToCCXT(quote.symbol);
    return {
      id: quote.quoteId,
      symbol: unifiedSymbol,
      side: quote.side,
      price: safeParseFloat(quote.price),
      amount: safeParseFloat(quote.amount),
      expiresAt: quote.expiresAt,
      marketMaker: quote.marketMaker,
      spread: quote.spread ? safeParseFloat(quote.spread) : void 0,
      timestamp: quote.timestamp
    };
  }
  /**
   * Batch normalize markets
   */
  normalizeMarkets(markets) {
    return markets.map((market) => this.normalizeMarket(market));
  }
  /**
   * Batch normalize orders
   */
  normalizeOrders(orders) {
    return orders.map((order) => this.normalizeOrder(order));
  }
  /**
   * Batch normalize positions
   */
  normalizePositions(positions) {
    return positions.map((position) => this.normalizePosition(position));
  }
  /**
   * Batch normalize balances
   */
  normalizeBalances(balances) {
    return balances.map((balance) => this.normalizeBalance(balance));
  }
  /**
   * Batch normalize trades
   */
  normalizeTrades(trades) {
    return trades.map((trade) => this.normalizeTrade(trade));
  }
  /**
   * Batch normalize markets from listings (metadata/stats response)
   */
  normalizeMarketsFromListings(listings) {
    return listings.map((listing) => this.normalizeMarketFromListing(listing));
  }
  /**
   * Batch normalize tickers from listings (metadata/stats response)
   */
  normalizeTickersFromListings(listings) {
    return listings.map((listing) => this.normalizeTickerFromListing(listing));
  }
  /**
   * Normalize funding rate from listing (from /metadata/stats)
   */
  normalizeFundingRateFromListing(listing) {
    const unifiedSymbol = `${listing.ticker}/USDC:USDC`;
    const markPrice = safeParseFloat(listing.mark_price);
    const fundingIntervalSeconds = listing.funding_interval_s;
    const fundingIntervalHours = fundingIntervalSeconds / 3600;
    const now = Date.now();
    const intervalMs = fundingIntervalSeconds * 1e3;
    const nextFundingTimestamp = Math.ceil(now / intervalMs) * intervalMs;
    return {
      symbol: unifiedSymbol,
      fundingRate: safeParseFloat(listing.funding_rate),
      fundingTimestamp: now,
      nextFundingTimestamp,
      markPrice,
      indexPrice: markPrice,
      // Variational uses mark price as index
      fundingIntervalHours,
      info: listing
    };
  }
  /**
   * Normalize order book from listing quotes (from /metadata/stats)
   *
   * Since Variational is an RFQ-based DEX, we construct an order book
   * from the quotes at different notional sizes.
   */
  normalizeOrderBookFromListing(listing) {
    const unifiedSymbol = `${listing.ticker}/USDC:USDC`;
    const quotes = listing.quotes;
    const markPrice = safeParseFloat(listing.mark_price);
    const bids = [];
    const asks = [];
    const bid1k = safeParseFloat(quotes.size_1k.bid);
    const ask1k = safeParseFloat(quotes.size_1k.ask);
    const size1k = 1e3 / markPrice;
    if (bid1k > 0) bids.push([bid1k, size1k]);
    if (ask1k > 0) asks.push([ask1k, size1k]);
    const bid100k = safeParseFloat(quotes.size_100k.bid);
    const ask100k = safeParseFloat(quotes.size_100k.ask);
    const size100k = 1e5 / markPrice;
    if (bid100k > 0) bids.push([bid100k, size100k]);
    if (ask100k > 0) asks.push([ask100k, size100k]);
    if (quotes.size_1m) {
      const bid1m = safeParseFloat(quotes.size_1m.bid);
      const ask1m = safeParseFloat(quotes.size_1m.ask);
      const size1m = 1e6 / markPrice;
      if (bid1m > 0) bids.push([bid1m, size1m]);
      if (ask1m > 0) asks.push([ask1m, size1m]);
    }
    bids.sort((a, b) => b[0] - a[0]);
    asks.sort((a, b) => a[0] - b[0]);
    return {
      exchange: "variational",
      symbol: unifiedSymbol,
      bids,
      asks,
      timestamp: new Date(quotes.updated_at).getTime() || Date.now()
    };
  }
};

// src/adapters/variational/VariationalAdapter.ts
var VariationalAdapter = class extends BaseAdapter {
  id = "variational";
  name = "Variational";
  has = {
    // Public API (Available)
    fetchMarkets: true,
    fetchTicker: true,
    fetchOrderBook: true,
    // RFQ-based order book from quotes
    fetchFundingRate: true,
    // From metadata/stats
    // Public API (Not yet implemented/documented)
    fetchTrades: false,
    // No trades endpoint for RFQ DEX
    fetchFundingRateHistory: false,
    // Trading API (Implemented - requires API endpoint availability)
    createOrder: true,
    cancelOrder: true,
    cancelAllOrders: true,
    createBatchOrders: false,
    // Not supported natively
    cancelBatchOrders: false,
    // Not supported natively
    editOrder: false,
    // Not supported
    // Account API (Implemented)
    fetchPositions: true,
    fetchBalance: true,
    fetchOrderHistory: true,
    fetchMyTrades: true,
    fetchOpenOrders: false,
    // Not yet implemented
    fetchUserFees: false,
    fetchPortfolio: false,
    setLeverage: false,
    // Not supported
    setMarginMode: false,
    // Not supported
    fetchDeposits: false,
    // Not supported
    fetchWithdrawals: false,
    // Not supported
    // WebSocket (Not yet available)
    watchOrderBook: false,
    watchTrades: false,
    watchTicker: false,
    watchPositions: false,
    watchOrders: false,
    watchBalance: false
  };
  apiUrl;
  apiKey;
  apiSecret;
  rateLimiter;
  httpClient;
  normalizer;
  wsManager = null;
  constructor(config = {}) {
    super(config);
    const testnet = config.testnet ?? false;
    const urls = testnet ? VARIATIONAL_API_URLS.testnet : VARIATIONAL_API_URLS.mainnet;
    this.apiUrl = urls.rest;
    this.apiKey = config.apiKey;
    this.apiSecret = config.apiSecret;
    this.normalizer = new VariationalNormalizer();
    const tier = config.rateLimitTier ?? VARIATIONAL_DEFAULTS.rateLimitTier;
    const limits = VARIATIONAL_RATE_LIMITS[tier];
    this.rateLimiter = new RateLimiter({
      maxTokens: limits.maxRequests,
      refillRate: limits.maxRequests / (limits.windowMs / 1e3),
      windowMs: limits.windowMs,
      weights: VARIATIONAL_ENDPOINT_WEIGHTS
    });
    this.httpClient = new HTTPClient({
      baseUrl: this.apiUrl,
      timeout: config.timeout || VARIATIONAL_DEFAULTS.timeout,
      retry: {
        maxAttempts: 3,
        initialDelay: 1e3,
        maxDelay: 1e4,
        multiplier: 2,
        retryableStatuses: [408, 429, 500, 502, 503, 504]
      },
      circuitBreaker: {
        enabled: true,
        failureThreshold: 5,
        successThreshold: 2,
        resetTimeout: 6e4
      },
      exchange: this.id
    });
  }
  async initialize() {
    this._isReady = true;
    this._isDisconnected = false;
    this.info("Variational adapter initialized");
  }
  async disconnect() {
    if (this.wsManager) {
      await this.wsManager.disconnect();
      this.wsManager = null;
    }
    this._isReady = false;
    this._isDisconnected = true;
    this.info("Variational adapter disconnected");
  }
  // ==================== Symbol Conversion Methods ====================
  /**
   * Convert unified symbol to Variational format
   */
  symbolToExchange(symbol) {
    return this.normalizer.symbolFromCCXT(symbol);
  }
  /**
   * Convert Variational symbol to unified format
   */
  symbolFromExchange(exchangeSymbol) {
    return this.normalizer.symbolToCCXT(exchangeSymbol);
  }
  // ==================== Market Data Methods ====================
  async fetchMarkets(_params) {
    await this.rateLimiter.acquire(VARIATIONAL_ENDPOINTS.METADATA_STATS);
    try {
      const response = await this.httpClient.get(
        VARIATIONAL_ENDPOINTS.METADATA_STATS,
        {}
      );
      const listings = response.listings || [];
      return this.normalizer.normalizeMarketsFromListings(listings);
    } catch (error) {
      throw mapError3(error);
    }
  }
  async fetchTicker(symbol) {
    await this.rateLimiter.acquire(VARIATIONAL_ENDPOINTS.METADATA_STATS);
    if (!symbol) {
      throw new PerpDEXError("Symbol is required", "INVALID_SYMBOL", this.id);
    }
    try {
      const ticker = symbol.split("/")[0];
      const response = await this.httpClient.get(
        VARIATIONAL_ENDPOINTS.METADATA_STATS,
        {}
      );
      const listings = response.listings || [];
      const listing = listings.find((l) => l.ticker === ticker);
      if (!listing) {
        throw new PerpDEXError(`Market not found: ${symbol}`, "NOT_FOUND", this.id);
      }
      return this.normalizer.normalizeTickerFromListing(listing);
    } catch (error) {
      throw mapError3(error);
    }
  }
  async fetchOrderBook(symbol, _params) {
    await this.rateLimiter.acquire(VARIATIONAL_ENDPOINTS.METADATA_STATS);
    if (!symbol) {
      throw new PerpDEXError("Symbol is required", "INVALID_SYMBOL", this.id);
    }
    try {
      const ticker = symbol.split("/")[0];
      const response = await this.httpClient.get(
        VARIATIONAL_ENDPOINTS.METADATA_STATS,
        {}
      );
      const listings = response.listings || [];
      const listing = listings.find((l) => l.ticker === ticker);
      if (!listing) {
        throw new PerpDEXError(`Market not found: ${symbol}`, "NOT_FOUND", this.id);
      }
      return this.normalizer.normalizeOrderBookFromListing(listing);
    } catch (error) {
      throw mapError3(error);
    }
  }
  async fetchTrades(_symbol, _params) {
    await this.rateLimiter.acquire(VARIATIONAL_ENDPOINTS.TRADES);
    throw new PerpDEXError("fetchTrades not implemented", "NOT_IMPLEMENTED", this.id);
  }
  async fetchFundingRate(symbol) {
    await this.rateLimiter.acquire(VARIATIONAL_ENDPOINTS.METADATA_STATS);
    if (!symbol) {
      throw new PerpDEXError("Symbol is required", "INVALID_SYMBOL", this.id);
    }
    try {
      const ticker = symbol.split("/")[0];
      const response = await this.httpClient.get(
        VARIATIONAL_ENDPOINTS.METADATA_STATS,
        {}
      );
      const listings = response.listings || [];
      const listing = listings.find((l) => l.ticker === ticker);
      if (!listing) {
        throw new PerpDEXError(`Market not found: ${symbol}`, "NOT_FOUND", this.id);
      }
      return this.normalizer.normalizeFundingRateFromListing(listing);
    } catch (error) {
      throw mapError3(error);
    }
  }
  async fetchFundingRateHistory(_symbol, _since, _limit) {
    await this.rateLimiter.acquire(VARIATIONAL_ENDPOINTS.FUNDING_HISTORY);
    throw new PerpDEXError("fetchFundingRateHistory not implemented", "NOT_IMPLEMENTED", this.id);
  }
  // ==================== Trading Methods ====================
  async createOrder(request) {
    this.ensureAuthenticated();
    await this.rateLimiter.acquire(VARIATIONAL_ENDPOINTS.CREATE_ORDER);
    validateOrderRequest2(request);
    try {
      const orderRequest = convertOrderRequest3(request);
      orderRequest.clientOrderId = orderRequest.clientOrderId || generateClientOrderId();
      orderRequest.symbol = this.symbolToExchange(request.symbol);
      const response = await this.authenticatedRequest(
        "POST",
        VARIATIONAL_ENDPOINTS.CREATE_ORDER,
        orderRequest
      );
      return this.normalizer.normalizeOrder(response);
    } catch (error) {
      throw mapError3(error);
    }
  }
  async cancelOrder(orderId, _symbol) {
    this.ensureAuthenticated();
    await this.rateLimiter.acquire(VARIATIONAL_ENDPOINTS.CANCEL_ORDER);
    if (!orderId) {
      throw new PerpDEXError("Order ID is required", "INVALID_ORDER_ID", this.id);
    }
    try {
      const endpoint = VARIATIONAL_ENDPOINTS.CANCEL_ORDER.replace("{orderId}", orderId);
      const response = await this.authenticatedRequest(
        "DELETE",
        endpoint
      );
      return this.normalizer.normalizeOrder(response);
    } catch (error) {
      throw mapError3(error);
    }
  }
  async cancelAllOrders(symbol) {
    this.ensureAuthenticated();
    await this.rateLimiter.acquire(VARIATIONAL_ENDPOINTS.CANCEL_ALL_ORDERS);
    try {
      const body = symbol ? { symbol: this.symbolToExchange(symbol) } : void 0;
      const response = await this.authenticatedRequest(
        "DELETE",
        VARIATIONAL_ENDPOINTS.CANCEL_ALL_ORDERS,
        body
      );
      return this.normalizer.normalizeOrders(response.orders || []);
    } catch (error) {
      throw mapError3(error);
    }
  }
  async createBatchOrders(_requests) {
    throw new PerpDEXError("createBatchOrders not supported", "NOT_SUPPORTED", this.id);
  }
  async cancelBatchOrders(_orderIds, _symbol) {
    throw new PerpDEXError("cancelBatchOrders not supported", "NOT_SUPPORTED", this.id);
  }
  // ==================== Account Methods ====================
  async fetchPositions(symbols) {
    this.ensureAuthenticated();
    await this.rateLimiter.acquire(VARIATIONAL_ENDPOINTS.POSITIONS);
    try {
      const response = await this.authenticatedRequest(
        "GET",
        VARIATIONAL_ENDPOINTS.POSITIONS
      );
      let positions = this.normalizer.normalizePositions(response.positions || []);
      if (symbols && symbols.length > 0) {
        positions = positions.filter((p) => symbols.includes(p.symbol));
      }
      return positions;
    } catch (error) {
      throw mapError3(error);
    }
  }
  async fetchBalance() {
    this.ensureAuthenticated();
    await this.rateLimiter.acquire(VARIATIONAL_ENDPOINTS.BALANCE);
    try {
      const response = await this.authenticatedRequest(
        "GET",
        VARIATIONAL_ENDPOINTS.BALANCE
      );
      return this.normalizer.normalizeBalances(response.balances || []);
    } catch (error) {
      throw mapError3(error);
    }
  }
  async setLeverage(_symbol, _leverage) {
    throw new PerpDEXError("setLeverage not supported", "NOT_SUPPORTED", this.id);
  }
  async setMarginMode(_symbol, _marginMode) {
    throw new PerpDEXError("setMarginMode not supported", "NOT_SUPPORTED", this.id);
  }
  async fetchOrderHistory(symbol, since, limit) {
    this.ensureAuthenticated();
    await this.rateLimiter.acquire(VARIATIONAL_ENDPOINTS.ORDER_HISTORY);
    try {
      const params = {};
      if (symbol) {
        params.symbol = this.symbolToExchange(symbol);
      }
      if (since) {
        params.since = since.toString();
      }
      if (limit) {
        params.limit = limit.toString();
      }
      const queryString = Object.entries(params).map(([key, value]) => `${key}=${encodeURIComponent(value)}`).join("&");
      const endpoint = queryString ? `${VARIATIONAL_ENDPOINTS.ORDER_HISTORY}?${queryString}` : VARIATIONAL_ENDPOINTS.ORDER_HISTORY;
      const response = await this.authenticatedRequest(
        "GET",
        endpoint
      );
      return this.normalizer.normalizeOrders(response.orders || []);
    } catch (error) {
      throw mapError3(error);
    }
  }
  async fetchMyTrades(symbol, since, limit) {
    this.ensureAuthenticated();
    await this.rateLimiter.acquire(VARIATIONAL_ENDPOINTS.USER_TRADES);
    try {
      const params = {};
      if (symbol) {
        params.symbol = this.symbolToExchange(symbol);
      }
      if (since) {
        params.since = since.toString();
      }
      if (limit) {
        params.limit = limit.toString();
      }
      const queryString = Object.entries(params).map(([key, value]) => `${key}=${encodeURIComponent(value)}`).join("&");
      const endpoint = queryString ? `${VARIATIONAL_ENDPOINTS.USER_TRADES}?${queryString}` : VARIATIONAL_ENDPOINTS.USER_TRADES;
      const response = await this.authenticatedRequest(
        "GET",
        endpoint
      );
      return this.normalizer.normalizeTrades(response.trades || []);
    } catch (error) {
      throw mapError3(error);
    }
  }
  async fetchDeposits(_currency, _since, _limit) {
    throw new PerpDEXError("fetchDeposits not supported", "NOT_SUPPORTED", this.id);
  }
  async fetchWithdrawals(_currency, _since, _limit) {
    throw new PerpDEXError("fetchWithdrawals not supported", "NOT_SUPPORTED", this.id);
  }
  async fetchUserFees() {
    await this.rateLimiter.acquire(VARIATIONAL_ENDPOINTS.USER_FEES);
    throw new PerpDEXError("fetchUserFees not implemented", "NOT_IMPLEMENTED", this.id);
  }
  async fetchPortfolio() {
    await this.rateLimiter.acquire(VARIATIONAL_ENDPOINTS.PORTFOLIO);
    throw new PerpDEXError("fetchPortfolio not implemented", "NOT_IMPLEMENTED", this.id);
  }
  async fetchRateLimitStatus() {
    throw new PerpDEXError("fetchRateLimitStatus not implemented", "NOT_IMPLEMENTED", this.id);
  }
  // ==================== WebSocket Methods ====================
  async *watchOrderBook(_symbol, _limit) {
    throw new PerpDEXError("watchOrderBook not implemented", "NOT_IMPLEMENTED", this.id);
  }
  async *watchTrades(_symbol) {
    throw new PerpDEXError("watchTrades not implemented", "NOT_IMPLEMENTED", this.id);
  }
  async *watchTicker(_symbol) {
    throw new PerpDEXError("watchTicker not implemented", "NOT_IMPLEMENTED", this.id);
  }
  async *watchPositions() {
    throw new PerpDEXError("watchPositions not implemented", "NOT_IMPLEMENTED", this.id);
  }
  async *watchOrders() {
    throw new PerpDEXError("watchOrders not implemented", "NOT_IMPLEMENTED", this.id);
  }
  async *watchBalance() {
    throw new PerpDEXError("watchBalance not implemented", "NOT_IMPLEMENTED", this.id);
  }
  async *watchFundingRate(_symbol) {
    throw new PerpDEXError("watchFundingRate not implemented", "NOT_IMPLEMENTED", this.id);
  }
  // ==================== RFQ-Specific Methods ====================
  /**
   * Request quotes from market makers (RFQ-specific)
   *
   * This method requests quotes from Variational's market makers for a specific
   * trade size. The quotes will expire after a short period (typically 10 seconds).
   *
   * @param symbol - Trading pair in unified format (e.g., "BTC/USDC:USDC")
   * @param side - Trade direction ('buy' or 'sell')
   * @param amount - Trade size in base currency
   * @returns Array of quotes from market makers
   */
  async requestQuote(symbol, side, amount) {
    this.ensureAuthenticated();
    await this.rateLimiter.acquire(VARIATIONAL_ENDPOINTS.REQUEST_QUOTE);
    if (!symbol) {
      throw new PerpDEXError("Symbol is required", "INVALID_SYMBOL", this.id);
    }
    if (!["buy", "sell"].includes(side)) {
      throw new PerpDEXError("Invalid order side", "INVALID_ORDER_SIDE", this.id);
    }
    if (!amount || amount <= 0) {
      throw new PerpDEXError("Amount must be greater than 0", "INVALID_AMOUNT", this.id);
    }
    try {
      const request = {
        symbol: this.symbolToExchange(symbol),
        side,
        amount: amount.toString()
      };
      const response = await this.authenticatedRequest(
        "POST",
        VARIATIONAL_ENDPOINTS.REQUEST_QUOTE,
        request
      );
      return response.quotes || [];
    } catch (error) {
      throw mapError3(error);
    }
  }
  /**
   * Accept a quote and execute trade (RFQ-specific)
   *
   * After receiving quotes from requestQuote(), use this method to accept
   * a specific quote and execute the trade. The quote must not be expired.
   *
   * @param quoteId - The ID of the quote to accept
   * @returns The resulting order from accepting the quote
   */
  async acceptQuote(quoteId) {
    this.ensureAuthenticated();
    await this.rateLimiter.acquire(VARIATIONAL_ENDPOINTS.ACCEPT_QUOTE);
    if (!quoteId) {
      throw new PerpDEXError("Quote ID is required", "INVALID_QUOTE_ID", this.id);
    }
    try {
      const endpoint = VARIATIONAL_ENDPOINTS.ACCEPT_QUOTE.replace("{quoteId}", quoteId);
      const response = await this.authenticatedRequest(
        "POST",
        endpoint
      );
      return this.normalizer.normalizeOrder(response);
    } catch (error) {
      throw mapError3(error);
    }
  }
  // ==================== Private Helper Methods ====================
  /**
   * Ensure API credentials are configured
   */
  ensureAuthenticated() {
    if (!this.apiKey || !this.apiSecret) {
      throw new PerpDEXError(
        "API credentials required for this operation",
        "AUTHENTICATION_REQUIRED",
        this.id
      );
    }
  }
  /**
   * Generate HMAC-SHA256 signature for authenticated requests
   * Note: This is now async to support browser Web Crypto API
   */
  async generateSignature(method, path, timestamp, body) {
    if (!this.apiSecret) {
      throw new PerpDEXError("API secret required for authentication", "MISSING_API_SECRET", this.id);
    }
    const message = `${timestamp}${method}${path}${body ? JSON.stringify(body) : ""}`;
    return createHmacSha256(this.apiSecret, message);
  }
  /**
   * Make an authenticated request to the Variational API
   *
   * All authenticated requests include:
   * - X-API-Key: The API key
   * - X-Timestamp: Unix timestamp in milliseconds
   * - X-Signature: HMAC-SHA256 signature
   */
  async authenticatedRequest(method, path, body) {
    const timestamp = Date.now().toString();
    const signature = await this.generateSignature(method, path, timestamp, body);
    const headers = {
      "X-API-Key": this.apiKey,
      "X-Timestamp": timestamp,
      "X-Signature": signature
    };
    const options = {
      headers,
      body
    };
    try {
      let response;
      switch (method) {
        case "GET":
          response = await this.httpClient.get(path, { headers });
          break;
        case "POST":
          response = await this.httpClient.post(path, options);
          break;
        case "DELETE":
          response = await this.httpClient.delete(path, options);
          break;
        case "PUT":
          response = await this.httpClient.put(path, options);
          break;
        default:
          throw new PerpDEXError(`Unsupported HTTP method: ${method}`, "INVALID_REQUEST", this.id);
      }
      return response;
    } catch (error) {
      throw mapError3(error);
    }
  }
};

// src/adapters/extended/constants.ts
var EXTENDED_API_URLS = {
  mainnet: {
    rest: "https://api.starknet.extended.exchange",
    websocket: "wss://ws.starknet.extended.exchange",
    starknet: "https://starknet-mainnet.public.blastapi.io"
  },
  testnet: {
    rest: "https://api.starknet.sepolia.extended.exchange",
    websocket: "wss://ws.starknet.sepolia.extended.exchange",
    starknet: "https://starknet-sepolia.public.blastapi.io"
  }
};
var EXTENDED_ENDPOINTS = {
  // Market Data (Public)
  MARKETS: "/api/v1/info/markets",
  TICKER: "/api/v1/info/markets",
  TICKER_SYMBOL: "/api/v1/info/markets/{market}/stats",
  ORDERBOOK: "/api/v1/info/markets/{market}/orderbook",
  TRADES: "/api/v1/info/markets/{market}/trades",
  FUNDING_RATE: "/api/v1/info/{market}/funding",
  FUNDING_HISTORY: "/api/v1/info/{market}/funding/history",
  // Trading (Private)
  CREATE_ORDER: "/api/v1/user/order",
  CANCEL_ORDER: "/api/v1/user/order/{orderId}",
  CANCEL_ALL_ORDERS: "/api/v1/user/orders/cancel-all",
  EDIT_ORDER: "/api/v1/user/order/{orderId}",
  BATCH_ORDERS: "/api/v1/user/orders/batch",
  OPEN_ORDERS: "/api/v1/user/orders",
  ORDER_HISTORY: "/api/v1/user/orders/history",
  ORDER_STATUS: "/api/v1/user/order/{orderId}",
  // Positions & Account
  POSITIONS: "/api/v1/user/positions",
  BALANCE: "/api/v1/user/balance",
  LEVERAGE: "/api/v1/user/leverage",
  MARGIN_MODE: "/api/v1/user/margin-mode",
  USER_TRADES: "/api/v1/user/trades",
  USER_FEES: "/api/v1/user/fees",
  PORTFOLIO: "/api/v1/user/portfolio",
  // StarkNet specific
  STARKNET_STATE: "/api/v1/starknet/state",
  STARKNET_TX: "/api/v1/starknet/transaction/{txHash}",
  STARKNET_ACCOUNT: "/api/v1/starknet/account/{address}",
  // Rate Limit Status
  RATE_LIMIT_STATUS: "/api/v1/rate-limit"
};
var EXTENDED_RATE_LIMITS = {
  default: {
    maxRequests: 1e3,
    windowMs: 6e4
    // 1 minute (1000 req/min per API docs)
  },
  authenticated: {
    maxRequests: 1e3,
    windowMs: 6e4
    // 1 minute
  },
  vip: {
    maxRequests: 12e3,
    windowMs: 3e5
    // 5 minutes (60000/5min for market makers)
  }
};
var EXTENDED_ENDPOINT_WEIGHTS = {
  [EXTENDED_ENDPOINTS.MARKETS]: 1,
  [EXTENDED_ENDPOINTS.TICKER_SYMBOL]: 1,
  [EXTENDED_ENDPOINTS.ORDERBOOK]: 2,
  [EXTENDED_ENDPOINTS.TRADES]: 1,
  [EXTENDED_ENDPOINTS.FUNDING_RATE]: 1,
  [EXTENDED_ENDPOINTS.CREATE_ORDER]: 10,
  // CANCEL_ORDER and EDIT_ORDER share the same endpoint path, use higher weight
  [EXTENDED_ENDPOINTS.CANCEL_ORDER]: 10,
  [EXTENDED_ENDPOINTS.CANCEL_ALL_ORDERS]: 10,
  [EXTENDED_ENDPOINTS.BATCH_ORDERS]: 20,
  [EXTENDED_ENDPOINTS.POSITIONS]: 2,
  [EXTENDED_ENDPOINTS.BALANCE]: 2,
  [EXTENDED_ENDPOINTS.LEVERAGE]: 5
};
var EXTENDED_WS_CONFIG = {
  reconnectDelay: 1e3,
  maxReconnectDelay: 6e4,
  reconnectAttempts: 10,
  pingInterval: 3e4,
  pongTimeout: 1e4
};
var EXTENDED_WS_CHANNELS = {
  ORDERBOOK: "orderbook",
  TRADES: "trades",
  TICKER: "ticker",
  ORDERS: "orders",
  POSITIONS: "positions",
  BALANCE: "balance",
  FUNDING: "funding"
};
var EXTENDED_LEVERAGE_TIERS = {
  MIN: 1,
  MAX: 100,
  DEFAULT: 10
};
var EXTENDED_DEFAULTS = {
  timeout: 3e4,
  // 30 seconds
  orderBookDepth: 50,
  tradesLimit: 100,
  orderHistoryLimit: 500,
  defaultLeverage: 10,
  maxLeverage: 100
};
var EXTENDED_STARKNET_CONFIG = {
  chainId: {
    mainnet: "SN_MAIN",
    testnet: "SN_GOERLI"
  },
  blockTime: 6e5,
  // 10 minutes in milliseconds
  confirmations: 1
};

// src/adapters/extended/error-codes.ts
var EXTENDED_CLIENT_ERRORS = {
  INSUFFICIENT_MARGIN: "INSUFFICIENT_MARGIN",
  INSUFFICIENT_BALANCE: "INSUFFICIENT_BALANCE",
  INVALID_API_KEY: "INVALID_API_KEY",
  INVALID_ORDER: "INVALID_ORDER",
  INVALID_SYMBOL: "INVALID_SYMBOL",
  INVALID_QUANTITY: "INVALID_QUANTITY",
  INVALID_PRICE: "INVALID_PRICE",
  INVALID_LEVERAGE: "INVALID_LEVERAGE",
  ORDER_NOT_FOUND: "ORDER_NOT_FOUND",
  POSITION_NOT_FOUND: "POSITION_NOT_FOUND",
  LEVERAGE_TOO_HIGH: "LEVERAGE_TOO_HIGH",
  UNAUTHORIZED: "UNAUTHORIZED",
  FORBIDDEN: "FORBIDDEN",
  MARKET_CLOSED: "MARKET_CLOSED",
  LIQUIDATION_RISK: "LIQUIDATION_RISK"
};
var EXTENDED_SERVER_ERRORS = {
  INTERNAL_ERROR: "INTERNAL_ERROR",
  SERVICE_UNAVAILABLE: "SERVICE_UNAVAILABLE",
  TIMEOUT: "TIMEOUT",
  MATCHING_ENGINE_ERROR: "MATCHING_ENGINE_ERROR",
  STARKNET_ERROR: "STARKNET_ERROR",
  DATABASE_ERROR: "DATABASE_ERROR"
};
var EXTENDED_RATE_LIMIT_ERROR = "RATE_LIMIT_EXCEEDED";
var EXTENDED_STARKNET_ERRORS = {
  TRANSACTION_FAILED: "STARKNET_TRANSACTION_FAILED",
  INVALID_SIGNATURE: "STARKNET_INVALID_SIGNATURE",
  INSUFFICIENT_FUNDS: "STARKNET_INSUFFICIENT_FUNDS",
  CONTRACT_ERROR: "STARKNET_CONTRACT_ERROR",
  NONCE_MISMATCH: "STARKNET_NONCE_MISMATCH"
};
var EXTENDED_HTTP_ERROR_CODES = {
  400: EXTENDED_CLIENT_ERRORS.INVALID_ORDER,
  401: EXTENDED_CLIENT_ERRORS.UNAUTHORIZED,
  403: EXTENDED_CLIENT_ERRORS.FORBIDDEN,
  404: EXTENDED_CLIENT_ERRORS.ORDER_NOT_FOUND,
  429: EXTENDED_RATE_LIMIT_ERROR,
  500: EXTENDED_SERVER_ERRORS.INTERNAL_ERROR,
  502: EXTENDED_SERVER_ERRORS.SERVICE_UNAVAILABLE,
  503: EXTENDED_SERVER_ERRORS.SERVICE_UNAVAILABLE,
  504: EXTENDED_SERVER_ERRORS.TIMEOUT
};
var EXTENDED_ERROR_MESSAGES = {
  "insufficient margin": EXTENDED_CLIENT_ERRORS.INSUFFICIENT_MARGIN,
  "insufficient balance": EXTENDED_CLIENT_ERRORS.INSUFFICIENT_BALANCE,
  "invalid api key": EXTENDED_CLIENT_ERRORS.INVALID_API_KEY,
  "api key invalid": EXTENDED_CLIENT_ERRORS.INVALID_API_KEY,
  "invalid order": EXTENDED_CLIENT_ERRORS.INVALID_ORDER,
  "invalid symbol": EXTENDED_CLIENT_ERRORS.INVALID_SYMBOL,
  "invalid quantity": EXTENDED_CLIENT_ERRORS.INVALID_QUANTITY,
  "invalid price": EXTENDED_CLIENT_ERRORS.INVALID_PRICE,
  "invalid leverage": EXTENDED_CLIENT_ERRORS.INVALID_LEVERAGE,
  "leverage too high": EXTENDED_CLIENT_ERRORS.LEVERAGE_TOO_HIGH,
  "order not found": EXTENDED_CLIENT_ERRORS.ORDER_NOT_FOUND,
  "position not found": EXTENDED_CLIENT_ERRORS.POSITION_NOT_FOUND,
  "market closed": EXTENDED_CLIENT_ERRORS.MARKET_CLOSED,
  "liquidation risk": EXTENDED_CLIENT_ERRORS.LIQUIDATION_RISK,
  "rate limit exceeded": EXTENDED_RATE_LIMIT_ERROR,
  "too many requests": EXTENDED_RATE_LIMIT_ERROR,
  "internal server error": EXTENDED_SERVER_ERRORS.INTERNAL_ERROR,
  "service unavailable": EXTENDED_SERVER_ERRORS.SERVICE_UNAVAILABLE,
  "timeout": EXTENDED_SERVER_ERRORS.TIMEOUT,
  "matching engine error": EXTENDED_SERVER_ERRORS.MATCHING_ENGINE_ERROR,
  "starknet error": EXTENDED_SERVER_ERRORS.STARKNET_ERROR,
  "transaction failed": EXTENDED_STARKNET_ERRORS.TRANSACTION_FAILED,
  "starknet transaction failed": EXTENDED_STARKNET_ERRORS.TRANSACTION_FAILED,
  "contract error": EXTENDED_STARKNET_ERRORS.CONTRACT_ERROR,
  "nonce mismatch": EXTENDED_STARKNET_ERRORS.NONCE_MISMATCH
};
function extractErrorCode(message) {
  const lowerMessage = message.toLowerCase();
  for (const [keyword, code] of Object.entries(EXTENDED_ERROR_MESSAGES)) {
    if (lowerMessage.includes(keyword)) {
      return code;
    }
  }
  return "UNKNOWN_ERROR";
}
function extractErrorCodeFromStatus2(status) {
  return EXTENDED_HTTP_ERROR_CODES[status] || "UNKNOWN_ERROR";
}
function mapExtendedError(code, message, context) {
  const errorCode = typeof code === "number" ? extractErrorCodeFromStatus2(code) : code;
  switch (errorCode) {
    case EXTENDED_CLIENT_ERRORS.INSUFFICIENT_MARGIN:
    case EXTENDED_CLIENT_ERRORS.INSUFFICIENT_BALANCE:
    case EXTENDED_CLIENT_ERRORS.LIQUIDATION_RISK:
      return new InsufficientMarginError(message, errorCode, "extended", context);
    case EXTENDED_CLIENT_ERRORS.INVALID_API_KEY:
    case EXTENDED_CLIENT_ERRORS.UNAUTHORIZED:
    case EXTENDED_STARKNET_ERRORS.INVALID_SIGNATURE:
      return new InvalidSignatureError(message, errorCode, "extended", context);
    case EXTENDED_CLIENT_ERRORS.INVALID_ORDER:
    case EXTENDED_CLIENT_ERRORS.INVALID_SYMBOL:
    case EXTENDED_CLIENT_ERRORS.INVALID_QUANTITY:
    case EXTENDED_CLIENT_ERRORS.INVALID_PRICE:
    case EXTENDED_CLIENT_ERRORS.INVALID_LEVERAGE:
    case EXTENDED_CLIENT_ERRORS.LEVERAGE_TOO_HIGH:
    case EXTENDED_CLIENT_ERRORS.MARKET_CLOSED:
      return new InvalidOrderError(message, errorCode, "extended", context);
    case EXTENDED_CLIENT_ERRORS.ORDER_NOT_FOUND:
    case EXTENDED_CLIENT_ERRORS.POSITION_NOT_FOUND:
      return new OrderNotFoundError(message, errorCode, "extended", context);
    case EXTENDED_RATE_LIMIT_ERROR:
      return new RateLimitError(message, errorCode, "extended", void 0, context);
    case EXTENDED_SERVER_ERRORS.SERVICE_UNAVAILABLE:
    case EXTENDED_SERVER_ERRORS.TIMEOUT:
      return new ExchangeUnavailableError(message, errorCode, "extended", context);
    case EXTENDED_SERVER_ERRORS.INTERNAL_ERROR:
    case EXTENDED_SERVER_ERRORS.MATCHING_ENGINE_ERROR:
    case EXTENDED_SERVER_ERRORS.DATABASE_ERROR:
    case EXTENDED_SERVER_ERRORS.STARKNET_ERROR:
    case EXTENDED_STARKNET_ERRORS.TRANSACTION_FAILED:
    case EXTENDED_STARKNET_ERRORS.CONTRACT_ERROR:
      return new NetworkError(message, errorCode, "extended", context);
    default:
      return new PerpDEXError(message, errorCode, "extended", context);
  }
}
function mapHTTPError(status, body) {
  const message = body?.message || body?.error || `HTTP ${status}`;
  let errorCode = body?.code;
  if (!errorCode) {
    errorCode = extractErrorCode(message);
  }
  if (errorCode === "UNKNOWN_ERROR") {
    errorCode = extractErrorCodeFromStatus2(status);
  }
  return mapExtendedError(errorCode, message, {
    httpStatus: status,
    responseBody: body
  });
}
function mapStarkNetError(error) {
  const message = error?.message || String(error);
  const code = extractErrorCode(message);
  return mapExtendedError(code, message, {
    starknetError: error,
    isStarkNetError: true
  });
}

// src/adapters/extended/utils.ts
function convertOrderRequest4(request) {
  return {
    symbol: request.symbol,
    type: request.type,
    side: request.side,
    quantity: request.amount.toString(),
    price: request.price?.toString(),
    stopPrice: request.stopPrice?.toString(),
    clientOrderId: request.clientOrderId,
    postOnly: request.postOnly,
    reduceOnly: request.reduceOnly,
    timeInForce: request.timeInForce
  };
}
function mapError4(error) {
  if (error instanceof PerpDEXError) {
    return error;
  }
  if (error?.response?.status) {
    const status = error.response.status;
    const body = error.response.data;
    return mapHTTPError(status, body);
  }
  if (error?.code && typeof error.code === "string" && error.code.startsWith("E")) {
    const originalMessage = error.message || "Network error";
    const message2 = originalMessage.toLowerCase().includes("network") ? originalMessage : `network error: ${originalMessage}`;
    return new NetworkError(message2, "NETWORK_ERROR", "extended", { originalError: error });
  }
  const message = error?.message || error?.error || String(error);
  const code = extractErrorCode(message);
  const context = {
    originalError: error
  };
  return mapExtendedError(code, message, context);
}
function validateOrderRequest3(request) {
  if (!request.symbol) {
    throw new PerpDEXError("Symbol is required", "INVALID_SYMBOL", "extended");
  }
  if (!request.type) {
    throw new PerpDEXError("Order type is required", "INVALID_ORDER_TYPE", "extended");
  }
  if (!request.side) {
    throw new PerpDEXError("Order side is required", "INVALID_ORDER_SIDE", "extended");
  }
  if (!request.amount || request.amount <= 0) {
    throw new PerpDEXError("Quantity must be greater than 0", "INVALID_QUANTITY", "extended");
  }
  if ((request.type === "limit" || request.type === "stopLimit") && (!request.price || request.price <= 0)) {
    throw new PerpDEXError("Price is required for limit orders", "INVALID_PRICE", "extended");
  }
  if ((request.type === "stopMarket" || request.type === "stopLimit") && (!request.stopPrice || request.stopPrice <= 0)) {
    throw new PerpDEXError("Stop price is required for stop orders", "INVALID_STOP_PRICE", "extended");
  }
}
function validateLeverage(leverage) {
  if (!Number.isInteger(leverage)) {
    throw new PerpDEXError("Leverage must be an integer", "INVALID_LEVERAGE", "extended");
  }
  if (leverage < EXTENDED_LEVERAGE_TIERS.MIN || leverage > EXTENDED_LEVERAGE_TIERS.MAX) {
    throw new PerpDEXError(
      `Leverage must be between ${EXTENDED_LEVERAGE_TIERS.MIN}x and ${EXTENDED_LEVERAGE_TIERS.MAX}x`,
      "INVALID_LEVERAGE",
      "extended"
    );
  }
}
function safeParseFloat2(value) {
  if (value === void 0 || value === null || value === "") {
    return 0;
  }
  const parsed = typeof value === "string" ? parseFloat(value) : value;
  return isNaN(parsed) ? 0 : parsed;
}
function formatStarkNetAddress(address) {
  const formatted = address.toLowerCase();
  return formatted.startsWith("0x") ? formatted : `0x${formatted}`;
}
function isValidStarkNetAddress(address) {
  const hexPattern = /^0x[0-9a-fA-F]{4,64}$/;
  return hexPattern.test(address);
}

// src/adapters/extended/ExtendedNormalizer.ts
var ExtendedNormalizer = class {
  /**
   * Convert Extended symbol to unified CCXT format
   * Handles multiple Extended formats:
   * "BTC-USD-PERP" â†’ "BTC/USD:USD"
   * "BTCUSD" â†’ "BTC/USD:USD"
   */
  symbolToCCXT(extendedSymbol) {
    if (extendedSymbol.includes("-")) {
      const parts = extendedSymbol.split("-");
      if (parts.length >= 2) {
        const [base, quote] = parts;
        return `${base}/${quote}:${quote}`;
      }
    }
    const match = extendedSymbol.match(/^([A-Z]+)(USD|USDT|USDC)$/);
    if (match) {
      const [, base, quote] = match;
      return `${base}/${quote}:${quote}`;
    }
    return extendedSymbol;
  }
  /**
   * Convert unified CCXT symbol to Extended format
   * "BTC/USD:USD" â†’ "BTC-USD-PERP"
   */
  symbolFromCCXT(ccxtSymbol) {
    const [pair] = ccxtSymbol.split(":");
    if (!pair) {
      return ccxtSymbol;
    }
    const [base, quote] = pair.split("/");
    if (!base || !quote) {
      return ccxtSymbol;
    }
    return `${base}-${quote}-PERP`;
  }
  /**
   * Normalize market data
   */
  normalizeMarket(market) {
    const unifiedSymbol = this.symbolToCCXT(market.symbol);
    return {
      id: market.marketId,
      symbol: unifiedSymbol,
      base: market.baseAsset,
      quote: market.quoteAsset,
      settle: market.settleAsset,
      contractSize: safeParseFloat2(market.contractMultiplier) || 1,
      active: market.isActive,
      minAmount: safeParseFloat2(market.minOrderQuantity),
      maxAmount: safeParseFloat2(market.maxOrderQuantity),
      pricePrecision: market.pricePrecision,
      amountPrecision: market.quantityPrecision,
      priceTickSize: safeParseFloat2(market.minPrice),
      amountStepSize: safeParseFloat2(market.minOrderQuantity),
      makerFee: 2e-4,
      takerFee: 5e-4,
      maxLeverage: market.maxLeverage ? safeParseFloat2(market.maxLeverage) : 1,
      fundingIntervalHours: 8,
      info: market
    };
  }
  /**
   * Normalize ticker data
   */
  normalizeTicker(ticker) {
    const unifiedSymbol = this.symbolToCCXT(ticker.symbol);
    return {
      symbol: unifiedSymbol,
      timestamp: ticker.timestamp,
      high: safeParseFloat2(ticker.high24h),
      low: safeParseFloat2(ticker.low24h),
      bid: safeParseFloat2(ticker.bidPrice),
      ask: safeParseFloat2(ticker.askPrice),
      last: safeParseFloat2(ticker.lastPrice),
      open: safeParseFloat2(ticker.lastPrice),
      close: safeParseFloat2(ticker.lastPrice),
      baseVolume: safeParseFloat2(ticker.volume24h),
      quoteVolume: safeParseFloat2(ticker.quoteVolume24h),
      change: safeParseFloat2(ticker.priceChange24h),
      percentage: safeParseFloat2(ticker.priceChangePercent24h),
      info: ticker
    };
  }
  /**
   * Normalize order book data
   */
  normalizeOrderBook(orderbook) {
    const unifiedSymbol = this.symbolToCCXT(orderbook.symbol);
    return {
      exchange: "extended",
      symbol: unifiedSymbol,
      bids: orderbook.bids.map(([price, amount]) => [
        safeParseFloat2(price),
        safeParseFloat2(amount)
      ]),
      asks: orderbook.asks.map(([price, amount]) => [
        safeParseFloat2(price),
        safeParseFloat2(amount)
      ]),
      timestamp: orderbook.timestamp
    };
  }
  /**
   * Normalize trade data
   */
  normalizeTrade(trade) {
    const unifiedSymbol = this.symbolToCCXT(trade.symbol);
    return {
      id: trade.id,
      orderId: void 0,
      symbol: unifiedSymbol,
      side: trade.side,
      price: safeParseFloat2(trade.price),
      amount: safeParseFloat2(trade.quantity),
      cost: safeParseFloat2(trade.price) * safeParseFloat2(trade.quantity),
      timestamp: trade.timestamp,
      info: trade
    };
  }
  /**
   * Normalize funding rate data
   */
  normalizeFundingRate(fundingRate) {
    const unifiedSymbol = this.symbolToCCXT(fundingRate.symbol);
    return {
      symbol: unifiedSymbol,
      fundingRate: safeParseFloat2(fundingRate.fundingRate),
      fundingTimestamp: fundingRate.fundingTime,
      nextFundingTimestamp: fundingRate.nextFundingTime || 0,
      markPrice: safeParseFloat2(fundingRate.markPrice),
      indexPrice: safeParseFloat2(fundingRate.indexPrice),
      fundingIntervalHours: 8,
      info: fundingRate
    };
  }
  /**
   * Normalize order data
   */
  normalizeOrder(order) {
    const unifiedSymbol = this.symbolToCCXT(order.symbol);
    const filled = safeParseFloat2(order.filledQuantity || "0");
    const amount = safeParseFloat2(order.quantity);
    const remaining = safeParseFloat2(order.remainingQuantity || String(amount - filled));
    return {
      id: order.orderId,
      clientOrderId: order.clientOrderId,
      symbol: unifiedSymbol,
      type: this.normalizeOrderType(order.type),
      side: order.side,
      price: order.price ? safeParseFloat2(order.price) : void 0,
      stopPrice: order.stopPrice ? safeParseFloat2(order.stopPrice) : void 0,
      amount,
      filled,
      remaining,
      reduceOnly: false,
      postOnly: false,
      status: this.normalizeOrderStatus(order.status),
      timestamp: order.timestamp,
      lastUpdateTimestamp: order.updateTime,
      info: order
    };
  }
  /**
   * Normalize order type
   */
  normalizeOrderType(type) {
    switch (type) {
      case "market":
        return "market";
      case "limit":
      case "stop":
      case "stop_limit":
        return "limit";
      default:
        return "limit";
    }
  }
  /**
   * Normalize order status
   */
  normalizeOrderStatus(status) {
    switch (status) {
      case "pending":
      case "open":
        return "open";
      case "filled":
        return "closed";
      case "cancelled":
        return "canceled";
      case "expired":
        return "expired";
      case "rejected":
        return "rejected";
      case "partially_filled":
        return "open";
      default:
        return "open";
    }
  }
  /**
   * Normalize position data
   */
  normalizePosition(position) {
    const unifiedSymbol = this.symbolToCCXT(position.symbol);
    const size = safeParseFloat2(position.size);
    const markPrice = safeParseFloat2(position.markPrice);
    return {
      symbol: unifiedSymbol,
      side: position.side,
      size,
      entryPrice: safeParseFloat2(position.entryPrice),
      markPrice,
      leverage: safeParseFloat2(position.leverage),
      liquidationPrice: safeParseFloat2(position.liquidationPrice),
      unrealizedPnl: safeParseFloat2(position.unrealizedPnl),
      realizedPnl: 0,
      margin: safeParseFloat2(position.initialMargin),
      maintenanceMargin: safeParseFloat2(position.maintenanceMargin),
      marginRatio: safeParseFloat2(position.maintenanceMargin) / (size * markPrice),
      marginMode: position.marginMode,
      timestamp: position.timestamp,
      info: position
    };
  }
  /**
   * Normalize balance data
   */
  normalizeBalance(balance) {
    return {
      currency: balance.asset,
      free: safeParseFloat2(balance.free),
      used: safeParseFloat2(balance.locked),
      total: safeParseFloat2(balance.total)
    };
  }
  /**
   * Batch normalize markets
   */
  normalizeMarkets(markets) {
    return markets.map((market) => this.normalizeMarket(market));
  }
  /**
   * Batch normalize orders
   */
  normalizeOrders(orders) {
    return orders.map((order) => this.normalizeOrder(order));
  }
  /**
   * Batch normalize positions
   */
  normalizePositions(positions) {
    return positions.map((position) => this.normalizePosition(position));
  }
  /**
   * Batch normalize balances
   */
  normalizeBalances(balances) {
    return balances.map((balance) => this.normalizeBalance(balance));
  }
  /**
   * Batch normalize trades
   */
  normalizeTrades(trades) {
    return trades.map((trade) => this.normalizeTrade(trade));
  }
  /**
   * Batch normalize funding rates
   */
  normalizeFundingRates(rates) {
    return rates.map((rate) => this.normalizeFundingRate(rate));
  }
};

// src/adapters/extended/ExtendedStarkNetClient.ts
var import_starknet3 = require("starknet");
var ExtendedStarkNetClient = class _ExtendedStarkNetClient {
  provider;
  account;
  logger;
  constructor(config) {
    this.logger = new Logger("ExtendedStarkNetClient");
    const nodeUrl = config.rpcUrl || (config.network === "mainnet" ? "https://starknet-mainnet.public.blastapi.io" : "https://starknet-testnet.public.blastapi.io");
    this.provider = new import_starknet3.RpcProvider({ nodeUrl });
    if (config.privateKey && config.accountAddress) {
      this.initializeAccount(config.privateKey, config.accountAddress);
    }
  }
  /**
   * Initialize StarkNet account with private key
   */
  initializeAccount(privateKey, address) {
    try {
      const formattedAddress = formatStarkNetAddress(address);
      if (!isValidStarkNetAddress(formattedAddress)) {
        throw new Error(`Invalid StarkNet address: ${address}`);
      }
      const accountOptions = {
        provider: this.provider,
        address: formattedAddress,
        signer: privateKey,
        cairoVersion: "1"
      };
      this.account = new import_starknet3.Account(accountOptions);
      this.logger.info("StarkNet account initialized", { address: formattedAddress });
    } catch (error) {
      this.logger.error("Failed to initialize StarkNet account", error instanceof Error ? error : void 0);
      throw mapStarkNetError(error);
    }
  }
  /**
   * Check if account is initialized
   */
  isAccountInitialized() {
    return this.account !== void 0;
  }
  /**
   * Get account address
   */
  getAccountAddress() {
    return this.account?.address;
  }
  /**
   * Get current block number
   */
  async getBlockNumber() {
    try {
      const block = await this.provider.getBlock("latest");
      return block.block_number;
    } catch (error) {
      this.logger.error("Failed to get block number", error instanceof Error ? error : void 0);
      throw mapStarkNetError(error);
    }
  }
  // StarkNet ETH contract address (same on mainnet and testnet)
  static ETH_CONTRACT_ADDRESS = "0x049d36570d4e46f48e99674bd3fcc84644ddd6b96f7c741b1562b82f9e004dc7";
  /**
   * Get account state from StarkNet
   */
  async getAccountState(address) {
    try {
      const targetAddress = address || this.account?.address;
      if (!targetAddress) {
        throw new Error("No account address provided");
      }
      const formattedAddress = formatStarkNetAddress(targetAddress);
      let balance = "0";
      try {
        const result = await this.provider.callContract({
          contractAddress: _ExtendedStarkNetClient.ETH_CONTRACT_ADDRESS,
          entrypoint: "balanceOf",
          calldata: import_starknet3.CallData.compile({ account: formattedAddress })
        });
        if (result && result.length > 0) {
          const lowValue = result[0];
          if (lowValue !== void 0) {
            balance = BigInt(lowValue).toString();
          }
        }
      } catch (balanceError) {
        this.logger.warn("Failed to fetch balance, using 0", { error: balanceError instanceof Error ? balanceError.message : String(balanceError) });
      }
      const nonce = await this.provider.getNonceForAddress(formattedAddress);
      return {
        address: formattedAddress,
        balance,
        nonce: parseInt(nonce, 16)
      };
    } catch (error) {
      this.logger.error("Failed to get account state", error instanceof Error ? error : void 0);
      throw mapStarkNetError(error);
    }
  }
  /**
   * Get transaction status
   */
  async getTransaction(txHash) {
    try {
      const receipt = await this.provider.getTransactionReceipt(txHash);
      const executionStatus = receipt.isSuccess() ? "SUCCEEDED" : receipt.isReverted() ? "REVERTED" : void 0;
      const txType = receipt.isError() ? "INVOKE" : receipt.type;
      const blockNumber = receipt.isError() ? void 0 : receipt.block_number;
      return {
        txHash,
        status: this.mapTransactionStatus(executionStatus),
        type: txType,
        blockNumber,
        timestamp: Date.now()
        // StarkNet doesn't provide timestamp in receipt
      };
    } catch (error) {
      this.logger.error("Failed to get transaction", error instanceof Error ? error : void 0, { txHash });
      throw mapStarkNetError(error);
    }
  }
  /**
   * Map StarkNet transaction status to our format
   */
  mapTransactionStatus(status) {
    switch (status) {
      case "SUCCEEDED":
        return "accepted";
      case "REVERTED":
        return "rejected";
      default:
        return "pending";
    }
  }
  /**
   * Wait for transaction confirmation
   */
  async waitForTransaction(txHash, _confirmations = EXTENDED_STARKNET_CONFIG.confirmations, timeoutMs = 3e5) {
    const startTime = Date.now();
    while (Date.now() - startTime < timeoutMs) {
      try {
        const tx = await this.getTransaction(txHash);
        if (tx.status === "accepted" || tx.status === "rejected") {
          return tx;
        }
        await new Promise((resolve) => setTimeout(resolve, 5e3));
      } catch (error) {
        await new Promise((resolve) => setTimeout(resolve, 5e3));
      }
    }
    throw new Error(`Transaction ${txHash} confirmation timeout after ${timeoutMs}ms`);
  }
  /**
   * Call contract view function (read-only)
   */
  async callContract(contractAddress, entrypoint, calldata = []) {
    try {
      const formattedAddress = formatStarkNetAddress(contractAddress);
      const compiledCalldata = Array.isArray(calldata) ? calldata.map(String) : import_starknet3.CallData.compile(calldata);
      const result = await this.provider.callContract({
        contractAddress: formattedAddress,
        entrypoint,
        calldata: compiledCalldata
      });
      return result;
    } catch (error) {
      this.logger.error("Failed to call contract", error instanceof Error ? error : void 0, {
        contractAddress,
        entrypoint
      });
      throw mapStarkNetError(error);
    }
  }
  /**
   * Execute contract function (state-changing)
   * Requires initialized account
   */
  async executeContract(contractAddress, entrypoint, calldata = []) {
    if (!this.account) {
      throw new Error("Account not initialized. Cannot execute contract calls.");
    }
    try {
      const formattedAddress = formatStarkNetAddress(contractAddress);
      const compiledCalldata = Array.isArray(calldata) ? calldata.map(String) : import_starknet3.CallData.compile(calldata);
      const { transaction_hash } = await this.account.execute({
        contractAddress: formattedAddress,
        entrypoint,
        calldata: compiledCalldata
      });
      this.logger.info("Contract execution initiated", {
        contractAddress: formattedAddress,
        entrypoint,
        txHash: transaction_hash
      });
      return transaction_hash;
    } catch (error) {
      this.logger.error("Failed to execute contract", error instanceof Error ? error : void 0, {
        contractAddress,
        entrypoint
      });
      throw mapStarkNetError(error);
    }
  }
  /**
   * Get positions from StarkNet contract
   * (Placeholder - actual implementation depends on Extended's contract ABI)
   */
  async getPositionsFromContract(contractAddress, accountAddress) {
    try {
      const targetAddress = accountAddress || this.account?.address;
      if (!targetAddress) {
        throw new Error("No account address provided");
      }
      const result = await this.callContract(contractAddress, "get_positions", [
        targetAddress
      ]);
      return result;
    } catch (error) {
      this.logger.error("Failed to get positions from contract", error instanceof Error ? error : void 0);
      throw mapStarkNetError(error);
    }
  }
  /**
   * Submit order to StarkNet contract
   * (Placeholder - actual implementation depends on Extended's contract ABI)
   */
  async submitOrderToContract(contractAddress, orderData) {
    if (!this.account) {
      throw new Error("Account not initialized. Cannot submit orders.");
    }
    try {
      const txHash = await this.executeContract(
        contractAddress,
        "submit_order",
        [orderData]
        // Needs proper formatting
      );
      return txHash;
    } catch (error) {
      this.logger.error("Failed to submit order to contract", error instanceof Error ? error : void 0);
      throw mapStarkNetError(error);
    }
  }
  /**
   * Get contract info
   */
  async getContractInfo(contractAddress) {
    try {
      const formattedAddress = formatStarkNetAddress(contractAddress);
      const classHash = await this.provider.getClassHashAt(formattedAddress);
      return {
        address: formattedAddress,
        classHash
      };
    } catch (error) {
      this.logger.error("Failed to get contract info", error instanceof Error ? error : void 0, { contractAddress });
      throw mapStarkNetError(error);
    }
  }
  /**
   * Estimate fee for contract execution
   */
  async estimateFee(contractAddress, entrypoint, calldata = []) {
    if (!this.account) {
      throw new Error("Account not initialized. Cannot estimate fees.");
    }
    try {
      const formattedAddress = formatStarkNetAddress(contractAddress);
      const compiledCalldata = Array.isArray(calldata) ? calldata.map(String) : import_starknet3.CallData.compile(calldata);
      const feeEstimate = await this.account.estimateInvokeFee({
        contractAddress: formattedAddress,
        entrypoint,
        calldata: compiledCalldata
      });
      return BigInt(feeEstimate.overall_fee.toString());
    } catch (error) {
      this.logger.error("Failed to estimate fee", error instanceof Error ? error : void 0, { contractAddress, entrypoint });
      throw mapStarkNetError(error);
    }
  }
  /**
   * Cleanup resources
   */
  async disconnect() {
    this.account = void 0;
    this.logger.info("StarkNet client disconnected");
  }
};

// src/adapters/extended/ExtendedWebSocketWrapper.ts
var ExtendedWebSocketWrapper = class _ExtendedWebSocketWrapper {
  ws;
  wsUrl;
  apiKey;
  normalizer;
  logger;
  isConnected = false;
  isConnecting = false;
  reconnectAttempts = 0;
  maxReconnectAttempts;
  reconnect;
  pingInterval;
  pingIntervalMs;
  pongTimeout;
  subscriptions = /* @__PURE__ */ new Map();
  connectionPromise;
  constructor(config) {
    this.wsUrl = config.wsUrl;
    this.apiKey = config.apiKey;
    this.normalizer = new ExtendedNormalizer();
    this.logger = new Logger("ExtendedWebSocketWrapper");
    this.reconnect = config.reconnect ?? true;
    this.pingIntervalMs = config.pingInterval ?? EXTENDED_WS_CONFIG.pingInterval;
    this.maxReconnectAttempts = config.maxReconnectAttempts ?? EXTENDED_WS_CONFIG.reconnectAttempts;
  }
  /**
   * Connect to WebSocket
   */
  async connect() {
    if (this.isConnected) {
      return;
    }
    if (this.isConnecting && this.connectionPromise) {
      return this.connectionPromise;
    }
    this.isConnecting = true;
    this.connectionPromise = new Promise((resolve, reject) => {
      try {
        this.ws = new WebSocket(this.wsUrl);
        this.ws.onopen = () => {
          this.isConnected = true;
          this.isConnecting = false;
          this.reconnectAttempts = 0;
          this.logger.info("WebSocket connected");
          this.startHeartbeat();
          if (this.apiKey) {
            this.authenticate();
          }
          this.resubscribeAll();
          resolve();
        };
        this.ws.onmessage = (event) => {
          this.handleMessage(event.data);
        };
        this.ws.onerror = (error) => {
          this.logger.error("WebSocket error", error instanceof Error ? error : new Error("WebSocket error"));
          if (this.isConnecting) {
            this.isConnecting = false;
            reject(new Error("WebSocket connection failed"));
          }
        };
        this.ws.onclose = (event) => {
          this.isConnected = false;
          this.isConnecting = false;
          this.stopHeartbeat();
          this.logger.info("WebSocket closed", { code: event.code, reason: event.reason });
          if (this.reconnect && this.reconnectAttempts < this.maxReconnectAttempts) {
            this.scheduleReconnect();
          }
        };
      } catch (error) {
        this.isConnecting = false;
        reject(error);
      }
    });
    return this.connectionPromise;
  }
  /**
   * Disconnect from WebSocket
   */
  disconnect() {
    this.reconnect && (this.reconnectAttempts = this.maxReconnectAttempts);
    this.stopHeartbeat();
    if (this.ws) {
      this.ws.close(1e3, "Client disconnect");
      this.ws = void 0;
    }
    this.isConnected = false;
    this.isConnecting = false;
    this.subscriptions.clear();
    this.logger.info("WebSocket disconnected");
  }
  /**
   * Watch order book updates
   */
  async *watchOrderBook(symbol, limit) {
    const channel = this.getChannelKey(EXTENDED_WS_CHANNELS.ORDERBOOK, symbol);
    const exchangeSymbol = this.normalizer.symbolFromCCXT(symbol);
    await this.subscribe(EXTENDED_WS_CHANNELS.ORDERBOOK, exchangeSymbol);
    try {
      for await (const message of this.createMessageIterator(channel)) {
        if (message.channel === "orderbook" && message.symbol === exchangeSymbol) {
          const orderbook = {
            exchange: "extended",
            symbol: this.normalizer.symbolToCCXT(message.symbol),
            bids: message.bids.slice(0, limit).map(([price, amount]) => [
              parseFloat(price),
              parseFloat(amount)
            ]),
            asks: message.asks.slice(0, limit).map(([price, amount]) => [
              parseFloat(price),
              parseFloat(amount)
            ]),
            timestamp: message.timestamp,
            sequenceId: message.sequence,
            checksum: message.checksum
          };
          yield orderbook;
        }
      }
    } finally {
      await this.unsubscribe(EXTENDED_WS_CHANNELS.ORDERBOOK, exchangeSymbol);
    }
  }
  /**
   * Watch trade updates
   */
  async *watchTrades(symbol) {
    const channel = this.getChannelKey(EXTENDED_WS_CHANNELS.TRADES, symbol);
    const exchangeSymbol = this.normalizer.symbolFromCCXT(symbol);
    await this.subscribe(EXTENDED_WS_CHANNELS.TRADES, exchangeSymbol);
    try {
      for await (const message of this.createMessageIterator(channel)) {
        if (message.channel === "trades" && message.symbol === exchangeSymbol) {
          const price = parseFloat(message.price);
          const amount = parseFloat(message.quantity);
          const trade = {
            id: message.id,
            symbol: this.normalizer.symbolToCCXT(message.symbol),
            side: message.side,
            price,
            amount,
            cost: price * amount,
            timestamp: message.timestamp
          };
          yield trade;
        }
      }
    } finally {
      await this.unsubscribe(EXTENDED_WS_CHANNELS.TRADES, exchangeSymbol);
    }
  }
  /**
   * Watch ticker updates
   */
  async *watchTicker(symbol) {
    const channel = this.getChannelKey(EXTENDED_WS_CHANNELS.TICKER, symbol);
    const exchangeSymbol = this.normalizer.symbolFromCCXT(symbol);
    await this.subscribe(EXTENDED_WS_CHANNELS.TICKER, exchangeSymbol);
    try {
      for await (const message of this.createMessageIterator(channel)) {
        if (message.channel === "ticker" && message.symbol === exchangeSymbol) {
          const lastPrice = parseFloat(message.lastPrice);
          const ticker = {
            symbol: this.normalizer.symbolToCCXT(message.symbol),
            timestamp: message.timestamp,
            high: parseFloat(message.high24h),
            low: parseFloat(message.low24h),
            bid: parseFloat(message.bidPrice),
            ask: parseFloat(message.askPrice),
            last: lastPrice,
            open: lastPrice,
            // WebSocket may not provide open price
            close: lastPrice,
            baseVolume: parseFloat(message.volume24h),
            quoteVolume: parseFloat(message.quoteVolume24h),
            change: parseFloat(message.priceChange24h),
            percentage: parseFloat(message.priceChangePercent24h)
          };
          yield ticker;
        }
      }
    } finally {
      await this.unsubscribe(EXTENDED_WS_CHANNELS.TICKER, exchangeSymbol);
    }
  }
  /**
   * Watch position updates (requires authentication)
   */
  async *watchPositions() {
    if (!this.apiKey) {
      throw new Error("API key required for watching positions");
    }
    const channel = EXTENDED_WS_CHANNELS.POSITIONS;
    await this.subscribe(channel);
    try {
      for await (const message of this.createMessageIterator(channel)) {
        if (message.channel === "positions") {
          const positions = message.positions.map(
            (pos) => this.normalizer.normalizePosition(pos)
          );
          yield positions;
        }
      }
    } finally {
      await this.unsubscribe(channel);
    }
  }
  /**
   * Watch order updates (requires authentication)
   */
  async *watchOrders() {
    if (!this.apiKey) {
      throw new Error("API key required for watching orders");
    }
    const channel = EXTENDED_WS_CHANNELS.ORDERS;
    await this.subscribe(channel);
    try {
      for await (const message of this.createMessageIterator(channel)) {
        if (message.channel === "orders") {
          const orders = message.orders.map(
            (ord) => this.normalizer.normalizeOrder(ord)
          );
          yield orders;
        }
      }
    } finally {
      await this.unsubscribe(channel);
    }
  }
  /**
   * Watch balance updates (requires authentication)
   */
  async *watchBalance() {
    if (!this.apiKey) {
      throw new Error("API key required for watching balance");
    }
    const channel = EXTENDED_WS_CHANNELS.BALANCE;
    await this.subscribe(channel);
    try {
      for await (const message of this.createMessageIterator(channel)) {
        if (message.channel === "balance") {
          const balances = message.balances.map(
            (bal) => this.normalizer.normalizeBalance(bal)
          );
          yield balances;
        }
      }
    } finally {
      await this.unsubscribe(channel);
    }
  }
  /**
   * Watch funding rate updates
   */
  async *watchFundingRate(symbol) {
    const channel = this.getChannelKey(EXTENDED_WS_CHANNELS.FUNDING, symbol);
    const exchangeSymbol = this.normalizer.symbolFromCCXT(symbol);
    await this.subscribe(EXTENDED_WS_CHANNELS.FUNDING, exchangeSymbol);
    try {
      for await (const message of this.createMessageIterator(channel)) {
        if (message.channel === "funding" && message.symbol === exchangeSymbol) {
          const fundingRate = {
            symbol: this.normalizer.symbolToCCXT(message.symbol),
            fundingRate: parseFloat(message.fundingRate),
            fundingTimestamp: message.fundingTime,
            nextFundingTimestamp: message.nextFundingTime || 0,
            markPrice: parseFloat(message.markPrice),
            indexPrice: parseFloat(message.indexPrice),
            fundingIntervalHours: 8
          };
          yield fundingRate;
        }
      }
    } finally {
      await this.unsubscribe(EXTENDED_WS_CHANNELS.FUNDING, exchangeSymbol);
    }
  }
  // ==================== Private Methods ====================
  /**
   * Subscribe to a channel
   */
  async subscribe(channel, symbol) {
    await this.ensureConnected();
    const channelKey = this.getChannelKey(channel, symbol);
    if (!this.subscriptions.has(channelKey)) {
      this.subscriptions.set(channelKey, /* @__PURE__ */ new Set());
    }
    const message = {
      action: "subscribe",
      channel,
      symbol
    };
    this.send(message);
    this.logger.debug("Subscribed to channel", { channel, symbol });
  }
  /**
   * Unsubscribe from a channel
   */
  async unsubscribe(channel, symbol) {
    const channelKey = this.getChannelKey(channel, symbol);
    if (this.subscriptions.has(channelKey)) {
      this.subscriptions.delete(channelKey);
      if (this.isConnected) {
        const message = {
          action: "unsubscribe",
          channel,
          symbol
        };
        this.send(message);
      }
      this.logger.debug("Unsubscribed from channel", { channel, symbol });
    }
  }
  /**
   * Authenticate the WebSocket connection
   */
  authenticate() {
    if (!this.apiKey) return;
    const authMessage = {
      action: "auth",
      apiKey: this.apiKey,
      timestamp: Date.now()
    };
    this.send(authMessage);
    this.logger.debug("Sent authentication message");
  }
  /**
   * Handle incoming WebSocket messages
   */
  handleMessage(data) {
    try {
      const message = JSON.parse(data);
      if (message.type === "pong" || message.event === "pong") {
        this.handlePong();
        return;
      }
      if (message.event === "subscribed" || message.event === "unsubscribed") {
        this.logger.debug("Subscription event", { event: message.event, channel: message.channel });
        return;
      }
      if (message.event === "authenticated") {
        this.logger.info("WebSocket authenticated");
        return;
      }
      if (message.error || message.event === "error") {
        this.logger.error("WebSocket error message", new Error(message.error || message.message));
        return;
      }
      const channel = message.channel;
      const symbol = message.symbol;
      const channelKey = this.getChannelKey(channel, symbol);
      const handlers = this.subscriptions.get(channelKey);
      if (handlers) {
        handlers.forEach((handler) => handler(message));
      }
    } catch (error) {
      this.logger.error("Failed to parse WebSocket message", error instanceof Error ? error : new Error(String(error)));
    }
  }
  /**
   * Create an async iterator for messages on a channel
   */
  /** Maximum queue size for backpressure */
  static MAX_QUEUE_SIZE = 1e3;
  async *createMessageIterator(channelKey) {
    const messageQueue = [];
    let resolver = null;
    let isActive = true;
    const handler = (message) => {
      if (resolver) {
        resolver(message);
        resolver = null;
      } else {
        if (messageQueue.length >= _ExtendedWebSocketWrapper.MAX_QUEUE_SIZE) {
          messageQueue.shift();
          this.logger.warn(`Queue overflow on channel ${channelKey}, dropping oldest message`);
        }
        messageQueue.push(message);
      }
    };
    const handlers = this.subscriptions.get(channelKey);
    if (handlers) {
      handlers.add(handler);
    }
    try {
      while (isActive && this.subscriptions.has(channelKey)) {
        if (messageQueue.length > 0) {
          yield messageQueue.shift();
        } else {
          yield await new Promise((resolve) => {
            resolver = resolve;
          });
        }
      }
    } finally {
      isActive = false;
      if (handlers) {
        handlers.delete(handler);
      }
    }
  }
  /**
   * Ensure WebSocket is connected
   */
  async ensureConnected() {
    if (!this.isConnected) {
      await this.connect();
    }
  }
  /**
   * Send a message through WebSocket
   */
  send(message) {
    if (this.ws && this.isConnected) {
      this.ws.send(JSON.stringify(message));
    }
  }
  /**
   * Get channel key for subscription tracking
   */
  getChannelKey(channel, symbol) {
    return symbol ? `${channel}:${symbol}` : channel;
  }
  /**
   * Start heartbeat ping/pong
   */
  startHeartbeat() {
    this.stopHeartbeat();
    this.pingInterval = setInterval(() => {
      if (this.isConnected) {
        this.send({ type: "ping", timestamp: Date.now() });
        this.pongTimeout = setTimeout(() => {
          this.logger.warn("Pong timeout, reconnecting...");
          this.ws?.close(4e3, "Pong timeout");
        }, EXTENDED_WS_CONFIG.pongTimeout);
      }
    }, this.pingIntervalMs);
  }
  /**
   * Stop heartbeat
   */
  stopHeartbeat() {
    if (this.pingInterval) {
      clearInterval(this.pingInterval);
      this.pingInterval = void 0;
    }
    if (this.pongTimeout) {
      clearTimeout(this.pongTimeout);
      this.pongTimeout = void 0;
    }
  }
  /**
   * Handle pong response
   */
  handlePong() {
    if (this.pongTimeout) {
      clearTimeout(this.pongTimeout);
      this.pongTimeout = void 0;
    }
  }
  /**
   * Schedule reconnection
   */
  scheduleReconnect() {
    this.reconnectAttempts++;
    const delay = Math.min(
      EXTENDED_WS_CONFIG.reconnectDelay * Math.pow(2, this.reconnectAttempts - 1),
      EXTENDED_WS_CONFIG.maxReconnectDelay
    );
    this.logger.info(`Reconnecting in ${delay}ms (attempt ${this.reconnectAttempts}/${this.maxReconnectAttempts})`);
    setTimeout(() => {
      this.connect().catch((error) => {
        this.logger.error("Reconnection failed", error instanceof Error ? error : new Error(String(error)));
      });
    }, delay);
  }
  /**
   * Resubscribe to all channels after reconnection
   */
  resubscribeAll() {
    for (const channelKey of this.subscriptions.keys()) {
      const parts = channelKey.split(":");
      const channel = parts[0] ?? "";
      const symbol = parts[1];
      if (channel) {
        const message = {
          action: "subscribe",
          channel,
          symbol: symbol || void 0
        };
        this.send(message);
      }
    }
  }
  /**
   * Check if connected
   */
  get connected() {
    return this.isConnected;
  }
};

// src/adapters/extended/ExtendedAdapter.ts
var ExtendedAdapter = class extends BaseAdapter {
  id = "extended";
  name = "Extended";
  has = {
    fetchMarkets: true,
    fetchTicker: true,
    fetchOrderBook: true,
    fetchTrades: true,
    fetchFundingRate: true,
    fetchFundingRateHistory: true,
    fetchPositions: true,
    fetchBalance: true,
    fetchOrderHistory: true,
    fetchMyTrades: true,
    fetchUserFees: true,
    fetchPortfolio: true,
    fetchRateLimitStatus: false,
    createOrder: true,
    createBatchOrders: true,
    cancelOrder: true,
    cancelAllOrders: true,
    cancelBatchOrders: true,
    editOrder: true,
    setLeverage: true,
    setMarginMode: true,
    fetchDeposits: false,
    fetchWithdrawals: false,
    watchOrderBook: true,
    watchTrades: true,
    watchTicker: true,
    watchPositions: true,
    watchOrders: true,
    watchBalance: true,
    watchFundingRate: true
  };
  apiUrl;
  wsUrl;
  apiKey;
  rateLimiter;
  httpClient;
  normalizer;
  starkNetClient;
  wsManager = null;
  wsWrapper;
  constructor(config = {}) {
    super(config);
    const testnet = config.testnet ?? false;
    if (testnet) {
      this.logger.warn("Extended testnet (Sepolia) is not operational. Using mainnet instead.");
    }
    const urls = EXTENDED_API_URLS.mainnet;
    this.apiUrl = urls.rest;
    this.wsUrl = urls.websocket;
    this.apiKey = config.apiKey;
    this.normalizer = new ExtendedNormalizer();
    if (config.starknetPrivateKey && config.starknetAccountAddress) {
      this.starkNetClient = new ExtendedStarkNetClient({
        network: "mainnet",
        privateKey: config.starknetPrivateKey,
        accountAddress: config.starknetAccountAddress,
        rpcUrl: config.starknetRpcUrl || urls.starknet
      });
    }
    const limits = EXTENDED_RATE_LIMITS.default;
    this.rateLimiter = new RateLimiter({
      maxTokens: limits.maxRequests,
      refillRate: limits.maxRequests / (limits.windowMs / 1e3),
      windowMs: limits.windowMs,
      weights: EXTENDED_ENDPOINT_WEIGHTS
    });
    this.httpClient = new HTTPClient({
      baseUrl: this.apiUrl,
      timeout: config.timeout || EXTENDED_DEFAULTS.timeout,
      retry: {
        maxAttempts: 3,
        initialDelay: 1e3,
        maxDelay: 1e4,
        multiplier: 2,
        retryableStatuses: [408, 429, 500, 502, 503, 504]
      },
      circuitBreaker: {
        enabled: true,
        failureThreshold: 5,
        successThreshold: 2,
        resetTimeout: 6e4
      },
      exchange: this.id
    });
  }
  async initialize() {
    this._isReady = true;
    this.info("Extended adapter initialized", {
      starkNetEnabled: !!this.starkNetClient
    });
  }
  async disconnect() {
    if (this.wsWrapper) {
      this.wsWrapper.disconnect();
      this.wsWrapper = void 0;
    }
    if (this.wsManager) {
      await this.wsManager.disconnect();
      this.wsManager = null;
    }
    if (this.starkNetClient) {
      await this.starkNetClient.disconnect();
    }
    this._isReady = false;
    this.info("Extended adapter disconnected");
  }
  // ==================== Symbol Conversion Methods ====================
  /**
   * Convert unified symbol to Extended format
   */
  symbolToExchange(symbol) {
    return this.normalizer.symbolFromCCXT(symbol);
  }
  /**
   * Convert Extended symbol to unified format
   */
  symbolFromExchange(exchangeSymbol) {
    return this.normalizer.symbolToCCXT(exchangeSymbol);
  }
  // ==================== Market Data Methods ====================
  async fetchMarkets(_params) {
    await this.rateLimiter.acquire(EXTENDED_ENDPOINTS.MARKETS);
    try {
      const response = await this.httpClient.get(
        EXTENDED_ENDPOINTS.MARKETS,
        {}
      );
      const markets = response.markets || [];
      return this.normalizer.normalizeMarkets(markets);
    } catch (error) {
      throw mapError4(error);
    }
  }
  async fetchTicker(symbol) {
    await this.rateLimiter.acquire(EXTENDED_ENDPOINTS.TICKER_SYMBOL);
    try {
      const market = this.symbolToExchange(symbol);
      const endpoint = EXTENDED_ENDPOINTS.TICKER_SYMBOL.replace("{market}", market);
      const ticker = await this.httpClient.get(endpoint, {});
      return this.normalizer.normalizeTicker(ticker);
    } catch (error) {
      throw mapError4(error);
    }
  }
  async fetchOrderBook(symbol, params) {
    await this.rateLimiter.acquire(EXTENDED_ENDPOINTS.ORDERBOOK);
    try {
      const market = this.symbolToExchange(symbol);
      let endpoint = EXTENDED_ENDPOINTS.ORDERBOOK.replace("{market}", market);
      const queryParams = {};
      if (params?.limit) {
        queryParams.depth = params.limit;
      }
      endpoint += this.buildQueryString(queryParams);
      const orderbook = await this.httpClient.get(endpoint, {});
      return this.normalizer.normalizeOrderBook(orderbook);
    } catch (error) {
      throw mapError4(error);
    }
  }
  async fetchTrades(symbol, params) {
    await this.rateLimiter.acquire(EXTENDED_ENDPOINTS.TRADES);
    try {
      const market = this.symbolToExchange(symbol);
      let endpoint = EXTENDED_ENDPOINTS.TRADES.replace("{market}", market);
      const queryParams = {};
      if (params?.since) {
        queryParams.startTime = params.since;
      }
      if (params?.limit) {
        queryParams.limit = params.limit;
      }
      endpoint += this.buildQueryString(queryParams);
      const response = await this.httpClient.get(endpoint, {});
      const trades = response.trades || [];
      return this.normalizer.normalizeTrades(trades);
    } catch (error) {
      throw mapError4(error);
    }
  }
  async fetchFundingRate(symbol) {
    await this.rateLimiter.acquire(EXTENDED_ENDPOINTS.FUNDING_RATE);
    try {
      const market = this.symbolToExchange(symbol);
      const endpoint = EXTENDED_ENDPOINTS.FUNDING_RATE.replace("{market}", market);
      const fundingRate = await this.httpClient.get(endpoint, {});
      return this.normalizer.normalizeFundingRate(fundingRate);
    } catch (error) {
      throw mapError4(error);
    }
  }
  async fetchFundingRateHistory(symbol, since, limit) {
    await this.rateLimiter.acquire(EXTENDED_ENDPOINTS.FUNDING_HISTORY);
    try {
      const market = this.symbolToExchange(symbol);
      let endpoint = EXTENDED_ENDPOINTS.FUNDING_HISTORY.replace("{market}", market);
      const queryParams = {};
      if (since) {
        queryParams.startTime = since;
      }
      if (limit) {
        queryParams.limit = limit;
      }
      endpoint += this.buildQueryString(queryParams);
      const response = await this.httpClient.get(endpoint, {});
      const rates = response.rates || [];
      return this.normalizer.normalizeFundingRates(rates);
    } catch (error) {
      throw mapError4(error);
    }
  }
  // ==================== Trading Methods ====================
  async createOrder(request) {
    await this.rateLimiter.acquire(EXTENDED_ENDPOINTS.CREATE_ORDER);
    validateOrderRequest3(request);
    if (!this.apiKey) {
      throw new PerpDEXError("API key required for trading", "AUTHENTICATION_ERROR", this.id);
    }
    try {
      const extendedOrder = convertOrderRequest4(request);
      const order = await this.httpClient.post(
        EXTENDED_ENDPOINTS.CREATE_ORDER,
        {
          headers: {
            "X-Api-Key": this.apiKey,
            "Content-Type": "application/json"
          },
          body: extendedOrder
        }
      );
      return this.normalizer.normalizeOrder(order);
    } catch (error) {
      throw mapError4(error);
    }
  }
  async cancelOrder(orderId, _symbol) {
    await this.rateLimiter.acquire(EXTENDED_ENDPOINTS.CANCEL_ORDER);
    if (!this.apiKey) {
      throw new PerpDEXError("API key required for trading", "AUTHENTICATION_ERROR", this.id);
    }
    try {
      const endpoint = EXTENDED_ENDPOINTS.CANCEL_ORDER.replace("{orderId}", orderId);
      const order = await this.httpClient.delete(endpoint, {
        headers: {
          "X-Api-Key": this.apiKey
        }
      });
      return this.normalizer.normalizeOrder(order);
    } catch (error) {
      throw mapError4(error);
    }
  }
  async cancelAllOrders(symbol) {
    await this.rateLimiter.acquire(EXTENDED_ENDPOINTS.CANCEL_ALL_ORDERS);
    if (!this.apiKey) {
      throw new PerpDEXError("API key required for trading", "AUTHENTICATION_ERROR", this.id);
    }
    try {
      const queryParams = {};
      if (symbol) {
        queryParams.market = this.symbolToExchange(symbol);
      }
      let endpoint = EXTENDED_ENDPOINTS.CANCEL_ALL_ORDERS;
      endpoint += this.buildQueryString(queryParams);
      const response = await this.httpClient.delete(
        endpoint,
        {
          headers: {
            "X-Api-Key": this.apiKey
          }
        }
      );
      const orders = response.orders || [];
      return this.normalizer.normalizeOrders(orders);
    } catch (error) {
      throw mapError4(error);
    }
  }
  async createBatchOrders(requests) {
    await this.rateLimiter.acquire(EXTENDED_ENDPOINTS.BATCH_ORDERS);
    if (!this.apiKey) {
      throw new PerpDEXError("API key required for trading", "AUTHENTICATION_ERROR", this.id);
    }
    try {
      requests.forEach((req) => validateOrderRequest3(req));
      const extendedOrders = requests.map((req) => convertOrderRequest4(req));
      const response = await this.httpClient.post(
        EXTENDED_ENDPOINTS.BATCH_ORDERS,
        {
          headers: {
            "X-Api-Key": this.apiKey,
            "Content-Type": "application/json"
          },
          body: { orders: extendedOrders }
        }
      );
      const orders = response.orders || [];
      return this.normalizer.normalizeOrders(orders);
    } catch (error) {
      throw mapError4(error);
    }
  }
  async cancelBatchOrders(orderIds, _symbol) {
    await this.rateLimiter.acquire(EXTENDED_ENDPOINTS.CANCEL_ALL_ORDERS);
    if (!this.apiKey) {
      throw new PerpDEXError("API key required for trading", "AUTHENTICATION_ERROR", this.id);
    }
    try {
      const response = await this.httpClient.delete(
        EXTENDED_ENDPOINTS.CANCEL_ALL_ORDERS,
        {
          headers: {
            "X-Api-Key": this.apiKey,
            "Content-Type": "application/json"
          },
          body: { orderIds }
        }
      );
      const orders = response.orders || [];
      return this.normalizer.normalizeOrders(orders);
    } catch (error) {
      throw mapError4(error);
    }
  }
  async editOrder(orderId, symbol, type, side, amount, price) {
    await this.rateLimiter.acquire(EXTENDED_ENDPOINTS.EDIT_ORDER);
    if (!this.apiKey) {
      throw new PerpDEXError("API key required for trading", "AUTHENTICATION_ERROR", this.id);
    }
    try {
      const endpoint = EXTENDED_ENDPOINTS.EDIT_ORDER.replace("{orderId}", orderId);
      const market = this.symbolToExchange(symbol);
      const body = {
        symbol: market,
        type,
        side
      };
      if (amount !== void 0) {
        body.quantity = amount.toString();
      }
      if (price !== void 0) {
        body.price = price.toString();
      }
      const order = await this.httpClient.put(endpoint, {
        headers: {
          "X-Api-Key": this.apiKey,
          "Content-Type": "application/json"
        },
        body
      });
      return this.normalizer.normalizeOrder(order);
    } catch (error) {
      throw mapError4(error);
    }
  }
  // ==================== Account Methods ====================
  async fetchPositions(symbols) {
    await this.rateLimiter.acquire(EXTENDED_ENDPOINTS.POSITIONS);
    if (!this.apiKey) {
      throw new PerpDEXError("API key required for account data", "AUTHENTICATION_ERROR", this.id);
    }
    try {
      const queryParams = {};
      if (symbols && symbols.length > 0) {
        queryParams.markets = symbols.map((s) => this.symbolToExchange(s)).join(",");
      }
      let endpoint = EXTENDED_ENDPOINTS.POSITIONS;
      endpoint += this.buildQueryString(queryParams);
      const response = await this.httpClient.get(
        endpoint,
        {
          headers: {
            "X-Api-Key": this.apiKey
          }
        }
      );
      const positions = response.positions || [];
      return this.normalizer.normalizePositions(positions);
    } catch (error) {
      throw mapError4(error);
    }
  }
  async fetchBalance() {
    await this.rateLimiter.acquire(EXTENDED_ENDPOINTS.BALANCE);
    if (!this.apiKey) {
      throw new PerpDEXError("API key required for account data", "AUTHENTICATION_ERROR", this.id);
    }
    try {
      const response = await this.httpClient.get(
        EXTENDED_ENDPOINTS.BALANCE,
        {
          headers: {
            "X-Api-Key": this.apiKey
          }
        }
      );
      const balances = response.balances || [];
      return this.normalizer.normalizeBalances(balances);
    } catch (error) {
      throw mapError4(error);
    }
  }
  async setLeverage(symbol, leverage) {
    await this.rateLimiter.acquire(EXTENDED_ENDPOINTS.LEVERAGE);
    validateLeverage(leverage);
    if (!this.apiKey) {
      throw new PerpDEXError("API key required for leverage changes", "AUTHENTICATION_ERROR", this.id);
    }
    try {
      const market = this.symbolToExchange(symbol);
      await this.httpClient.post(
        EXTENDED_ENDPOINTS.LEVERAGE,
        {
          headers: {
            "X-Api-Key": this.apiKey,
            "Content-Type": "application/json"
          },
          body: {
            market,
            leverage
          }
        }
      );
    } catch (error) {
      throw mapError4(error);
    }
  }
  async setMarginMode(symbol, marginMode) {
    await this.rateLimiter.acquire(EXTENDED_ENDPOINTS.MARGIN_MODE);
    if (!this.apiKey) {
      throw new PerpDEXError("API key required for margin mode changes", "AUTHENTICATION_ERROR", this.id);
    }
    try {
      const market = this.symbolToExchange(symbol);
      await this.httpClient.post(
        EXTENDED_ENDPOINTS.MARGIN_MODE,
        {
          headers: {
            "X-Api-Key": this.apiKey,
            "Content-Type": "application/json"
          },
          body: {
            market,
            marginMode
          }
        }
      );
    } catch (error) {
      throw mapError4(error);
    }
  }
  async fetchOrderHistory(symbol, since, limit) {
    await this.rateLimiter.acquire(EXTENDED_ENDPOINTS.ORDER_HISTORY);
    if (!this.apiKey) {
      throw new PerpDEXError("API key required for order history", "AUTHENTICATION_ERROR", this.id);
    }
    try {
      const queryParams = {};
      if (symbol) {
        queryParams.market = this.symbolToExchange(symbol);
      }
      if (since) {
        queryParams.startTime = since;
      }
      if (limit) {
        queryParams.limit = limit;
      }
      let endpoint = EXTENDED_ENDPOINTS.ORDER_HISTORY;
      endpoint += this.buildQueryString(queryParams);
      const response = await this.httpClient.get(
        endpoint,
        {
          headers: {
            "X-Api-Key": this.apiKey
          }
        }
      );
      const orders = response.orders || [];
      return this.normalizer.normalizeOrders(orders);
    } catch (error) {
      throw mapError4(error);
    }
  }
  async fetchMyTrades(symbol, since, limit) {
    await this.rateLimiter.acquire(EXTENDED_ENDPOINTS.USER_TRADES);
    if (!this.apiKey) {
      throw new PerpDEXError("API key required for trade history", "AUTHENTICATION_ERROR", this.id);
    }
    try {
      const queryParams = {};
      if (symbol) {
        queryParams.market = this.symbolToExchange(symbol);
      }
      if (since) {
        queryParams.startTime = since;
      }
      if (limit) {
        queryParams.limit = limit;
      }
      let endpoint = EXTENDED_ENDPOINTS.USER_TRADES;
      endpoint += this.buildQueryString(queryParams);
      const response = await this.httpClient.get(
        endpoint,
        {
          headers: {
            "X-Api-Key": this.apiKey
          }
        }
      );
      const trades = response.trades || [];
      return this.normalizer.normalizeTrades(trades);
    } catch (error) {
      throw mapError4(error);
    }
  }
  async fetchDeposits(_currency, _since, _limit) {
    throw new PerpDEXError("fetchDeposits not supported", "NOT_SUPPORTED", this.id);
  }
  async fetchWithdrawals(_currency, _since, _limit) {
    throw new PerpDEXError("fetchWithdrawals not supported", "NOT_SUPPORTED", this.id);
  }
  async fetchUserFees() {
    await this.rateLimiter.acquire(EXTENDED_ENDPOINTS.USER_FEES);
    if (!this.apiKey) {
      throw new PerpDEXError("API key required for fee information", "AUTHENTICATION_ERROR", this.id);
    }
    try {
      const response = await this.httpClient.get(EXTENDED_ENDPOINTS.USER_FEES, {
        headers: {
          "X-Api-Key": this.apiKey
        }
      });
      return {
        maker: parseFloat(response.maker),
        taker: parseFloat(response.taker),
        volume30d: response.volume30d ? parseFloat(response.volume30d) : void 0
      };
    } catch (error) {
      throw mapError4(error);
    }
  }
  async fetchPortfolio() {
    await this.rateLimiter.acquire(EXTENDED_ENDPOINTS.PORTFOLIO);
    if (!this.apiKey) {
      throw new PerpDEXError("API key required for portfolio data", "AUTHENTICATION_ERROR", this.id);
    }
    try {
      const response = await this.httpClient.get(EXTENDED_ENDPOINTS.PORTFOLIO, {
        headers: {
          "X-Api-Key": this.apiKey
        }
      });
      return {
        totalValue: parseFloat(response.totalValue),
        dailyPnl: parseFloat(response.dailyPnl),
        dailyPnlPercentage: parseFloat(response.dailyPnlPercentage),
        timestamp: Date.now()
      };
    } catch (error) {
      throw mapError4(error);
    }
  }
  async fetchRateLimitStatus() {
    throw new PerpDEXError("fetchRateLimitStatus not supported", "NOT_SUPPORTED", this.id);
  }
  // ==================== WebSocket Methods ====================
  /**
   * Ensure WebSocket is connected and return the wrapper
   */
  async ensureWebSocketConnected() {
    if (!this.wsWrapper) {
      this.wsWrapper = new ExtendedWebSocketWrapper({
        wsUrl: this.wsUrl,
        apiKey: this.apiKey,
        reconnect: true,
        pingInterval: EXTENDED_WS_CONFIG.pingInterval,
        maxReconnectAttempts: EXTENDED_WS_CONFIG.reconnectAttempts
      });
    }
    if (!this.wsWrapper.connected) {
      await this.wsWrapper.connect();
    }
    return this.wsWrapper;
  }
  /**
   * Watch real-time order book updates
   */
  async *watchOrderBook(symbol, limit) {
    const ws = await this.ensureWebSocketConnected();
    yield* ws.watchOrderBook(symbol, limit);
  }
  /**
   * Watch real-time trade updates
   */
  async *watchTrades(symbol) {
    const ws = await this.ensureWebSocketConnected();
    yield* ws.watchTrades(symbol);
  }
  /**
   * Watch real-time ticker updates
   */
  async *watchTicker(symbol) {
    const ws = await this.ensureWebSocketConnected();
    yield* ws.watchTicker(symbol);
  }
  /**
   * Watch real-time position updates (requires API key)
   */
  async *watchPositions() {
    if (!this.apiKey) {
      throw new PerpDEXError("API key required for watching positions", "AUTHENTICATION_ERROR", this.id);
    }
    const ws = await this.ensureWebSocketConnected();
    yield* ws.watchPositions();
  }
  /**
   * Watch real-time order updates (requires API key)
   */
  async *watchOrders() {
    if (!this.apiKey) {
      throw new PerpDEXError("API key required for watching orders", "AUTHENTICATION_ERROR", this.id);
    }
    const ws = await this.ensureWebSocketConnected();
    yield* ws.watchOrders();
  }
  /**
   * Watch real-time balance updates (requires API key)
   */
  async *watchBalance() {
    if (!this.apiKey) {
      throw new PerpDEXError("API key required for watching balance", "AUTHENTICATION_ERROR", this.id);
    }
    const ws = await this.ensureWebSocketConnected();
    yield* ws.watchBalance();
  }
  /**
   * Watch real-time funding rate updates
   */
  async *watchFundingRate(symbol) {
    const ws = await this.ensureWebSocketConnected();
    yield* ws.watchFundingRate(symbol);
  }
  // ==================== Private Helper Methods ====================
  /**
   * Build query string from parameters
   */
  buildQueryString(params) {
    const filtered = Object.entries(params).filter(([_, value]) => value !== void 0 && value !== null).map(([key, value]) => `${encodeURIComponent(key)}=${encodeURIComponent(value)}`);
    return filtered.length > 0 ? `?${filtered.join("&")}` : "";
  }
};

// src/adapters/dydx/constants.ts
var DYDX_API_URLS = {
  mainnet: {
    indexer: "https://indexer.dydx.trade/v4",
    websocket: "wss://indexer.dydx.trade/v4/ws"
  },
  testnet: {
    indexer: "https://indexer.v4testnet.dydx.exchange/v4",
    websocket: "wss://indexer.v4testnet.dydx.exchange/v4/ws"
  }
};
var DYDX_MAINNET_API = DYDX_API_URLS.mainnet.indexer;
var DYDX_TESTNET_API = DYDX_API_URLS.testnet.indexer;
var DYDX_MAINNET_WS = DYDX_API_URLS.mainnet.websocket;
var DYDX_TESTNET_WS = DYDX_API_URLS.testnet.websocket;
var DYDX_RATE_LIMIT = {
  maxRequests: 100,
  windowMs: 6e4,
  // 1 minute
  weights: {
    // Public endpoints
    fetchMarkets: 1,
    fetchOrderBook: 2,
    fetchTrades: 1,
    fetchTicker: 1,
    fetchFundingRate: 1,
    fetchFundingRateHistory: 2,
    fetchOHLCV: 2,
    // Private endpoints
    fetchPositions: 2,
    fetchBalance: 2,
    createOrder: 5,
    cancelOrder: 3,
    cancelAllOrders: 10,
    fetchOpenOrders: 2,
    fetchOrderHistory: 2,
    fetchMyTrades: 2,
    setLeverage: 3
  }
};
function unifiedToDydx(symbol) {
  const parts = symbol.split("/");
  const base = parts[0];
  if (!base) {
    throw new Error(`Invalid symbol format: ${symbol}`);
  }
  return `${base}-USD`;
}
function dydxToUnified(exchangeSymbol) {
  const parts = exchangeSymbol.split("-");
  const base = parts[0];
  const quote = parts[1] || "USD";
  return `${base}/${quote}:${quote}`;
}
var DYDX_DEFAULT_PRECISION = {
  price: 6,
  amount: 4
};
var DYDX_FUNDING_INTERVAL_HOURS = 1;
var DYDX_DEFAULT_SUBACCOUNT_NUMBER = 0;
var DYDX_ERROR_MESSAGES = {
  "insufficient funds": "INSUFFICIENT_MARGIN",
  "insufficient margin": "INSUFFICIENT_MARGIN",
  "invalid signature": "INVALID_SIGNATURE",
  "order would immediately match": "ORDER_WOULD_MATCH",
  "position does not exist": "POSITION_NOT_FOUND",
  "order not found": "ORDER_NOT_FOUND",
  "order does not exist": "ORDER_NOT_FOUND",
  "rate limit exceeded": "RATE_LIMIT_EXCEEDED",
  "invalid order size": "INVALID_ORDER_SIZE",
  "price out of bounds": "PRICE_OUT_OF_BOUNDS",
  "market not found": "MARKET_NOT_FOUND",
  "subaccount not found": "SUBACCOUNT_NOT_FOUND",
  "unauthorized": "UNAUTHORIZED"
};

// src/adapters/dydx/DydxAuth.ts
var DydxAuth = class {
  mnemonic;
  privateKey;
  subaccountNumber;
  testnet;
  address;
  initialized = false;
  constructor(config) {
    this.mnemonic = config.mnemonic;
    this.privateKey = config.privateKey;
    this.subaccountNumber = config.subaccountNumber ?? DYDX_DEFAULT_SUBACCOUNT_NUMBER;
    this.testnet = config.testnet ?? false;
    if (!this.mnemonic && !this.privateKey) {
      throw new Error("Either mnemonic or privateKey must be provided");
    }
  }
  /**
   * Initialize the auth strategy
   *
   * Derives the dYdX address from the mnemonic or private key.
   * This is called lazily when the address is first needed.
   */
  async initialize() {
    if (this.initialized) {
      return;
    }
    try {
      if (this.mnemonic) {
        this.address = await this.deriveAddressFromMnemonic(this.mnemonic);
      } else if (this.privateKey) {
        this.address = await this.deriveAddressFromPrivateKey(this.privateKey);
      }
      this.initialized = true;
    } catch (error) {
      throw new Error(`Failed to initialize dYdX auth: ${error instanceof Error ? error.message : "Unknown error"}`);
    }
  }
  /**
   * Derive dYdX address from mnemonic
   *
   * Note: This is a simplified implementation. In production,
   * use @cosmjs/proto-signing or @dydxprotocol/v4-client-js
   */
  async deriveAddressFromMnemonic(mnemonic) {
    const words = mnemonic.trim().split(/\s+/);
    if (words.length !== 24 && words.length !== 12) {
      throw new Error("Invalid mnemonic: must be 12 or 24 words");
    }
    const hash3 = this.simpleHash(mnemonic);
    return `dydx${hash3.slice(0, 38)}`;
  }
  /**
   * Derive dYdX address from private key
   */
  async deriveAddressFromPrivateKey(privateKey) {
    const cleanKey = privateKey.startsWith("0x") ? privateKey.slice(2) : privateKey;
    if (cleanKey.length !== 64) {
      throw new Error("Invalid private key: must be 32 bytes (64 hex characters)");
    }
    const hash3 = this.simpleHash(cleanKey);
    return `dydx${hash3.slice(0, 38)}`;
  }
  /**
   * Simple hash function for placeholder address generation
   * Real implementation should use proper cryptographic derivation
   */
  simpleHash(input) {
    let hash3 = 0;
    for (let i = 0; i < input.length; i++) {
      const char = input.charCodeAt(i);
      hash3 = (hash3 << 5) - hash3 + char;
      hash3 = hash3 & hash3;
    }
    const hexChars = "0123456789abcdef";
    let result = "";
    for (let i = 0; i < 40; i++) {
      hash3 = (hash3 << 5) - hash3 + i;
      hash3 = hash3 & hash3;
      result += hexChars[Math.abs(hash3) % 16];
    }
    return result;
  }
  /**
   * Sign a request
   *
   * For dYdX Indexer API, most requests don't require signing.
   * Trading operations use the official SDK's internal signing.
   */
  async sign(request) {
    await this.initialize();
    return {
      ...request,
      headers: this.getHeaders()
    };
  }
  /**
   * Get authentication headers
   *
   * For Indexer API, only Content-Type is needed.
   * Trading operations use SDK-managed headers.
   */
  getHeaders() {
    return {
      "Content-Type": "application/json"
    };
  }
  /**
   * Refresh is not needed for dYdX Indexer API
   */
  async refresh() {
  }
  /**
   * Get the dYdX address
   *
   * @returns The derived dYdX address (bech32 format)
   */
  async getAddress() {
    await this.initialize();
    return this.address;
  }
  /**
   * Get the subaccount number
   *
   * @returns The configured subaccount number
   */
  getSubaccountNumber() {
    return this.subaccountNumber;
  }
  /**
   * Get subaccount ID (address + subaccount number)
   *
   * dYdX uses the format: {address}/{subaccountNumber}
   */
  async getSubaccountId() {
    const address = await this.getAddress();
    return `${address}/${this.subaccountNumber}`;
  }
  /**
   * Check if credentials are valid
   *
   * For dYdX, this validates that the mnemonic/private key
   * can derive a valid address.
   */
  async verify() {
    try {
      await this.initialize();
      return !!this.address;
    } catch {
      return false;
    }
  }
  /**
   * Check if this is testnet configuration
   */
  isTestnet() {
    return this.testnet;
  }
  /**
   * Get the mnemonic (if available)
   *
   * Warning: Handle with care, this is sensitive data
   */
  getMnemonic() {
    return this.mnemonic;
  }
  /**
   * Check if auth has mnemonic (for trading operations)
   */
  hasMnemonic() {
    return !!this.mnemonic;
  }
};

// src/adapters/dydx/DydxNormalizer.ts
var DydxNormalizer = class {
  // ===========================================================================
  // Market Normalization
  // ===========================================================================
  /**
   * Normalize dYdX market to unified format
   *
   * @param market - dYdX perpetual market data
   * @returns Unified market
   */
  normalizeMarket(market) {
    const unifiedSymbol = dydxToUnified(market.ticker);
    const [base = "", rest = ""] = unifiedSymbol.split("/");
    const [quote = "", settle = ""] = rest.split(":");
    const stepSize = parseFloat(market.stepSize);
    const amountPrecision = stepSize > 0 ? Math.abs(Math.log10(stepSize)) : DYDX_DEFAULT_PRECISION.amount;
    const tickSize = parseFloat(market.tickSize);
    const pricePrecision = tickSize > 0 ? Math.abs(Math.log10(tickSize)) : DYDX_DEFAULT_PRECISION.price;
    return {
      id: market.ticker,
      symbol: unifiedSymbol,
      base,
      quote,
      settle,
      active: market.status === "ACTIVE",
      minAmount: stepSize,
      pricePrecision: Math.round(pricePrecision),
      amountPrecision: Math.round(amountPrecision),
      priceTickSize: tickSize,
      amountStepSize: stepSize,
      makerFee: 1e-4,
      // 0.01% - dYdX v4 default
      takerFee: 5e-4,
      // 0.05% - dYdX v4 default
      maxLeverage: 20,
      // Default max leverage
      fundingIntervalHours: DYDX_FUNDING_INTERVAL_HOURS,
      info: {
        oraclePrice: market.oraclePrice,
        openInterest: market.openInterest,
        volume24H: market.volume24H,
        initialMarginFraction: market.initialMarginFraction,
        maintenanceMarginFraction: market.maintenanceMarginFraction
      }
    };
  }
  /**
   * Normalize multiple markets
   *
   * @param markets - Record of dYdX markets
   * @returns Array of unified markets
   */
  normalizeMarkets(markets) {
    return Object.values(markets).map((market) => this.normalizeMarket(market));
  }
  // ===========================================================================
  // Order Normalization
  // ===========================================================================
  /**
   * Normalize dYdX order to unified format
   *
   * @param order - dYdX order
   * @returns Unified order
   */
  normalizeOrder(order) {
    const unifiedSymbol = dydxToUnified(order.ticker);
    const size = parseFloat(order.size);
    const filled = parseFloat(order.totalFilled);
    const remaining = size - filled;
    return {
      id: order.id,
      symbol: unifiedSymbol,
      type: this.normalizeOrderType(order.type),
      side: order.side === "BUY" ? "buy" : "sell",
      amount: size,
      price: order.price ? parseFloat(order.price) : void 0,
      stopPrice: order.triggerPrice ? parseFloat(order.triggerPrice) : void 0,
      status: this.normalizeOrderStatus(order.status),
      filled,
      remaining,
      reduceOnly: order.reduceOnly,
      postOnly: order.postOnly,
      clientOrderId: order.clientId,
      timestamp: order.updatedAt ? new Date(order.updatedAt).getTime() : Date.now(),
      timeInForce: this.normalizeTimeInForce(order.timeInForce),
      info: {
        subaccountId: order.subaccountId,
        clobPairId: order.clobPairId,
        goodTilBlock: order.goodTilBlock,
        goodTilBlockTime: order.goodTilBlockTime,
        orderFlags: order.orderFlags,
        removalReason: order.removalReason
      }
    };
  }
  /**
   * Normalize multiple orders
   *
   * @param orders - Array of dYdX orders
   * @returns Array of unified orders
   */
  normalizeOrders(orders) {
    return orders.map((order) => this.normalizeOrder(order));
  }
  /**
   * Normalize dYdX order type to unified format
   */
  normalizeOrderType(type) {
    switch (type) {
      case "MARKET":
        return "market";
      case "STOP_LIMIT":
        return "stopLimit";
      case "STOP_MARKET":
        return "stopMarket";
      case "LIMIT":
      default:
        return "limit";
    }
  }
  /**
   * Normalize dYdX order status to unified format
   */
  normalizeOrderStatus(status) {
    switch (status) {
      case "OPEN":
      case "PENDING":
      case "UNTRIGGERED":
        return "open";
      case "FILLED":
        return "filled";
      case "CANCELED":
      case "BEST_EFFORT_CANCELED":
        return "canceled";
      default:
        return "open";
    }
  }
  /**
   * Normalize time in force
   */
  normalizeTimeInForce(tif) {
    switch (tif) {
      case "IOC":
        return "IOC";
      case "FOK":
        return "FOK";
      case "GTT":
      default:
        return "GTC";
    }
  }
  // ===========================================================================
  // Position Normalization
  // ===========================================================================
  /**
   * Normalize dYdX position to unified format
   *
   * @param position - dYdX perpetual position
   * @param oraclePrice - Current oracle price for the market
   * @returns Unified position
   */
  normalizePosition(position, oraclePrice = 0) {
    const unifiedSymbol = dydxToUnified(position.market);
    const size = Math.abs(parseFloat(position.size));
    const entryPrice = parseFloat(position.entryPrice);
    const unrealizedPnl = parseFloat(position.unrealizedPnl);
    const realizedPnl = parseFloat(position.realizedPnl);
    const positionValue = size * (oraclePrice || entryPrice);
    const leverage = positionValue > 0 ? positionValue / (positionValue + unrealizedPnl) : 1;
    return {
      symbol: unifiedSymbol,
      side: position.side === "LONG" ? "long" : "short",
      size,
      entryPrice,
      markPrice: oraclePrice || entryPrice,
      liquidationPrice: 0,
      // Needs to be calculated based on account state
      unrealizedPnl,
      realizedPnl,
      leverage: Math.round(leverage * 10) / 10,
      marginMode: "cross",
      // dYdX v4 uses cross-margin
      margin: 0,
      // Needs account equity data
      maintenanceMargin: 0,
      marginRatio: 0,
      timestamp: new Date(position.createdAt).getTime(),
      info: {
        status: position.status,
        maxSize: position.maxSize,
        netFunding: position.netFunding,
        sumOpen: position.sumOpen,
        sumClose: position.sumClose,
        subaccountNumber: position.subaccountNumber
      }
    };
  }
  /**
   * Normalize multiple positions
   *
   * @param positions - Record of dYdX positions
   * @param oraclePrices - Map of oracle prices by ticker
   * @returns Array of unified positions
   */
  normalizePositions(positions, oraclePrices = {}) {
    return Object.values(positions).filter((pos) => parseFloat(pos.size) !== 0).map((pos) => this.normalizePosition(pos, oraclePrices[pos.market] || 0));
  }
  // ===========================================================================
  // Order Book Normalization
  // ===========================================================================
  /**
   * Normalize dYdX order book to unified format
   *
   * @param orderBook - dYdX order book response
   * @param ticker - Market ticker
   * @returns Unified order book
   */
  normalizeOrderBook(orderBook, ticker) {
    const unifiedSymbol = dydxToUnified(ticker);
    const bids = orderBook.bids.map((level) => [
      parseFloat(level.price),
      parseFloat(level.size)
    ]);
    const asks = orderBook.asks.map((level) => [
      parseFloat(level.price),
      parseFloat(level.size)
    ]);
    return {
      symbol: unifiedSymbol,
      timestamp: Date.now(),
      bids,
      asks,
      exchange: "dydx"
    };
  }
  // ===========================================================================
  // Trade Normalization
  // ===========================================================================
  /**
   * Normalize dYdX trade to unified format
   *
   * @param trade - dYdX trade
   * @param ticker - Market ticker
   * @returns Unified trade
   */
  normalizeTrade(trade, ticker) {
    const unifiedSymbol = dydxToUnified(ticker);
    const price = parseFloat(trade.price);
    const amount = parseFloat(trade.size);
    return {
      id: trade.id,
      symbol: unifiedSymbol,
      side: trade.side === "BUY" ? "buy" : "sell",
      price,
      amount,
      cost: price * amount,
      timestamp: new Date(trade.createdAt).getTime(),
      info: {
        type: trade.type,
        createdAtHeight: trade.createdAtHeight
      }
    };
  }
  /**
   * Normalize multiple trades
   *
   * @param trades - Array of dYdX trades
   * @param ticker - Market ticker
   * @returns Array of unified trades
   */
  normalizeTrades(trades, ticker) {
    return trades.map((trade) => this.normalizeTrade(trade, ticker));
  }
  /**
   * Normalize dYdX fill to unified trade format
   *
   * @param fill - dYdX fill
   * @returns Unified trade
   */
  normalizeFill(fill) {
    const unifiedSymbol = dydxToUnified(fill.market);
    const price = parseFloat(fill.price);
    const amount = parseFloat(fill.size);
    return {
      id: fill.id,
      symbol: unifiedSymbol,
      orderId: fill.orderId,
      side: fill.side === "BUY" ? "buy" : "sell",
      price,
      amount,
      cost: price * amount,
      timestamp: new Date(fill.createdAt).getTime(),
      info: {
        liquidity: fill.liquidity,
        type: fill.type,
        fee: fill.fee,
        subaccountNumber: fill.subaccountNumber
      }
    };
  }
  /**
   * Normalize multiple fills
   *
   * @param fills - Array of dYdX fills
   * @returns Array of unified trades
   */
  normalizeFills(fills) {
    return fills.map((fill) => this.normalizeFill(fill));
  }
  // ===========================================================================
  // Funding Rate Normalization
  // ===========================================================================
  /**
   * Normalize dYdX funding rate to unified format
   *
   * @param funding - dYdX historical funding data
   * @param oraclePrice - Current oracle price
   * @returns Unified funding rate
   */
  normalizeFundingRate(funding, oraclePrice = 0) {
    const unifiedSymbol = dydxToUnified(funding.ticker);
    const fundingTimestamp = new Date(funding.effectiveAt).getTime();
    return {
      symbol: unifiedSymbol,
      fundingRate: parseFloat(funding.rate),
      fundingTimestamp,
      nextFundingTimestamp: fundingTimestamp + DYDX_FUNDING_INTERVAL_HOURS * 3600 * 1e3,
      markPrice: oraclePrice || parseFloat(funding.price),
      indexPrice: parseFloat(funding.price),
      fundingIntervalHours: DYDX_FUNDING_INTERVAL_HOURS,
      info: {
        price: funding.price,
        effectiveAtHeight: funding.effectiveAtHeight
      }
    };
  }
  /**
   * Normalize multiple funding rates
   *
   * @param fundingHistory - Array of dYdX funding records
   * @param oraclePrice - Current oracle price
   * @returns Array of unified funding rates
   */
  normalizeFundingHistory(fundingHistory, oraclePrice = 0) {
    return fundingHistory.map((f) => this.normalizeFundingRate(f, oraclePrice));
  }
  // ===========================================================================
  // Balance Normalization
  // ===========================================================================
  /**
   * Normalize dYdX subaccount to unified balance format
   *
   * @param subaccount - dYdX subaccount data
   * @returns Array of unified balances
   */
  normalizeBalance(subaccount) {
    const equity = parseFloat(subaccount.equity);
    const freeCollateral = parseFloat(subaccount.freeCollateral);
    const used = equity - freeCollateral;
    return [
      {
        currency: "USDC",
        total: equity,
        free: freeCollateral,
        used: used > 0 ? used : 0,
        usdValue: equity,
        info: {
          pendingDeposits: subaccount.pendingDeposits,
          pendingWithdrawals: subaccount.pendingWithdrawals,
          marginEnabled: subaccount.marginEnabled,
          subaccountNumber: subaccount.subaccountNumber
        }
      }
    ];
  }
  // ===========================================================================
  // Ticker Normalization
  // ===========================================================================
  /**
   * Normalize market data to ticker format
   *
   * @param market - dYdX perpetual market data
   * @returns Unified ticker
   */
  normalizeTicker(market) {
    const unifiedSymbol = dydxToUnified(market.ticker);
    const oraclePrice = parseFloat(market.oraclePrice);
    const priceChange = parseFloat(market.priceChange24H);
    const volume = parseFloat(market.volume24H);
    const openPrice = priceChange !== 0 ? oraclePrice / (1 + priceChange) : oraclePrice;
    return {
      symbol: unifiedSymbol,
      last: oraclePrice,
      bid: oraclePrice,
      // dYdX doesn't provide BBO in market data
      ask: oraclePrice,
      high: oraclePrice,
      // Not provided in basic market data
      low: oraclePrice,
      open: openPrice,
      close: oraclePrice,
      change: oraclePrice - openPrice,
      percentage: priceChange * 100,
      baseVolume: volume / oraclePrice,
      // Convert USD volume to base
      quoteVolume: volume,
      timestamp: Date.now(),
      info: {
        openInterest: market.openInterest,
        nextFundingRate: market.nextFundingRate,
        nextFundingAt: market.nextFundingAt,
        trades24H: market.trades24H
      }
    };
  }
  // ===========================================================================
  // OHLCV Normalization
  // ===========================================================================
  /**
   * Normalize dYdX candle to OHLCV format
   *
   * @param candle - dYdX candle data
   * @returns OHLCV tuple
   */
  normalizeCandle(candle) {
    return [
      new Date(candle.startedAt).getTime(),
      parseFloat(candle.open),
      parseFloat(candle.high),
      parseFloat(candle.low),
      parseFloat(candle.close),
      parseFloat(candle.baseTokenVolume)
    ];
  }
  /**
   * Normalize multiple candles
   *
   * @param candles - Array of dYdX candles
   * @returns Array of OHLCV tuples
   */
  normalizeCandles(candles) {
    return candles.map((candle) => this.normalizeCandle(candle));
  }
};

// src/adapters/dydx/error-codes.ts
function mapDydxError(error) {
  if (error instanceof PerpDEXError) {
    return error;
  }
  if (error instanceof Error) {
    const message = error.message.toLowerCase();
    for (const [pattern, code] of Object.entries(DYDX_ERROR_MESSAGES)) {
      if (message.includes(pattern)) {
        switch (code) {
          case "INSUFFICIENT_MARGIN":
            return new InsufficientMarginError(error.message, code, "dydx", error);
          case "INVALID_SIGNATURE":
            return new InvalidSignatureError(error.message, code, "dydx", error);
          case "ORDER_WOULD_MATCH":
            return new InvalidOrderError(error.message, code, "dydx", error);
          case "POSITION_NOT_FOUND":
            return new PositionNotFoundError(error.message, code, "dydx", error);
          case "ORDER_NOT_FOUND":
            return new OrderNotFoundError(error.message, code, "dydx", error);
          case "RATE_LIMIT_EXCEEDED":
            return new RateLimitError(error.message, code, "dydx", void 0, error);
          case "INVALID_ORDER_SIZE":
            return new InvalidOrderError(error.message, code, "dydx", error);
          case "PRICE_OUT_OF_BOUNDS":
            return new InvalidOrderError(error.message, code, "dydx", error);
          case "MARKET_NOT_FOUND":
            return new InvalidSymbolError(error.message, code, "dydx", error);
          case "SUBACCOUNT_NOT_FOUND":
            return new PerpDEXError(error.message, code, "dydx", error);
          case "UNAUTHORIZED":
            return new InvalidSignatureError(error.message, code, "dydx", error);
        }
      }
    }
    if (message.includes("429")) {
      return new RateLimitError("Rate limit exceeded", "RATE_LIMIT", "dydx", void 0, error);
    }
    if (message.includes("503") || message.includes("502") || message.includes("504")) {
      return new ExchangeUnavailableError(
        "Exchange temporarily unavailable",
        "EXCHANGE_DOWN",
        "dydx",
        error
      );
    }
    if (message.includes("401") || message.includes("403")) {
      return new InvalidSignatureError(
        "Authentication failed",
        "UNAUTHORIZED",
        "dydx",
        error
      );
    }
    if (message.includes("404")) {
      return new PerpDEXError("Resource not found", "NOT_FOUND", "dydx", error);
    }
    if (message.includes("400")) {
      return new InvalidOrderError("Bad request", "BAD_REQUEST", "dydx", error);
    }
  }
  return new ExchangeUnavailableError(
    "Unknown exchange error",
    "UNKNOWN_ERROR",
    "dydx",
    error
  );
}

// src/adapters/dydx/utils.ts
function mapTimeframeToDydx(timeframe) {
  const mapping = {
    "1m": "1MIN",
    "5m": "5MINS",
    "15m": "15MINS",
    "30m": "30MINS",
    "1h": "1HOUR",
    "4h": "4HOURS",
    "1d": "1DAY"
  };
  return mapping[timeframe] || "1HOUR";
}
function getDefaultOHLCVDuration(timeframe) {
  const durationMap = {
    "1m": 24 * 60 * 60 * 1e3,
    // 24 hours of 1m candles
    "5m": 5 * 24 * 60 * 60 * 1e3,
    // 5 days
    "15m": 7 * 24 * 60 * 60 * 1e3,
    // 7 days
    "30m": 14 * 24 * 60 * 60 * 1e3,
    // 14 days
    "1h": 30 * 24 * 60 * 60 * 1e3,
    // 30 days
    "4h": 90 * 24 * 60 * 60 * 1e3,
    // 90 days
    "1d": 365 * 24 * 60 * 60 * 1e3
    // 1 year
  };
  return durationMap[timeframe] || 30 * 24 * 60 * 60 * 1e3;
}
function buildQueryString(params) {
  const entries = Object.entries(params).filter(([_, value]) => value !== void 0).map(([key, value]) => `${encodeURIComponent(key)}=${encodeURIComponent(String(value))}`);
  return entries.join("&");
}
function buildUrl(baseUrl, path, params) {
  const url = `${baseUrl}${path}`;
  if (!params || Object.keys(params).length === 0) {
    return url;
  }
  const queryString = buildQueryString(params);
  return queryString ? `${url}?${queryString}` : url;
}

// src/adapters/dydx/DydxAdapter.ts
var DydxAdapter = class extends BaseAdapter {
  id = "dydx";
  name = "dYdX v4";
  has = {
    // Market Data
    fetchMarkets: true,
    fetchTicker: true,
    fetchOrderBook: true,
    fetchTrades: true,
    fetchOHLCV: true,
    fetchFundingRate: true,
    fetchFundingRateHistory: true,
    // Trading
    createOrder: true,
    cancelOrder: true,
    cancelAllOrders: true,
    createBatchOrders: false,
    cancelBatchOrders: "emulated",
    editOrder: false,
    // Order Query
    fetchOpenOrders: true,
    fetchOrder: false,
    // Account History
    fetchOrderHistory: true,
    fetchMyTrades: true,
    fetchDeposits: false,
    fetchWithdrawals: false,
    // Positions & Balance
    fetchPositions: true,
    fetchBalance: true,
    setLeverage: false,
    // dYdX v4 uses cross-margin
    setMarginMode: false,
    // WebSocket
    watchOrderBook: true,
    watchTrades: true,
    watchTicker: true,
    watchPositions: true,
    watchOrders: true,
    watchBalance: true,
    watchFundingRate: false,
    watchOHLCV: true,
    // Advanced
    twapOrders: false,
    vaultTrading: false,
    // Additional Info
    fetchUserFees: false,
    fetchPortfolio: false,
    fetchRateLimitStatus: false
  };
  apiUrl;
  auth;
  rateLimiter;
  normalizer;
  subaccountNumber;
  // Market cache for oracle prices
  marketDataCache = /* @__PURE__ */ new Map();
  marketDataCacheTTL = 6e4;
  // 1 minute
  constructor(config = {}) {
    super(config);
    this.apiUrl = config.testnet ? DYDX_TESTNET_API : DYDX_MAINNET_API;
    this.normalizer = new DydxNormalizer();
    this.rateLimiter = new RateLimiter({
      maxTokens: config.rateLimit?.maxRequests ?? DYDX_RATE_LIMIT.maxRequests,
      windowMs: config.rateLimit?.windowMs ?? DYDX_RATE_LIMIT.windowMs,
      weights: config.rateLimit?.weights ?? DYDX_RATE_LIMIT.weights,
      exchange: "dydx"
    });
    this.subaccountNumber = config.subaccountNumber ?? DYDX_DEFAULT_SUBACCOUNT_NUMBER;
    if (config.mnemonic || config.privateKey) {
      this.auth = new DydxAuth({
        mnemonic: config.mnemonic,
        privateKey: config.privateKey,
        subaccountNumber: this.subaccountNumber,
        testnet: config.testnet
      });
    }
  }
  // ===========================================================================
  // Connection Management
  // ===========================================================================
  async initialize() {
    if (this._isReady) {
      return;
    }
    if (this.auth) {
      const isValid2 = await this.auth.verify();
      if (!isValid2) {
        throw new Error("Failed to verify dYdX credentials");
      }
      this.debug("Authentication verified", { subaccountNumber: this.subaccountNumber });
    }
    try {
      await this.fetchMarkets();
      this.debug("Markets loaded successfully");
    } catch (error) {
      throw mapDydxError(error);
    }
    this._isReady = true;
    this.debug("Adapter initialized");
  }
  async disconnect() {
    this.marketDataCache.clear();
    await super.disconnect();
    this.debug("Adapter disconnected");
  }
  // ===========================================================================
  // Market Data (Public)
  // ===========================================================================
  async fetchMarkets(params) {
    await this.rateLimiter.acquire("fetchMarkets");
    try {
      const response = await this.request(
        "GET",
        `${this.apiUrl}/perpetualMarkets`
      );
      const markets = this.normalizer.normalizeMarkets(response.markets);
      for (const [ticker, market] of Object.entries(response.markets)) {
        this.marketDataCache.set(ticker, {
          oraclePrice: parseFloat(market.oraclePrice),
          timestamp: Date.now()
        });
      }
      if (params?.active !== void 0) {
        return markets.filter((m) => m.active === params.active);
      }
      return markets;
    } catch (error) {
      throw mapDydxError(error);
    }
  }
  async fetchTicker(symbol) {
    await this.rateLimiter.acquire("fetchTicker");
    try {
      const response = await this.request(
        "GET",
        `${this.apiUrl}/perpetualMarkets`
      );
      const exchangeSymbol = this.symbolToExchange(symbol);
      const market = response.markets[exchangeSymbol];
      if (!market) {
        throw new Error(`Market not found: ${symbol}`);
      }
      this.marketDataCache.set(exchangeSymbol, {
        oraclePrice: parseFloat(market.oraclePrice),
        timestamp: Date.now()
      });
      return this.normalizer.normalizeTicker(market);
    } catch (error) {
      throw mapDydxError(error);
    }
  }
  async fetchOrderBook(symbol, _params) {
    await this.rateLimiter.acquire("fetchOrderBook");
    try {
      const exchangeSymbol = this.symbolToExchange(symbol);
      const response = await this.request(
        "GET",
        `${this.apiUrl}/orderbooks/perpetualMarket/${exchangeSymbol}`
      );
      return this.normalizer.normalizeOrderBook(response, exchangeSymbol);
    } catch (error) {
      throw mapDydxError(error);
    }
  }
  async fetchTrades(symbol, params) {
    await this.rateLimiter.acquire("fetchTrades");
    try {
      const exchangeSymbol = this.symbolToExchange(symbol);
      const queryParams = {
        limit: params?.limit ?? 100
      };
      if (params?.since) {
        queryParams.createdBeforeOrAtHeight = void 0;
      }
      const url = buildUrl(
        this.apiUrl,
        "/trades",
        { market: exchangeSymbol, ...queryParams }
      );
      const response = await this.request("GET", url);
      return this.normalizer.normalizeTrades(response.trades, exchangeSymbol);
    } catch (error) {
      throw mapDydxError(error);
    }
  }
  async fetchFundingRate(symbol) {
    await this.rateLimiter.acquire("fetchFundingRate");
    try {
      const exchangeSymbol = this.symbolToExchange(symbol);
      const marketsResponse = await this.request(
        "GET",
        `${this.apiUrl}/perpetualMarkets`
      );
      const market = marketsResponse.markets[exchangeSymbol];
      if (!market) {
        throw new Error(`Market not found: ${symbol}`);
      }
      const oraclePrice = parseFloat(market.oraclePrice);
      const fundingTimestamp = new Date(market.nextFundingAt).getTime();
      return {
        symbol,
        fundingRate: parseFloat(market.nextFundingRate),
        fundingTimestamp,
        nextFundingTimestamp: fundingTimestamp + 3600 * 1e3,
        // +1 hour
        markPrice: oraclePrice,
        indexPrice: oraclePrice,
        fundingIntervalHours: 1,
        info: {
          nextFundingAt: market.nextFundingAt
        }
      };
    } catch (error) {
      throw mapDydxError(error);
    }
  }
  async fetchFundingRateHistory(symbol, since, limit) {
    await this.rateLimiter.acquire("fetchFundingRateHistory");
    try {
      const exchangeSymbol = this.symbolToExchange(symbol);
      const queryParams = {
        limit: limit ?? 100
      };
      if (since) {
        queryParams.effectiveBeforeOrAt = new Date(since).toISOString();
      }
      const url = buildUrl(
        this.apiUrl,
        "/historicalFunding",
        { market: exchangeSymbol, ...queryParams }
      );
      const response = await this.request("GET", url);
      const oraclePrice = await this.getOraclePrice(exchangeSymbol);
      return this.normalizer.normalizeFundingHistory(response.historicalFunding, oraclePrice);
    } catch (error) {
      throw mapDydxError(error);
    }
  }
  async fetchOHLCV(symbol, timeframe = "1h", params) {
    await this.rateLimiter.acquire("fetchOHLCV");
    try {
      const exchangeSymbol = this.symbolToExchange(symbol);
      const resolution = mapTimeframeToDydx(timeframe);
      const now = Date.now();
      const defaultDuration = getDefaultOHLCVDuration(timeframe);
      const fromISO = new Date(params?.since ?? now - defaultDuration).toISOString();
      const toISO = params?.until ? new Date(params.until).toISOString() : new Date(now).toISOString();
      const queryParams = {
        resolution,
        fromISO,
        toISO,
        limit: params?.limit ?? 100
      };
      const url = buildUrl(
        this.apiUrl,
        "/candles",
        { market: exchangeSymbol, ...queryParams }
      );
      const response = await this.request("GET", url);
      return this.normalizer.normalizeCandles(response.candles);
    } catch (error) {
      throw mapDydxError(error);
    }
  }
  // ===========================================================================
  // Trading (Private)
  // ===========================================================================
  async createOrder(_request) {
    this.ensureInitialized();
    if (!this.auth) {
      throw new Error("Authentication required for trading. Provide mnemonic or privateKey.");
    }
    await this.rateLimiter.acquire("createOrder");
    try {
      throw new Error(
        "Trading operations require the official @dydxprotocol/v4-client-js SDK. This adapter provides read-only access to the Indexer API. Please integrate the official SDK for order placement."
      );
    } catch (error) {
      throw mapDydxError(error);
    }
  }
  async cancelOrder(_orderId, _symbol) {
    this.ensureInitialized();
    if (!this.auth) {
      throw new Error("Authentication required for trading");
    }
    await this.rateLimiter.acquire("cancelOrder");
    try {
      throw new Error(
        "Trading operations require the official @dydxprotocol/v4-client-js SDK. This adapter provides read-only access to the Indexer API."
      );
    } catch (error) {
      throw mapDydxError(error);
    }
  }
  async cancelAllOrders(_symbol) {
    this.ensureInitialized();
    if (!this.auth) {
      throw new Error("Authentication required for trading");
    }
    await this.rateLimiter.acquire("cancelAllOrders");
    try {
      throw new Error(
        "Trading operations require the official @dydxprotocol/v4-client-js SDK. This adapter provides read-only access to the Indexer API."
      );
    } catch (error) {
      throw mapDydxError(error);
    }
  }
  // ===========================================================================
  // Account Data (Private)
  // ===========================================================================
  async fetchPositions(symbols) {
    this.ensureInitialized();
    if (!this.auth) {
      throw new Error("Authentication required");
    }
    await this.rateLimiter.acquire("fetchPositions");
    try {
      const address = await this.auth.getAddress();
      const response = await this.request(
        "GET",
        `${this.apiUrl}/addresses/${address}/subaccountNumber/${this.subaccountNumber}`
      );
      const oraclePrices = {};
      for (const ticker of Object.keys(response.subaccount.openPerpetualPositions)) {
        oraclePrices[ticker] = await this.getOraclePrice(ticker);
      }
      let positions = this.normalizer.normalizePositions(
        response.subaccount.openPerpetualPositions,
        oraclePrices
      );
      if (symbols && symbols.length > 0) {
        positions = positions.filter((p) => symbols.includes(p.symbol));
      }
      return positions;
    } catch (error) {
      throw mapDydxError(error);
    }
  }
  async fetchBalance() {
    this.ensureInitialized();
    if (!this.auth) {
      throw new Error("Authentication required");
    }
    await this.rateLimiter.acquire("fetchBalance");
    try {
      const address = await this.auth.getAddress();
      const response = await this.request(
        "GET",
        `${this.apiUrl}/addresses/${address}/subaccountNumber/${this.subaccountNumber}`
      );
      return this.normalizer.normalizeBalance(response.subaccount);
    } catch (error) {
      throw mapDydxError(error);
    }
  }
  async setLeverage(_symbol, _leverage) {
    this.debug("setLeverage: dYdX v4 uses cross-margin mode without per-symbol leverage");
    throw new Error("dYdX v4 uses cross-margin mode. Leverage is automatically calculated based on account equity.");
  }
  // ===========================================================================
  // Order History
  // ===========================================================================
  async fetchOrderHistory(symbol, since, limit) {
    this.ensureInitialized();
    if (!this.auth) {
      throw new Error("Authentication required");
    }
    await this.rateLimiter.acquire("fetchOrderHistory");
    try {
      const address = await this.auth.getAddress();
      const queryParams = {
        limit: limit ?? 100
      };
      if (symbol) {
        queryParams.ticker = this.symbolToExchange(symbol);
      }
      const url = buildUrl(
        this.apiUrl,
        `/addresses/${address}/subaccountNumber/${this.subaccountNumber}/orders`,
        queryParams
      );
      const response = await this.request("GET", url);
      let orders = this.normalizer.normalizeOrders(response);
      if (since) {
        orders = orders.filter((order) => order.timestamp >= since);
      }
      orders.sort((a, b) => b.timestamp - a.timestamp);
      return orders;
    } catch (error) {
      throw mapDydxError(error);
    }
  }
  async fetchMyTrades(symbol, since, limit) {
    this.ensureInitialized();
    if (!this.auth) {
      throw new Error("Authentication required");
    }
    await this.rateLimiter.acquire("fetchMyTrades");
    try {
      const address = await this.auth.getAddress();
      const queryParams = {
        limit: limit ?? 100
      };
      if (symbol) {
        queryParams.market = this.symbolToExchange(symbol);
      }
      const url = buildUrl(
        this.apiUrl,
        `/addresses/${address}/subaccountNumber/${this.subaccountNumber}/fills`,
        queryParams
      );
      const response = await this.request("GET", url);
      let trades = this.normalizer.normalizeFills(response.fills);
      if (since) {
        trades = trades.filter((trade) => trade.timestamp >= since);
      }
      trades.sort((a, b) => b.timestamp - a.timestamp);
      return trades;
    } catch (error) {
      throw mapDydxError(error);
    }
  }
  /**
   * Fetch open orders
   *
   * @param symbol - Optional symbol to filter orders
   * @returns Array of open orders
   */
  async fetchOpenOrders(symbol) {
    this.ensureInitialized();
    if (!this.auth) {
      throw new Error("Authentication required");
    }
    await this.rateLimiter.acquire("fetchOpenOrders");
    try {
      const address = await this.auth.getAddress();
      const queryParams = {
        status: "OPEN"
      };
      if (symbol) {
        queryParams.ticker = this.symbolToExchange(symbol);
      }
      const url = buildUrl(
        this.apiUrl,
        `/addresses/${address}/subaccountNumber/${this.subaccountNumber}/orders`,
        queryParams
      );
      const response = await this.request("GET", url);
      return this.normalizer.normalizeOrders(response);
    } catch (error) {
      throw mapDydxError(error);
    }
  }
  // ===========================================================================
  // WebSocket Streams (Placeholder implementations)
  // ===========================================================================
  async *watchOrderBook(_symbol, _limit) {
    this.ensureInitialized();
    throw new Error("WebSocket streams require additional implementation. Use fetchOrderBook for polling.");
    yield {};
  }
  async *watchTrades(_symbol) {
    this.ensureInitialized();
    throw new Error("WebSocket streams require additional implementation. Use fetchTrades for polling.");
    yield {};
  }
  async *watchTicker(_symbol) {
    this.ensureInitialized();
    throw new Error("WebSocket streams require additional implementation. Use fetchTicker for polling.");
    yield {};
  }
  async *watchPositions() {
    this.ensureInitialized();
    throw new Error("WebSocket streams require additional implementation. Use fetchPositions for polling.");
    yield [];
  }
  async *watchOrders() {
    this.ensureInitialized();
    throw new Error("WebSocket streams require additional implementation. Use fetchOpenOrders for polling.");
    yield [];
  }
  async *watchBalance() {
    this.ensureInitialized();
    throw new Error("WebSocket streams require additional implementation. Use fetchBalance for polling.");
    yield [];
  }
  // ===========================================================================
  // Helper Methods
  // ===========================================================================
  symbolToExchange(symbol) {
    return unifiedToDydx(symbol);
  }
  symbolFromExchange(exchangeSymbol) {
    return dydxToUnified(exchangeSymbol);
  }
  /**
   * Get oracle price from cache or fetch fresh
   */
  async getOraclePrice(ticker) {
    const cached = this.marketDataCache.get(ticker);
    if (cached && Date.now() - cached.timestamp < this.marketDataCacheTTL) {
      return cached.oraclePrice;
    }
    const response = await this.request(
      "GET",
      `${this.apiUrl}/perpetualMarkets`
    );
    const market = response.markets[ticker];
    if (!market) {
      return 0;
    }
    const oraclePrice = parseFloat(market.oraclePrice);
    this.marketDataCache.set(ticker, { oraclePrice, timestamp: Date.now() });
    return oraclePrice;
  }
  /**
   * Get the dYdX address (if authenticated)
   */
  async getAddress() {
    if (!this.auth) {
      return void 0;
    }
    return this.auth.getAddress();
  }
  /**
   * Get the configured subaccount number
   */
  getSubaccountNumber() {
    return this.subaccountNumber;
  }
};

// src/adapters/jupiter/constants.ts
var JUPITER_API_URLS = {
  mainnet: {
    price: "https://api.jup.ag/price/v3",
    stats: "https://perp-api.jup.ag"
    // Stats API (unofficial, may change)
  }
  // Jupiter Perps only operates on mainnet
};
var JUPITER_MAINNET_PRICE_API = JUPITER_API_URLS.mainnet.price;
var JUPITER_MAINNET_STATS_API = JUPITER_API_URLS.mainnet.stats;
var JUPITER_PERPS_PROGRAM_ID = "PERPHjGBqRHArX4DySjwM6UJHiR3sWAatqfdBS2verr";
var JUPITER_TOKEN_MINTS = {
  SOL: "So11111111111111111111111111111111111111112",
  ETH: "7vfCXTUXx5WJV5JADk17DUJ4ksgau7utNKj4b963voxs",
  // Wormhole ETH
  BTC: "3NZ9JMVBmGAqocybic2c7LQCJScmgsAZ6vQqTDzcqmJh",
  // Wormhole BTC (WBTC)
  USDC: "EPjFWdd5AufqSSqeM2qN1xzybapC8G4wEGGkZwyTDt1v",
  USDT: "Es9vMFrzaCERmJfrF4H2FYD4KCoNkY11McCe8BenwNYB"
};
var JUPITER_MARKETS = {
  "SOL-PERP": {
    symbol: "SOL/USD:USD",
    baseToken: "SOL",
    maxLeverage: 250,
    minPositionSize: 0.01,
    tickSize: 1e-3,
    stepSize: 1e-3
  },
  "ETH-PERP": {
    symbol: "ETH/USD:USD",
    baseToken: "ETH",
    maxLeverage: 250,
    minPositionSize: 1e-3,
    tickSize: 0.01,
    stepSize: 1e-4
  },
  "BTC-PERP": {
    symbol: "BTC/USD:USD",
    baseToken: "BTC",
    maxLeverage: 250,
    minPositionSize: 1e-4,
    tickSize: 0.1,
    stepSize: 1e-5
  }
};
function unifiedToJupiter(symbol) {
  const parts = symbol.split("/");
  const base = parts[0];
  if (!base) {
    throw new Error(`Invalid symbol format: ${symbol}`);
  }
  return `${base}-PERP`;
}
function jupiterToUnified(exchangeSymbol) {
  const base = exchangeSymbol.replace("-PERP", "");
  return `${base}/USD:USD`;
}
var SOLANA_RPC_ENDPOINTS = {
  mainnet: [
    "https://api.mainnet-beta.solana.com",
    "https://solana-api.projectserum.com"
  ]
};
var SOLANA_DEFAULT_RPC = SOLANA_RPC_ENDPOINTS.mainnet[0];
var JUPITER_ERROR_MESSAGES = {
  "insufficient collateral": "INSUFFICIENT_MARGIN",
  "insufficient balance": "INSUFFICIENT_BALANCE",
  "position not found": "POSITION_NOT_FOUND",
  "invalid leverage": "INVALID_LEVERAGE",
  "max leverage exceeded": "MAX_LEVERAGE_EXCEEDED",
  "min position size": "MIN_POSITION_SIZE",
  "oracle price stale": "ORACLE_ERROR",
  "pool capacity exceeded": "POOL_CAPACITY_EXCEEDED",
  "rate limit": "RATE_LIMIT_EXCEEDED",
  "transaction failed": "TRANSACTION_FAILED"
};

// src/adapters/jupiter/JupiterNormalizer.ts
var JupiterNormalizer = class {
  /**
   * Normalize market data from custody and pool accounts
   */
  normalizeMarket(marketKey, custody, pool, _stats) {
    const marketConfig = JUPITER_MARKETS[marketKey];
    const symbol = jupiterToUnified(marketKey);
    const makerFee = pool.fees.openPositionFee / 1e4;
    const takerFee = pool.fees.closePositionFee / 1e4;
    return {
      id: marketKey,
      symbol,
      base: marketConfig?.baseToken || marketKey.replace("-PERP", ""),
      quote: "USD",
      settle: "USD",
      active: custody.trading.tradingEnabled,
      minAmount: marketConfig?.minPositionSize || 1e-3,
      maxAmount: custody.pricing.maxPositionLockedUsd,
      minCost: 10,
      // $10 minimum
      pricePrecision: this.getPricePrecision(marketKey),
      amountPrecision: this.getAmountPrecision(marketKey),
      priceTickSize: marketConfig?.tickSize || 1e-3,
      amountStepSize: marketConfig?.stepSize || 1e-3,
      makerFee,
      takerFee,
      maxLeverage: custody.pricing.maxLeverage,
      fundingIntervalHours: 1,
      // Jupiter uses hourly borrow fees
      contractSize: 1,
      info: {
        custody: custody.mint,
        pool: pool.name,
        oracle: custody.oracle.oracleAccount,
        isStable: custody.isStable,
        maxUtilization: custody.pricing.maxUtilization,
        marginMode: "isolated",
        positionMode: "one-way"
      }
    };
  }
  /**
   * Normalize multiple markets
   */
  normalizeMarkets(custodies, pool, stats) {
    const markets = [];
    for (const [marketKey] of Object.entries(JUPITER_MARKETS)) {
      const custody = custodies.get(marketKey);
      if (custody) {
        markets.push(
          this.normalizeMarket(
            marketKey,
            custody,
            pool,
            stats?.get(marketKey)
          )
        );
      }
    }
    return markets;
  }
  /**
   * Normalize on-chain position account to unified Position
   */
  normalizePosition(positionAddress, position, currentPrice, marketKey) {
    const symbol = jupiterToUnified(marketKey);
    const side = position.side === "Long" ? "long" : "short";
    const sizeUsd = parseFloat(position.sizeUsd);
    const collateralUsd = parseFloat(position.collateralUsd);
    const entryPrice = parseFloat(position.price);
    const size = parseFloat(position.sizeTokens);
    const leverage = sizeUsd / collateralUsd;
    const unrealizedPnl = this.calculateUnrealizedPnl(
      side,
      size,
      entryPrice,
      currentPrice
    );
    const liquidationPrice = this.calculateLiquidationPrice(
      side,
      entryPrice,
      leverage,
      collateralUsd,
      sizeUsd
    );
    const maintenanceMargin = sizeUsd * 0.01;
    const marginRatio = (collateralUsd - maintenanceMargin) / collateralUsd * 100;
    return {
      symbol,
      side,
      size,
      entryPrice,
      markPrice: currentPrice,
      liquidationPrice,
      leverage,
      marginMode: "isolated",
      margin: collateralUsd,
      maintenanceMargin,
      marginRatio,
      unrealizedPnl,
      realizedPnl: parseFloat(position.realizedPnl),
      timestamp: position.updateTime * 1e3,
      info: {
        positionAddress,
        owner: position.owner,
        pool: position.pool,
        custody: position.custody,
        openTime: position.openTime,
        cumulativeInterestSnapshot: position.cumulativeInterestSnapshot,
        notional: sizeUsd
      }
    };
  }
  /**
   * Normalize position for internal SDK use
   */
  normalizePositionInternal(positionAddress, position, currentPrice, marketKey) {
    const symbol = jupiterToUnified(marketKey);
    const side = position.side === "Long" ? "long" : "short";
    const sizeUsd = parseFloat(position.sizeUsd);
    const collateralUsd = parseFloat(position.collateralUsd);
    const entryPrice = parseFloat(position.price);
    const size = parseFloat(position.sizeTokens);
    const leverage = sizeUsd / collateralUsd;
    const unrealizedPnl = this.calculateUnrealizedPnl(
      side,
      size,
      entryPrice,
      currentPrice
    );
    const liquidationPrice = this.calculateLiquidationPrice(
      side,
      entryPrice,
      leverage,
      collateralUsd,
      sizeUsd
    );
    return {
      id: positionAddress,
      owner: position.owner,
      symbol,
      side,
      size,
      sizeUsd,
      entryPrice,
      markPrice: currentPrice,
      collateralUsd,
      leverage,
      unrealizedPnl,
      realizedPnl: parseFloat(position.realizedPnl),
      liquidationPrice,
      openTime: position.openTime * 1e3,
      updateTime: position.updateTime * 1e3
    };
  }
  /**
   * Normalize ticker from price API and stats
   */
  normalizeTicker(marketKey, priceData, stats) {
    const symbol = jupiterToUnified(marketKey);
    const price = parseFloat(priceData.price);
    const now = Date.now();
    const bid = priceData.extraInfo?.quotedPrice ? parseFloat(priceData.extraInfo.quotedPrice.buyPrice) : price * 0.9995;
    const ask = priceData.extraInfo?.quotedPrice ? parseFloat(priceData.extraInfo.quotedPrice.sellPrice) : price * 1.0005;
    return {
      symbol,
      timestamp: now,
      last: price,
      bid,
      ask,
      high: stats?.high24h ?? price,
      low: stats?.low24h ?? price,
      open: stats?.oraclePrice ?? price,
      close: price,
      change: 0,
      // Would need historical data
      percentage: 0,
      baseVolume: stats?.volume24h ? stats.volume24h / price : 0,
      quoteVolume: stats?.volume24h ?? 0,
      info: {
        oraclePrice: stats?.oraclePrice,
        markPrice: stats?.markPrice,
        longOpenInterest: stats?.longOpenInterest,
        shortOpenInterest: stats?.shortOpenInterest,
        confidenceLevel: priceData.extraInfo?.confidenceLevel
      }
    };
  }
  /**
   * Normalize balance from pool stats
   * Jupiter uses JLP pool for collateral
   */
  normalizeBalance(currency, total, locked) {
    return {
      currency,
      total,
      free: total - locked,
      used: locked
    };
  }
  /**
   * Normalize funding rate (Jupiter uses borrow fees, not funding rates)
   * We represent borrow fee as a pseudo-funding rate for unified interface
   */
  normalizeFundingRate(marketKey, custody, currentPrice) {
    const symbol = jupiterToUnified(marketKey);
    const now = Date.now();
    const hourlyBorrowRate = parseFloat(custody.fundingRateState.hourlyBorrowRate);
    return {
      symbol,
      fundingRate: hourlyBorrowRate,
      fundingTimestamp: custody.fundingRateState.lastUpdate * 1e3,
      nextFundingTimestamp: now + 36e5,
      // Next hour
      markPrice: currentPrice,
      indexPrice: currentPrice,
      // Jupiter uses oracle price as index
      fundingIntervalHours: 1,
      info: {
        cumulativeInterestRate: custody.fundingRateState.cumulativeInterestRate,
        isBorrowFee: true
        // Indicate this is a borrow fee, not traditional funding
      }
    };
  }
  /**
   * Normalize order book (Jupiter doesn't have traditional orderbook)
   * Returns synthetic orderbook based on pool liquidity
   */
  normalizeOrderBook(marketKey, currentPrice, poolStats) {
    const symbol = jupiterToUnified(marketKey);
    const now = Date.now();
    const bids = [];
    const asks = [];
    if (poolStats) {
      const availableLiquidity = poolStats.aumUsd * 0.1;
      const levels = 10;
      const spreadBps = 5;
      for (let i = 0; i < levels; i++) {
        const bidPrice = currentPrice * (1 - (spreadBps + i * 2) / 1e4);
        const askPrice = currentPrice * (1 + (spreadBps + i * 2) / 1e4);
        const size = availableLiquidity / levels / currentPrice;
        bids.push([bidPrice, size]);
        asks.push([askPrice, size]);
      }
    }
    return {
      symbol,
      exchange: "jupiter",
      bids,
      asks,
      timestamp: now
    };
  }
  /**
   * Normalize pool stats to unified format
   */
  normalizePoolStats(stats) {
    return {
      aumUsd: stats.aumUsd,
      volume24h: stats.volume24h,
      volume7d: stats.volume7d,
      fees24h: stats.fees24h,
      openInterest: stats.openInterest,
      longOpenInterest: stats.longOpenInterest,
      shortOpenInterest: stats.shortOpenInterest,
      jlpPrice: stats.jlpPrice,
      jlpSupply: stats.jlpSupply
    };
  }
  // ==========================================================================
  // Helper Methods
  // ==========================================================================
  /**
   * Calculate unrealized PnL
   */
  calculateUnrealizedPnl(side, size, entryPrice, currentPrice) {
    if (side === "long") {
      return size * (currentPrice - entryPrice);
    } else {
      return size * (entryPrice - currentPrice);
    }
  }
  /**
   * Calculate liquidation price
   * Simplified calculation - actual Jupiter calculation is more complex
   */
  calculateLiquidationPrice(side, entryPrice, leverage, _collateralUsd, _sizeUsd) {
    const maintenanceMargin = 0.01;
    const liquidationThreshold = 1 - maintenanceMargin;
    if (side === "long") {
      return entryPrice * (1 - liquidationThreshold / leverage);
    } else {
      return entryPrice * (1 + liquidationThreshold / leverage);
    }
  }
  /**
   * Get price precision for market
   */
  getPricePrecision(marketKey) {
    const config = JUPITER_MARKETS[marketKey];
    if (!config) return 6;
    const tickSize = config.tickSize;
    return Math.max(0, -Math.floor(Math.log10(tickSize)));
  }
  /**
   * Get amount precision for market
   */
  getAmountPrecision(marketKey) {
    const config = JUPITER_MARKETS[marketKey];
    if (!config) return 4;
    const stepSize = config.stepSize;
    return Math.max(0, -Math.floor(Math.log10(stepSize)));
  }
};

// src/adapters/jupiter/JupiterAuth.ts
var JupiterAuth = class {
  keypair;
  walletAddress;
  publicKey;
  rpcEndpoint;
  connection;
  isInitialized = false;
  logger = new Logger("JupiterAuth");
  constructor(config) {
    this.rpcEndpoint = config.rpcEndpoint || SOLANA_DEFAULT_RPC;
    if (config.privateKey) {
      this.initializeFromPrivateKey(config.privateKey);
    } else if (config.walletAddress) {
      this.walletAddress = config.walletAddress;
    }
  }
  /**
   * Initialize keypair from private key
   */
  initializeFromPrivateKey(privateKey) {
    try {
      const bytes = this.parsePrivateKey(privateKey);
      void this.initKeypairAsync(bytes);
    } catch (error) {
      this.logger.warn(`Failed to initialize keypair: ${error instanceof Error ? error.message : String(error)}`);
    }
  }
  /**
   * Async initialization of keypair (for dynamic import)
   */
  async initKeypairAsync(bytes) {
    try {
      const { Keypair, Connection } = await import("@solana/web3.js");
      this.keypair = Keypair.fromSecretKey(bytes);
      this.publicKey = this.keypair.publicKey;
      this.walletAddress = this.publicKey.toBase58();
      this.connection = new Connection(this.rpcEndpoint, "confirmed");
      this.isInitialized = true;
    } catch (error) {
      this.logger.warn(`Failed to initialize Solana keypair: ${error instanceof Error ? error.message : String(error)}`);
    }
  }
  /**
   * Ensure async initialization is complete
   */
  async ensureInitialized() {
    if (!this.isInitialized && this.walletAddress) {
      try {
        const { Connection, PublicKey } = await import("@solana/web3.js");
        this.connection = new Connection(this.rpcEndpoint, "confirmed");
        if (this.walletAddress) {
          this.publicKey = new PublicKey(this.walletAddress);
        }
        this.isInitialized = true;
      } catch (error) {
        throw new Error(`Failed to initialize Solana connection: ${error instanceof Error ? error.message : String(error)}`);
      }
    }
  }
  /**
   * Sign a request (required by IAuthStrategy interface)
   * Jupiter uses on-chain transaction signing, not HTTP request signing
   */
  async sign(request) {
    return {
      ...request,
      headers: {}
    };
  }
  /**
   * Jupiter doesn't use HTTP header authentication
   * All authentication is done via transaction signing
   */
  getHeaders() {
    return {};
  }
  /**
   * Sign a message
   */
  async signMessage(message) {
    if (!this.keypair) {
      throw new Error("Private key required for signing");
    }
    const { sign: sign2 } = await Promise.resolve().then(() => (init_ed25519(), ed25519_exports));
    const messageBytes = new TextEncoder().encode(message);
    return sign2(messageBytes, this.keypair.secretKey.slice(0, 32));
  }
  /**
   * Sign bytes (for transaction signing)
   */
  async signBytes(bytes) {
    if (!this.keypair) {
      throw new Error("Private key required for signing");
    }
    const { sign: sign2 } = await Promise.resolve().then(() => (init_ed25519(), ed25519_exports));
    return sign2(bytes, this.keypair.secretKey.slice(0, 32));
  }
  /**
   * Sign a Solana transaction
   */
  async signTransaction(transaction) {
    if (!this.keypair) {
      throw new Error("Private key required for transaction signing");
    }
    transaction.sign(this.keypair);
    return transaction;
  }
  /**
   * Sign multiple Solana transactions
   */
  async signAllTransactions(transactions) {
    if (!this.keypair) {
      throw new Error("Private key required for transaction signing");
    }
    for (const tx of transactions) {
      tx.sign(this.keypair);
    }
    return transactions;
  }
  /**
   * Get the wallet address
   */
  getWalletAddress() {
    return this.walletAddress;
  }
  /**
   * Get the public key
   */
  getPublicKey() {
    return this.publicKey;
  }
  /**
   * Get the keypair (for SDK usage)
   */
  getKeypair() {
    return this.keypair;
  }
  /**
   * Check if authentication is configured for trading
   */
  canSign() {
    return this.keypair !== void 0;
  }
  /**
   * Check if authentication is configured for read operations
   */
  canRead() {
    return this.walletAddress !== void 0;
  }
  /**
   * Get RPC endpoint
   */
  getRpcEndpoint() {
    return this.rpcEndpoint;
  }
  /**
   * Get Solana connection
   */
  async getConnection() {
    await this.ensureInitialized();
    if (!this.connection) {
      throw new Error("Connection not initialized");
    }
    return this.connection;
  }
  /**
   * Get SOL balance
   */
  async getSolBalance() {
    await this.ensureInitialized();
    if (!this.connection || !this.publicKey) {
      throw new Error("Connection or public key not initialized");
    }
    const balance = await this.connection.getBalance(this.publicKey);
    return balance / 1e9;
  }
  /**
   * Get token balance for an SPL token
   */
  async getTokenBalance(tokenMint) {
    await this.ensureInitialized();
    if (!this.connection || !this.publicKey) {
      throw new Error("Connection or public key not initialized");
    }
    const { PublicKey } = await import("@solana/web3.js");
    const tokenMintPubkey = new PublicKey(tokenMint);
    const tokenAccounts = await this.connection.getTokenAccountsByOwner(
      this.publicKey,
      { mint: tokenMintPubkey }
    );
    if (tokenAccounts.value.length === 0) {
      return 0;
    }
    const accountInfo = tokenAccounts.value[0];
    if (!accountInfo) {
      return 0;
    }
    const data = accountInfo.account.data;
    const amountBytes = data.slice(64, 72);
    const amount = Buffer.from(amountBytes).readBigUInt64LE();
    return Number(amount);
  }
  /**
   * Get associated token account address
   */
  async getAssociatedTokenAddress(tokenMint) {
    if (!this.publicKey) {
      throw new Error("Public key not initialized");
    }
    const { PublicKey } = await import("@solana/web3.js");
    const mintPubkey = new PublicKey(tokenMint);
    const TOKEN_PROGRAM_ID = new PublicKey("TokenkegQfeZyiNwAJbNbGKPFXCWuBvf9Ss623VQ5DA");
    const ASSOCIATED_TOKEN_PROGRAM_ID = new PublicKey("ATokenGPvbdGVxr1b2hvZbsiqW5xWH25efTNsLJA8knL");
    const [address] = await PublicKey.findProgramAddress(
      [this.publicKey.toBuffer(), TOKEN_PROGRAM_ID.toBuffer(), mintPubkey.toBuffer()],
      ASSOCIATED_TOKEN_PROGRAM_ID
    );
    return address.toBase58();
  }
  // ==========================================================================
  // Private Methods
  // ==========================================================================
  /**
   * Parse private key from various formats
   */
  parsePrivateKey(key) {
    if (key instanceof Uint8Array) {
      return key;
    }
    if (key.startsWith("[")) {
      try {
        const parsed = JSON.parse(key);
        return new Uint8Array(parsed);
      } catch {
        throw new Error("Invalid private key JSON array format");
      }
    }
    if (/^[1-9A-HJ-NP-Za-km-z]+$/.test(key)) {
      try {
        const bs58 = require_cjs2();
        return bs58.decode(key);
      } catch {
        throw new Error("Invalid base58 private key format");
      }
    }
    if (/^(0x)?[0-9a-fA-F]+$/.test(key)) {
      const hex = key.startsWith("0x") ? key.slice(2) : key;
      const bytes = new Uint8Array(hex.length / 2);
      for (let i = 0; i < bytes.length; i++) {
        bytes[i] = parseInt(hex.slice(i * 2, i * 2 + 2), 16);
      }
      return bytes;
    }
    throw new Error("Unsupported private key format");
  }
};

// src/adapters/jupiter/solana.ts
var SolanaClient = class {
  connection;
  config;
  isInitialized = false;
  constructor(config = {}) {
    this.config = {
      rpcEndpoint: config.rpcEndpoint || SOLANA_DEFAULT_RPC,
      commitment: config.commitment || "confirmed",
      confirmOptions: config.confirmOptions || {
        commitment: "confirmed",
        preflightCommitment: "confirmed",
        maxRetries: 3
      }
    };
  }
  /**
   * Initialize the Solana connection
   */
  async initialize() {
    if (this.isInitialized) {
      return;
    }
    try {
      const { Connection } = await import("@solana/web3.js");
      this.connection = new Connection(
        this.config.rpcEndpoint,
        this.config.commitment
      );
      this.isInitialized = true;
    } catch (error) {
      throw new Error(`Failed to initialize Solana connection: ${error instanceof Error ? error.message : String(error)}`);
    }
  }
  /**
   * Ensure connection is initialized
   */
  ensureInitialized() {
    if (!this.isInitialized || !this.connection) {
      throw new Error("SolanaClient not initialized. Call initialize() first.");
    }
    return this.connection;
  }
  /**
   * Get the connection instance
   */
  getConnection() {
    return this.ensureInitialized();
  }
  // ==========================================================================
  // Account Operations
  // ==========================================================================
  /**
   * Fetch account info
   */
  async getAccountInfo(pubkey) {
    const connection = this.ensureInitialized();
    const { PublicKey } = await import("@solana/web3.js");
    const publicKey = new PublicKey(pubkey);
    return connection.getAccountInfo(publicKey);
  }
  /**
   * Fetch multiple accounts
   */
  async getMultipleAccountsInfo(pubkeys) {
    const connection = this.ensureInitialized();
    const { PublicKey } = await import("@solana/web3.js");
    const publicKeys = pubkeys.map((pk) => new PublicKey(pk));
    return connection.getMultipleAccountsInfo(publicKeys);
  }
  /**
   * Get SOL balance for an address
   */
  async getBalance(pubkey) {
    const connection = this.ensureInitialized();
    const { PublicKey } = await import("@solana/web3.js");
    const publicKey = new PublicKey(pubkey);
    const lamports = await connection.getBalance(publicKey);
    return lamports / 1e9;
  }
  /**
   * Get token account balance
   */
  async getTokenBalance(tokenAccount) {
    const connection = this.ensureInitialized();
    const { PublicKey } = await import("@solana/web3.js");
    const publicKey = new PublicKey(tokenAccount);
    const balance = await connection.getTokenAccountBalance(publicKey);
    return parseFloat(balance.value.amount) / Math.pow(10, balance.value.decimals);
  }
  /**
   * Get token accounts by owner
   */
  async getTokenAccountsByOwner(owner, mint) {
    const connection = this.ensureInitialized();
    const { PublicKey } = await import("@solana/web3.js");
    const ownerPubkey = new PublicKey(owner);
    const TOKEN_PROGRAM_ID = new PublicKey("TokenkegQfeZyiNwAJbNbGKPFXCWuBvf9Ss623VQ5DA");
    const filter = mint ? { mint: new PublicKey(mint) } : { programId: TOKEN_PROGRAM_ID };
    const accounts = await connection.getTokenAccountsByOwner(ownerPubkey, filter);
    return accounts.value.map((account) => {
      const data = account.account.data;
      const mintBytes = data.slice(0, 32);
      const amountBytes = data.slice(64, 72);
      const mintPubkey = new PublicKey(mintBytes);
      const amount = Buffer.from(amountBytes).readBigUInt64LE();
      return {
        pubkey: account.pubkey.toBase58(),
        balance: Number(amount),
        mint: mintPubkey.toBase58()
      };
    });
  }
  /**
   * Fetch program accounts with filters
   */
  async getProgramAccounts(programId, filters) {
    const connection = this.ensureInitialized();
    const { PublicKey } = await import("@solana/web3.js");
    const programPubkey = new PublicKey(programId);
    const accounts = await connection.getProgramAccounts(programPubkey, {
      filters: filters?.map((f) => {
        if (f.memcmp) {
          return { memcmp: f.memcmp };
        }
        if (f.dataSize !== void 0) {
          return { dataSize: f.dataSize };
        }
        return void 0;
      }).filter(Boolean)
    });
    return accounts.map((account) => ({
      pubkey: account.pubkey.toBase58(),
      account: account.account
    }));
  }
  // ==========================================================================
  // Transaction Operations
  // ==========================================================================
  /**
   * Create a new transaction
   */
  async createTransaction() {
    const { Transaction } = await import("@solana/web3.js");
    const connection = this.ensureInitialized();
    const transaction = new Transaction();
    const latestBlockhash = await connection.getLatestBlockhash();
    transaction.recentBlockhash = latestBlockhash.blockhash;
    transaction.lastValidBlockHeight = latestBlockhash.lastValidBlockHeight;
    return transaction;
  }
  /**
   * Add instructions to a transaction
   */
  async addInstructions(transaction, instructions) {
    for (const ix of instructions) {
      transaction.add(ix);
    }
    return transaction;
  }
  /**
   * Sign and send a transaction
   */
  async sendTransaction(transaction, signers) {
    const connection = this.ensureInitialized();
    if (signers.length > 0) {
      transaction.sign(...signers);
    }
    const signature = await connection.sendRawTransaction(
      transaction.serialize(),
      {
        skipPreflight: false,
        preflightCommitment: this.config.commitment,
        maxRetries: 3
      }
    );
    const confirmation = await connection.confirmTransaction(
      {
        signature,
        blockhash: transaction.recentBlockhash,
        lastValidBlockHeight: transaction.lastValidBlockHeight
      },
      this.config.commitment
    );
    if (confirmation.value.err) {
      throw new Error(`Transaction failed: ${JSON.stringify(confirmation.value.err)}`);
    }
    return {
      signature,
      slot: confirmation.context.slot
    };
  }
  /**
   * Simulate a transaction (for testing without execution)
   */
  async simulateTransaction(transaction) {
    const connection = this.ensureInitialized();
    const simulation = await connection.simulateTransaction(transaction);
    return {
      success: simulation.value.err === null,
      logs: simulation.value.logs || [],
      unitsConsumed: simulation.value.unitsConsumed,
      error: simulation.value.err ? JSON.stringify(simulation.value.err) : void 0
    };
  }
  /**
   * Get transaction details
   */
  async getTransaction(signature) {
    const connection = this.ensureInitialized();
    const commitment = this.config.commitment === "processed" ? "confirmed" : this.config.commitment;
    const tx = await connection.getTransaction(signature, {
      commitment,
      maxSupportedTransactionVersion: 0
    });
    if (!tx) {
      return null;
    }
    return {
      slot: tx.slot,
      blockTime: tx.blockTime ?? null,
      err: tx.meta?.err,
      logs: tx.meta?.logMessages || []
    };
  }
  /**
   * Get recent blockhash
   */
  async getLatestBlockhash() {
    const connection = this.ensureInitialized();
    return connection.getLatestBlockhash();
  }
  // ==========================================================================
  // PDA Operations
  // ==========================================================================
  /**
   * Find Program Derived Address
   */
  async findProgramAddress(seeds, programId) {
    const { PublicKey } = await import("@solana/web3.js");
    const programPubkey = new PublicKey(programId);
    const [pubkey, bump] = await PublicKey.findProgramAddress(seeds, programPubkey);
    return {
      pubkey: pubkey.toBase58(),
      bump
    };
  }
  /**
   * Create PDA with bump
   */
  async createProgramAddress(seeds, programId) {
    const { PublicKey } = await import("@solana/web3.js");
    const programPubkey = new PublicKey(programId);
    const pubkey = await PublicKey.createProgramAddress(seeds, programPubkey);
    return pubkey.toBase58();
  }
  // ==========================================================================
  // Jupiter-specific Operations
  // ==========================================================================
  /**
   * Get Jupiter Perps position accounts for an owner
   */
  async getJupiterPositions(owner) {
    const { PublicKey } = await import("@solana/web3.js");
    const ownerBytes = new PublicKey(owner).toBuffer();
    const POSITION_DISCRIMINATOR = Buffer.from([
      86,
      122,
      136,
      76,
      92,
      71,
      18,
      143
      // Example - actual value from IDL
    ]);
    return this.getProgramAccounts(JUPITER_PERPS_PROGRAM_ID, [
      // Filter by discriminator
      {
        memcmp: {
          offset: 0,
          bytes: POSITION_DISCRIMINATOR.toString("base64")
        }
      },
      // Filter by owner
      {
        memcmp: {
          offset: 8,
          // After discriminator
          bytes: ownerBytes.toString("base64")
        }
      }
    ]);
  }
  /**
   * Get Jupiter pool account
   */
  async getJupiterPool() {
    const { pubkey } = await this.findProgramAddress(
      [Buffer.from("pool")],
      JUPITER_PERPS_PROGRAM_ID
    );
    const account = await this.getAccountInfo(pubkey);
    if (!account) {
      return null;
    }
    return { pubkey, account };
  }
  /**
   * Get custody account for a token
   */
  async getJupiterCustody(tokenMint) {
    const { PublicKey } = await import("@solana/web3.js");
    const mintPubkey = new PublicKey(tokenMint);
    const { pubkey } = await this.findProgramAddress(
      [Buffer.from("custody"), mintPubkey.toBuffer()],
      JUPITER_PERPS_PROGRAM_ID
    );
    const account = await this.getAccountInfo(pubkey);
    if (!account) {
      return null;
    }
    return { pubkey, account };
  }
  // ==========================================================================
  // Utility Methods
  // ==========================================================================
  /**
   * Check if the client is initialized
   */
  isReady() {
    return this.isInitialized;
  }
  /**
   * Get the RPC endpoint
   */
  getRpcEndpoint() {
    return this.config.rpcEndpoint;
  }
  /**
   * Get slot
   */
  async getSlot() {
    const connection = this.ensureInitialized();
    return connection.getSlot();
  }
  /**
   * Get block time for a slot
   */
  async getBlockTime(slot) {
    const connection = this.ensureInitialized();
    return connection.getBlockTime(slot);
  }
  /**
   * Disconnect (cleanup)
   */
  async disconnect() {
    this.isInitialized = false;
    this.connection = void 0;
  }
};

// src/adapters/jupiter/instructions.ts
var INSTRUCTION_DISCRIMINATORS = {
  // Position creation/modification (market orders)
  createIncreasePositionMarketRequest: Buffer.from([183, 198, 97, 169, 35, 1, 225, 57]),
  createDecreasePositionMarketRequest: Buffer.from([147, 238, 76, 91, 48, 86, 167, 253]),
  createDecreasePositionRequest2: Buffer.from([55, 39, 12, 22, 216, 115, 53, 101]),
  // Request management
  closePositionRequest: Buffer.from([75, 207, 70, 173, 118, 124, 218, 179]),
  // Position execution (called by keepers)
  increasePosition4: Buffer.from([102, 119, 60, 121, 0, 231, 167, 132]),
  decreasePosition4: Buffer.from([173, 196, 82, 93, 61, 94, 144, 38]),
  // Instant operations (atomic open/close)
  instantIncreasePosition: Buffer.from([111, 90, 197, 196, 253, 220, 125, 15]),
  instantDecreasePosition: Buffer.from([15, 73, 118, 177, 207, 6, 25, 62]),
  // TP/SL management
  instantCreateTpsl: Buffer.from([30, 101, 179, 184, 250, 186, 197, 200]),
  instantUpdateTpsl: Buffer.from([63, 40, 158, 99, 200, 158, 137, 233]),
  // Liquidation
  liquidateFullPosition4: Buffer.from([122, 33, 108, 125, 214, 143, 98, 67])
};
var JupiterInstructionBuilder = class {
  programId;
  isInitialized = false;
  /**
   * Initialize the instruction builder
   */
  async initialize() {
    if (this.isInitialized) {
      return;
    }
    const { PublicKey } = await import("@solana/web3.js");
    this.programId = new PublicKey(JUPITER_PERPS_PROGRAM_ID);
    this.isInitialized = true;
  }
  /**
   * Ensure builder is initialized
   */
  ensureInitialized() {
    if (!this.isInitialized || !this.programId) {
      throw new Error("JupiterInstructionBuilder not initialized. Call initialize() first.");
    }
  }
  // ==========================================================================
  // Position Instructions
  // ==========================================================================
  /**
   * Build open position instruction
   */
  async buildOpenPositionInstruction(params, accounts) {
    this.ensureInitialized();
    const { PublicKey, TransactionInstruction } = await import("@solana/web3.js");
    const data = this.encodeOpenPositionData(params);
    const keys = [
      { pubkey: new PublicKey(params.owner), isSigner: true, isWritable: true },
      { pubkey: new PublicKey(accounts.position), isSigner: false, isWritable: true },
      { pubkey: new PublicKey(accounts.pool), isSigner: false, isWritable: true },
      { pubkey: new PublicKey(accounts.custody), isSigner: false, isWritable: true },
      { pubkey: new PublicKey(accounts.custodyTokenAccount), isSigner: false, isWritable: true },
      { pubkey: new PublicKey(accounts.collateralCustody), isSigner: false, isWritable: true },
      { pubkey: new PublicKey(accounts.collateralTokenAccount), isSigner: false, isWritable: true },
      { pubkey: new PublicKey(accounts.oracle), isSigner: false, isWritable: false },
      { pubkey: new PublicKey(accounts.ownerTokenAccount), isSigner: false, isWritable: true },
      // System accounts
      { pubkey: new PublicKey("TokenkegQfeZyiNwAJbNbGKPFXCWuBvf9Ss623VQ5DA"), isSigner: false, isWritable: false },
      // Token Program
      { pubkey: new PublicKey("11111111111111111111111111111111"), isSigner: false, isWritable: false }
      // System Program
    ];
    return new TransactionInstruction({
      keys,
      programId: this.programId,
      data
    });
  }
  /**
   * Build close position instruction
   */
  async buildClosePositionInstruction(params, accounts) {
    this.ensureInitialized();
    const { PublicKey, TransactionInstruction } = await import("@solana/web3.js");
    const data = this.encodeClosePositionData(params);
    const keys = [
      { pubkey: new PublicKey(params.owner), isSigner: true, isWritable: true },
      { pubkey: new PublicKey(accounts.position), isSigner: false, isWritable: true },
      { pubkey: new PublicKey(accounts.pool), isSigner: false, isWritable: true },
      { pubkey: new PublicKey(accounts.custody), isSigner: false, isWritable: true },
      { pubkey: new PublicKey(accounts.custodyTokenAccount), isSigner: false, isWritable: true },
      { pubkey: new PublicKey(accounts.collateralCustody), isSigner: false, isWritable: true },
      { pubkey: new PublicKey(accounts.collateralTokenAccount), isSigner: false, isWritable: true },
      { pubkey: new PublicKey(accounts.oracle), isSigner: false, isWritable: false },
      { pubkey: new PublicKey(accounts.ownerTokenAccount), isSigner: false, isWritable: true },
      // System accounts
      { pubkey: new PublicKey("TokenkegQfeZyiNwAJbNbGKPFXCWuBvf9Ss623VQ5DA"), isSigner: false, isWritable: false }
    ];
    return new TransactionInstruction({
      keys,
      programId: this.programId,
      data
    });
  }
  /**
   * Build increase size instruction
   */
  async buildIncreaseSizeInstruction(params, accounts) {
    this.ensureInitialized();
    const { PublicKey, TransactionInstruction } = await import("@solana/web3.js");
    const data = this.encodeIncreaseSizeData(params);
    const keys = [
      { pubkey: new PublicKey(params.owner), isSigner: true, isWritable: true },
      { pubkey: new PublicKey(accounts.position), isSigner: false, isWritable: true },
      { pubkey: new PublicKey(accounts.pool), isSigner: false, isWritable: true },
      { pubkey: new PublicKey(accounts.custody), isSigner: false, isWritable: true },
      { pubkey: new PublicKey(accounts.oracle), isSigner: false, isWritable: false }
    ];
    return new TransactionInstruction({
      keys,
      programId: this.programId,
      data
    });
  }
  /**
   * Build decrease size instruction
   */
  async buildDecreaseSizeInstruction(params, accounts) {
    this.ensureInitialized();
    const { PublicKey, TransactionInstruction } = await import("@solana/web3.js");
    const data = this.encodeDecreaseSizeData(params);
    const keys = [
      { pubkey: new PublicKey(params.owner), isSigner: true, isWritable: true },
      { pubkey: new PublicKey(accounts.position), isSigner: false, isWritable: true },
      { pubkey: new PublicKey(accounts.pool), isSigner: false, isWritable: true },
      { pubkey: new PublicKey(accounts.custody), isSigner: false, isWritable: true },
      { pubkey: new PublicKey(accounts.collateralCustody), isSigner: false, isWritable: true },
      { pubkey: new PublicKey(accounts.collateralTokenAccount), isSigner: false, isWritable: true },
      { pubkey: new PublicKey(accounts.oracle), isSigner: false, isWritable: false },
      { pubkey: new PublicKey(accounts.ownerTokenAccount), isSigner: false, isWritable: true },
      // System accounts
      { pubkey: new PublicKey("TokenkegQfeZyiNwAJbNbGKPFXCWuBvf9Ss623VQ5DA"), isSigner: false, isWritable: false }
    ];
    return new TransactionInstruction({
      keys,
      programId: this.programId,
      data
    });
  }
  /**
   * Build add collateral instruction
   */
  async buildAddCollateralInstruction(params, accounts) {
    this.ensureInitialized();
    const { PublicKey, TransactionInstruction } = await import("@solana/web3.js");
    const data = this.encodeAddCollateralData(params);
    const keys = [
      { pubkey: new PublicKey(params.owner), isSigner: true, isWritable: true },
      { pubkey: new PublicKey(accounts.position), isSigner: false, isWritable: true },
      { pubkey: new PublicKey(accounts.pool), isSigner: false, isWritable: false },
      { pubkey: new PublicKey(accounts.collateralCustody), isSigner: false, isWritable: true },
      { pubkey: new PublicKey(accounts.collateralTokenAccount), isSigner: false, isWritable: true },
      { pubkey: new PublicKey(accounts.ownerTokenAccount), isSigner: false, isWritable: true },
      // System accounts
      { pubkey: new PublicKey("TokenkegQfeZyiNwAJbNbGKPFXCWuBvf9Ss623VQ5DA"), isSigner: false, isWritable: false }
    ];
    return new TransactionInstruction({
      keys,
      programId: this.programId,
      data
    });
  }
  /**
   * Build remove collateral instruction
   */
  async buildRemoveCollateralInstruction(params, accounts) {
    this.ensureInitialized();
    const { PublicKey, TransactionInstruction } = await import("@solana/web3.js");
    const data = this.encodeRemoveCollateralData(params);
    const keys = [
      { pubkey: new PublicKey(params.owner), isSigner: true, isWritable: true },
      { pubkey: new PublicKey(accounts.position), isSigner: false, isWritable: true },
      { pubkey: new PublicKey(accounts.pool), isSigner: false, isWritable: false },
      { pubkey: new PublicKey(accounts.collateralCustody), isSigner: false, isWritable: true },
      { pubkey: new PublicKey(accounts.collateralTokenAccount), isSigner: false, isWritable: true },
      { pubkey: new PublicKey(accounts.oracle), isSigner: false, isWritable: false },
      { pubkey: new PublicKey(accounts.ownerTokenAccount), isSigner: false, isWritable: true },
      // System accounts
      { pubkey: new PublicKey("TokenkegQfeZyiNwAJbNbGKPFXCWuBvf9Ss623VQ5DA"), isSigner: false, isWritable: false }
    ];
    return new TransactionInstruction({
      keys,
      programId: this.programId,
      data
    });
  }
  // ==========================================================================
  // Data Encoding
  // ==========================================================================
  /**
   * Encode open position instruction data
   * Uses createIncreasePositionMarketRequest for market orders
   */
  encodeOpenPositionData(params) {
    const PRICE_DECIMALS = 6;
    const USD_DECIMALS = 6;
    const sizeUsdScaled = BigInt(Math.floor(params.sizeUsd * 10 ** USD_DECIMALS));
    const collateralScaled = BigInt(Math.floor(params.collateralAmount * 10 ** USD_DECIMALS));
    const priceLimitScaled = params.priceLimit ? BigInt(Math.floor(params.priceLimit * 10 ** PRICE_DECIMALS)) : BigInt(0);
    const sideValue = params.side === "long" ? 0 : 1;
    const buffer = Buffer.alloc(8 + 1 + 8 + 8 + 8);
    let offset = 0;
    INSTRUCTION_DISCRIMINATORS.createIncreasePositionMarketRequest.copy(buffer, offset);
    offset += 8;
    buffer.writeUInt8(sideValue, offset);
    offset += 1;
    buffer.writeBigUInt64LE(sizeUsdScaled, offset);
    offset += 8;
    buffer.writeBigUInt64LE(collateralScaled, offset);
    offset += 8;
    buffer.writeBigUInt64LE(priceLimitScaled, offset);
    return buffer;
  }
  /**
   * Encode close position instruction data
   * Uses createDecreasePositionMarketRequest for market orders
   */
  encodeClosePositionData(params) {
    const PRICE_DECIMALS = 6;
    const USD_DECIMALS = 6;
    const sizeUsdScaled = params.sizeUsd ? BigInt(Math.floor(params.sizeUsd * 10 ** USD_DECIMALS)) : BigInt(0);
    const priceLimitScaled = params.priceLimit ? BigInt(Math.floor(params.priceLimit * 10 ** PRICE_DECIMALS)) : BigInt(0);
    const buffer = Buffer.alloc(8 + 8 + 8);
    let offset = 0;
    INSTRUCTION_DISCRIMINATORS.createDecreasePositionMarketRequest.copy(buffer, offset);
    offset += 8;
    buffer.writeBigUInt64LE(sizeUsdScaled, offset);
    offset += 8;
    buffer.writeBigUInt64LE(priceLimitScaled, offset);
    return buffer;
  }
  /**
   * Encode increase size instruction data
   * Uses createIncreasePositionMarketRequest (same as open, for adding to position)
   */
  encodeIncreaseSizeData(params) {
    const USD_DECIMALS = 6;
    const PRICE_DECIMALS = 6;
    const sizeDeltaScaled = BigInt(Math.floor(params.sizeDeltaUsd * 10 ** USD_DECIMALS));
    const priceLimitScaled = params.priceLimit ? BigInt(Math.floor(params.priceLimit * 10 ** PRICE_DECIMALS)) : BigInt(0);
    const buffer = Buffer.alloc(8 + 8 + 8);
    let offset = 0;
    INSTRUCTION_DISCRIMINATORS.createIncreasePositionMarketRequest.copy(buffer, offset);
    offset += 8;
    buffer.writeBigUInt64LE(sizeDeltaScaled, offset);
    offset += 8;
    buffer.writeBigUInt64LE(priceLimitScaled, offset);
    return buffer;
  }
  /**
   * Encode decrease size instruction data
   * Uses createDecreasePositionMarketRequest (same as close, for partial close)
   */
  encodeDecreaseSizeData(params) {
    const USD_DECIMALS = 6;
    const PRICE_DECIMALS = 6;
    const sizeDeltaScaled = BigInt(Math.floor(params.sizeDeltaUsd * 10 ** USD_DECIMALS));
    const priceLimitScaled = params.priceLimit ? BigInt(Math.floor(params.priceLimit * 10 ** PRICE_DECIMALS)) : BigInt(0);
    const buffer = Buffer.alloc(8 + 8 + 8);
    let offset = 0;
    INSTRUCTION_DISCRIMINATORS.createDecreasePositionMarketRequest.copy(buffer, offset);
    offset += 8;
    buffer.writeBigUInt64LE(sizeDeltaScaled, offset);
    offset += 8;
    buffer.writeBigUInt64LE(priceLimitScaled, offset);
    return buffer;
  }
  /**
   * Encode add collateral instruction data
   * Uses createIncreasePositionMarketRequest with size=0 to add collateral only
   */
  encodeAddCollateralData(params) {
    const USD_DECIMALS = 6;
    const collateralScaled = BigInt(Math.floor(params.collateralAmount * 10 ** USD_DECIMALS));
    const sizeUsd = BigInt(0);
    const priceLimit = BigInt(0);
    const buffer = Buffer.alloc(8 + 1 + 8 + 8 + 8);
    let offset = 0;
    INSTRUCTION_DISCRIMINATORS.createIncreasePositionMarketRequest.copy(buffer, offset);
    offset += 8;
    buffer.writeUInt8(0, offset);
    offset += 1;
    buffer.writeBigUInt64LE(sizeUsd, offset);
    offset += 8;
    buffer.writeBigUInt64LE(collateralScaled, offset);
    offset += 8;
    buffer.writeBigUInt64LE(priceLimit, offset);
    return buffer;
  }
  /**
   * Encode remove collateral instruction data
   * Uses createDecreasePositionMarketRequest with size=0 to remove collateral only
   */
  encodeRemoveCollateralData(params) {
    const USD_DECIMALS = 6;
    const collateralScaled = BigInt(Math.floor(params.collateralAmount * 10 ** USD_DECIMALS));
    const sizeUsd = BigInt(0);
    const priceLimit = BigInt(0);
    const buffer = Buffer.alloc(8 + 8 + 8 + 8);
    let offset = 0;
    INSTRUCTION_DISCRIMINATORS.createDecreasePositionMarketRequest.copy(buffer, offset);
    offset += 8;
    buffer.writeBigUInt64LE(sizeUsd, offset);
    offset += 8;
    buffer.writeBigUInt64LE(collateralScaled, offset);
    offset += 8;
    buffer.writeBigUInt64LE(priceLimit, offset);
    return buffer;
  }
  // ==========================================================================
  // Account Resolution Helpers
  // ==========================================================================
  /**
   * Resolve position accounts for a market
   */
  async resolvePositionAccounts(owner, symbol, side) {
    this.ensureInitialized();
    const { PublicKey } = await import("@solana/web3.js");
    const jupiterSymbol = unifiedToJupiter(symbol);
    const baseToken = jupiterSymbol.replace("-PERP", "");
    const tokenMint = JUPITER_TOKEN_MINTS[baseToken];
    if (!tokenMint) {
      throw new Error(`Unknown token for market: ${symbol}`);
    }
    const programId = this.programId;
    const [poolPda] = await PublicKey.findProgramAddress(
      [Buffer.from("pool")],
      programId
    );
    const [custodyPda] = await PublicKey.findProgramAddress(
      [Buffer.from("custody"), new PublicKey(tokenMint).toBuffer()],
      programId
    );
    const usdcMint = JUPITER_TOKEN_MINTS.USDC;
    const [collateralCustodyPda] = await PublicKey.findProgramAddress(
      [Buffer.from("custody"), new PublicKey(usdcMint).toBuffer()],
      programId
    );
    const ownerPubkey = new PublicKey(owner);
    const sideBuffer = Buffer.from([side === "long" ? 0 : 1]);
    const [positionPda] = await PublicKey.findProgramAddress(
      [
        Buffer.from("position"),
        ownerPubkey.toBuffer(),
        poolPda.toBuffer(),
        custodyPda.toBuffer(),
        sideBuffer
      ],
      programId
    );
    const [custodyTokenAccountPda] = await PublicKey.findProgramAddress(
      [Buffer.from("custody_token_account"), custodyPda.toBuffer()],
      programId
    );
    const [collateralTokenAccountPda] = await PublicKey.findProgramAddress(
      [Buffer.from("custody_token_account"), collateralCustodyPda.toBuffer()],
      programId
    );
    const [oraclePda] = await PublicKey.findProgramAddress(
      [Buffer.from("oracle"), custodyPda.toBuffer()],
      programId
    );
    return {
      position: positionPda.toBase58(),
      pool: poolPda.toBase58(),
      custody: custodyPda.toBase58(),
      custodyTokenAccount: custodyTokenAccountPda.toBase58(),
      collateralCustody: collateralCustodyPda.toBase58(),
      collateralTokenAccount: collateralTokenAccountPda.toBase58(),
      oracle: oraclePda.toBase58(),
      ownerTokenAccount: ""
      // Will be set by caller
    };
  }
  /**
   * Get associated token account address
   */
  async getAssociatedTokenAddress(owner, mint) {
    const { PublicKey } = await import("@solana/web3.js");
    const ownerPubkey = new PublicKey(owner);
    const mintPubkey = new PublicKey(mint);
    const TOKEN_PROGRAM_ID = new PublicKey("TokenkegQfeZyiNwAJbNbGKPFXCWuBvf9Ss623VQ5DA");
    const ASSOCIATED_TOKEN_PROGRAM_ID = new PublicKey("ATokenGPvbdGVxr1b2hvZbsiqW5xWH25efTNsLJA8knL");
    const [address] = await PublicKey.findProgramAddress(
      [ownerPubkey.toBuffer(), TOKEN_PROGRAM_ID.toBuffer(), mintPubkey.toBuffer()],
      ASSOCIATED_TOKEN_PROGRAM_ID
    );
    return address.toBase58();
  }
};

// src/adapters/jupiter/error-codes.ts
function mapJupiterError(error) {
  if (error instanceof PerpDEXError) {
    return error;
  }
  if (error instanceof Error) {
    const message = error.message.toLowerCase();
    for (const [pattern, code] of Object.entries(JUPITER_ERROR_MESSAGES)) {
      if (message.includes(pattern)) {
        switch (code) {
          case "INSUFFICIENT_MARGIN":
            return new InsufficientMarginError(error.message, code, "jupiter", error);
          case "INSUFFICIENT_BALANCE":
            return new InsufficientBalanceError(error.message, code, "jupiter", void 0, void 0, error);
          case "POSITION_NOT_FOUND":
            return new PositionNotFoundError(error.message, code, "jupiter", error);
          case "INVALID_LEVERAGE":
          case "MAX_LEVERAGE_EXCEEDED":
          case "MIN_POSITION_SIZE":
            return new InvalidOrderError(error.message, code, "jupiter", error);
          case "ORACLE_ERROR":
            return new ExchangeUnavailableError(error.message, code, "jupiter", error);
          case "POOL_CAPACITY_EXCEEDED":
            return new InvalidOrderError(error.message, code, "jupiter", error);
          case "RATE_LIMIT_EXCEEDED":
            return new RateLimitError(error.message, code, "jupiter", void 0, error);
          case "TRANSACTION_FAILED":
            return new TransactionFailedError(error.message, code, "jupiter", void 0, error);
        }
      }
    }
    if (message.includes("blockhash") || message.includes("expired")) {
      return new TransactionFailedError(
        "Transaction expired",
        "TRANSACTION_EXPIRED",
        "jupiter",
        void 0,
        error
      );
    }
    if (message.includes("signature verification")) {
      return new InvalidSignatureError(
        "Invalid transaction signature",
        "INVALID_SIGNATURE",
        "jupiter",
        error
      );
    }
    if (message.includes("insufficient lamports") || message.includes("insufficient sol")) {
      return new InsufficientBalanceError(
        "Insufficient SOL for transaction fees",
        "INSUFFICIENT_SOL",
        "jupiter",
        void 0,
        void 0,
        error
      );
    }
    if (message.includes("account not found") || message.includes("account does not exist")) {
      return new PerpDEXError(
        "Account not found on chain",
        "ACCOUNT_NOT_FOUND",
        "jupiter",
        error
      );
    }
    if (message.includes("429") || message.includes("too many requests")) {
      return new RateLimitError("RPC rate limit exceeded", "RATE_LIMIT", "jupiter", void 0, error);
    }
    if (message.includes("503") || message.includes("502") || message.includes("504")) {
      return new ExchangeUnavailableError(
        "Solana RPC temporarily unavailable",
        "RPC_UNAVAILABLE",
        "jupiter",
        error
      );
    }
    if (message.includes("timeout") || message.includes("timed out")) {
      return new ExchangeUnavailableError(
        "Request timeout",
        "TIMEOUT",
        "jupiter",
        error
      );
    }
  }
  return new ExchangeUnavailableError(
    "Unknown exchange error",
    "UNKNOWN_ERROR",
    "jupiter",
    error
  );
}

// src/adapters/jupiter/utils.ts
function getMarketConfig(symbol) {
  const jupiterSymbol = symbol.includes("-PERP") ? symbol : unifiedToJupiter(symbol);
  return JUPITER_MARKETS[jupiterSymbol];
}
function isValidMarket(symbol) {
  const jupiterSymbol = symbol.includes("-PERP") ? symbol : unifiedToJupiter(symbol);
  return jupiterSymbol in JUPITER_MARKETS;
}
function validateLeverage2(leverage, symbol) {
  const config = getMarketConfig(symbol);
  const maxLeverage = config?.maxLeverage || 100;
  if (leverage < 1) {
    return { valid: false, reason: "Leverage must be at least 1x" };
  }
  if (leverage > maxLeverage) {
    return { valid: false, reason: `Maximum leverage for ${symbol} is ${maxLeverage}x` };
  }
  return { valid: true };
}
function buildPriceApiUrl(tokenIds) {
  const baseUrl = "https://api.jup.ag/price/v3";
  const params = new URLSearchParams({
    ids: tokenIds.join(",")
  });
  return `${baseUrl}?${params.toString()}`;
}
function calculateLiquidationPrice(side, entryPrice, collateralUsd, sizeUsd, maintenanceMarginRate = 0.01) {
  const maintenanceMargin = sizeUsd * maintenanceMarginRate;
  const availableMargin = collateralUsd - maintenanceMargin;
  const priceMovement = availableMargin / sizeUsd * entryPrice;
  if (side === "long") {
    return entryPrice - priceMovement;
  } else {
    return entryPrice + priceMovement;
  }
}
function parseOnChainTimestamp(timestamp) {
  const ts = typeof timestamp === "string" ? parseInt(timestamp, 10) : timestamp;
  if (ts < 3250368e4) {
    return ts * 1e3;
  }
  return ts;
}
function validatePositionSize(sizeUsd, _symbol) {
  if (sizeUsd < 10) {
    return { valid: false, reason: "Minimum position size is $10 USD" };
  }
  return { valid: true };
}
function validateOrderParams(params) {
  const errors = [];
  if (!isValidMarket(params.symbol)) {
    errors.push(`Invalid market: ${params.symbol}`);
  }
  const sizeValidation = validatePositionSize(params.sizeUsd, params.symbol);
  if (!sizeValidation.valid && sizeValidation.reason) {
    errors.push(sizeValidation.reason);
  }
  const leverageValidation = validateLeverage2(params.leverage, params.symbol);
  if (!leverageValidation.valid && leverageValidation.reason) {
    errors.push(leverageValidation.reason);
  }
  return {
    valid: errors.length === 0,
    errors
  };
}

// src/adapters/jupiter/JupiterAdapter.ts
var JupiterAdapter = class extends BaseAdapter {
  id = "jupiter";
  name = "Jupiter Perps";
  has = {
    // Market data
    fetchMarkets: true,
    fetchTicker: true,
    fetchOrderBook: true,
    // Synthetic orderbook from pool liquidity
    fetchTrades: false,
    // No public trade feed
    fetchFundingRate: true,
    // Returns borrow fee as funding rate
    fetchFundingRateHistory: false,
    // No historical borrow fees API
    fetchOHLCV: false,
    // No candle data API
    // Trading (now supported via Solana transactions)
    createOrder: true,
    cancelOrder: false,
    // Jupiter uses instant execution
    cancelAllOrders: false,
    createBatchOrders: false,
    cancelBatchOrders: false,
    // Account data
    fetchPositions: true,
    fetchBalance: true,
    fetchOpenOrders: false,
    // Jupiter uses instant execution
    fetchOrderHistory: false,
    fetchMyTrades: false,
    // Position management
    setLeverage: false,
    // Leverage set per-trade
    setMarginMode: false,
    // Always isolated margin
    // WebSocket (not supported yet)
    watchOrderBook: false,
    watchTrades: false,
    watchTicker: false,
    watchPositions: false,
    watchOrders: false,
    watchBalance: false
  };
  normalizer;
  auth;
  solanaClient;
  instructionBuilder;
  priceCache = /* @__PURE__ */ new Map();
  priceCacheTTL = 5e3;
  // 5 second cache for prices
  adapterConfig;
  constructor(config = {}) {
    super({
      timeout: 3e4,
      ...config
    });
    this.adapterConfig = config;
    this.normalizer = new JupiterNormalizer();
    if (config.privateKey || config.walletAddress) {
      this.auth = new JupiterAuth({
        privateKey: config.privateKey,
        walletAddress: config.walletAddress,
        rpcEndpoint: config.rpcEndpoint
      });
    }
  }
  // ==========================================================================
  // Connection Management
  // ==========================================================================
  async initialize() {
    if (this._isReady) {
      this.debug("Already initialized");
      return;
    }
    this.debug("Initializing Jupiter adapter...");
    try {
      await this.fetchPrices(["SOL"]);
      if (this.auth) {
        await this.auth.ensureInitialized();
        this.solanaClient = new SolanaClient({
          rpcEndpoint: this.adapterConfig.rpcEndpoint,
          commitment: "confirmed"
        });
        await this.solanaClient.initialize();
        this.instructionBuilder = new JupiterInstructionBuilder();
        await this.instructionBuilder.initialize();
      }
      this._isReady = true;
      this.info("Jupiter adapter initialized successfully");
    } catch (error) {
      const mappedError = mapJupiterError(error);
      this.error("Failed to initialize Jupiter adapter", mappedError);
      throw mappedError;
    }
  }
  // ==========================================================================
  // Symbol Conversion
  // ==========================================================================
  symbolToExchange(symbol) {
    return unifiedToJupiter(symbol);
  }
  symbolFromExchange(exchangeSymbol) {
    return jupiterToUnified(exchangeSymbol);
  }
  // ==========================================================================
  // Market Data
  // ==========================================================================
  async fetchMarkets(params) {
    this.ensureInitialized();
    const cached = this.getPreloadedMarkets();
    if (cached) {
      return this.filterMarkets(cached, params);
    }
    try {
      const markets = Object.entries(JUPITER_MARKETS).map(([key, config]) => ({
        id: key,
        symbol: jupiterToUnified(key),
        base: config.baseToken,
        quote: "USD",
        settle: "USD",
        active: true,
        minAmount: config.minPositionSize,
        maxAmount: 1e7,
        // $10M max position
        minCost: 10,
        pricePrecision: Math.max(0, -Math.floor(Math.log10(config.tickSize))),
        amountPrecision: Math.max(0, -Math.floor(Math.log10(config.stepSize))),
        priceTickSize: config.tickSize,
        amountStepSize: config.stepSize,
        makerFee: 6e-4,
        // 0.06% fee
        takerFee: 6e-4,
        maxLeverage: config.maxLeverage,
        fundingIntervalHours: 1,
        // Jupiter uses hourly borrow fees
        contractSize: 1,
        info: {
          tokenMint: JUPITER_TOKEN_MINTS[config.baseToken],
          marginMode: "isolated",
          positionMode: "one-way"
        }
      }));
      return this.filterMarkets(markets, params);
    } catch (error) {
      throw mapJupiterError(error);
    }
  }
  async fetchTicker(symbol) {
    this.ensureInitialized();
    const jupiterSymbol = this.symbolToExchange(symbol);
    if (!isValidMarket(jupiterSymbol)) {
      throw new Error(`Invalid market: ${symbol}`);
    }
    try {
      const baseToken = jupiterSymbol.replace("-PERP", "");
      const mint = JUPITER_TOKEN_MINTS[baseToken];
      if (!mint) {
        throw new Error(`Unknown token: ${baseToken}`);
      }
      const priceData = await this.fetchPrice(mint);
      return this.normalizer.normalizeTicker(jupiterSymbol, priceData);
    } catch (error) {
      throw mapJupiterError(error);
    }
  }
  async fetchOrderBook(symbol, _params) {
    this.ensureInitialized();
    const jupiterSymbol = this.symbolToExchange(symbol);
    if (!isValidMarket(jupiterSymbol)) {
      throw new Error(`Invalid market: ${symbol}`);
    }
    try {
      const baseToken = jupiterSymbol.replace("-PERP", "");
      const mint = JUPITER_TOKEN_MINTS[baseToken];
      if (!mint) {
        throw new Error(`Unknown token: ${baseToken}`);
      }
      const priceData = await this.fetchPrice(mint);
      const currentPrice = parseFloat(priceData.price);
      return this.normalizer.normalizeOrderBook(jupiterSymbol, currentPrice);
    } catch (error) {
      throw mapJupiterError(error);
    }
  }
  async fetchTrades(_symbol, _params) {
    throw new NotSupportedError(
      "fetchTrades is not supported. Jupiter Perps trades are on-chain only.",
      "NOT_SUPPORTED",
      "jupiter"
    );
  }
  async fetchFundingRate(symbol) {
    this.ensureInitialized();
    const jupiterSymbol = this.symbolToExchange(symbol);
    if (!isValidMarket(jupiterSymbol)) {
      throw new Error(`Invalid market: ${symbol}`);
    }
    try {
      const baseToken = jupiterSymbol.replace("-PERP", "");
      const mint = JUPITER_TOKEN_MINTS[baseToken];
      if (!mint) {
        throw new Error(`Unknown token: ${baseToken}`);
      }
      const priceData = await this.fetchPrice(mint);
      const currentPrice = parseFloat(priceData.price);
      const mockCustody = this.createMockCustodyForFunding();
      return this.normalizer.normalizeFundingRate(jupiterSymbol, mockCustody, currentPrice);
    } catch (error) {
      throw mapJupiterError(error);
    }
  }
  async fetchFundingRateHistory(_symbol, _since, _limit) {
    this.warn("Jupiter Perps does not provide historical funding rate data");
    return [];
  }
  // ==========================================================================
  // Account Data
  // ==========================================================================
  async fetchPositions(symbols) {
    this.ensureInitialized();
    if (!this.auth?.canRead()) {
      throw new Error("Wallet address required to fetch positions");
    }
    if (!this.solanaClient) {
      throw new Error("Solana client not initialized");
    }
    const walletAddress = this.auth.getWalletAddress();
    if (!walletAddress) {
      throw new Error("Wallet address not configured");
    }
    try {
      const positionAccounts = await this.solanaClient.getJupiterPositions(walletAddress);
      const positions = [];
      for (const { pubkey, account } of positionAccounts) {
        try {
          const positionData = this.parsePositionAccount(account.data);
          const symbol = this.getSymbolFromCustody(positionData.custody);
          if (!symbol) continue;
          const jupiterSymbol = unifiedToJupiter(symbol);
          const baseToken = jupiterSymbol.replace("-PERP", "");
          const mint = JUPITER_TOKEN_MINTS[baseToken];
          if (!mint) continue;
          const priceData = await this.fetchPrice(mint);
          const markPrice = parseFloat(priceData.price);
          positions.push(this.normalizePosition(pubkey, positionData, markPrice, symbol));
        } catch (error) {
          this.warn(`Failed to parse position ${pubkey}: ${error}`);
        }
      }
      if (symbols && symbols.length > 0) {
        return positions.filter((p) => symbols.includes(p.symbol));
      }
      return positions;
    } catch (error) {
      throw mapJupiterError(error);
    }
  }
  async fetchBalance() {
    this.ensureInitialized();
    if (!this.auth?.canRead()) {
      throw new Error("Wallet address required to fetch balance");
    }
    const walletAddress = this.auth.getWalletAddress();
    if (!walletAddress) {
      throw new Error("Wallet address not configured");
    }
    try {
      const balances = [];
      const solBalance = await this.auth.getSolBalance();
      balances.push({
        currency: "SOL",
        total: solBalance,
        free: solBalance,
        used: 0
      });
      try {
        const usdcBalance = await this.auth.getTokenBalance(JUPITER_TOKEN_MINTS.USDC);
        const usdcAmount = usdcBalance / 1e6;
        balances.push({
          currency: "USDC",
          total: usdcAmount,
          free: usdcAmount,
          used: 0
        });
      } catch {
        balances.push({
          currency: "USDC",
          total: 0,
          free: 0,
          used: 0
        });
      }
      try {
        const usdtBalance = await this.auth.getTokenBalance(JUPITER_TOKEN_MINTS.USDT);
        const usdtAmount = usdtBalance / 1e6;
        balances.push({
          currency: "USDT",
          total: usdtAmount,
          free: usdtAmount,
          used: 0
        });
      } catch {
        balances.push({
          currency: "USDT",
          total: 0,
          free: 0,
          used: 0
        });
      }
      return balances;
    } catch (error) {
      throw mapJupiterError(error);
    }
  }
  async fetchOpenOrders(_symbol) {
    return [];
  }
  // ==========================================================================
  // Trading Operations
  // ==========================================================================
  async createOrder(request) {
    this.ensureInitialized();
    if (!this.auth?.canSign()) {
      throw new Error("Private key required for trading");
    }
    if (!this.solanaClient || !this.instructionBuilder) {
      throw new Error("Solana client not initialized");
    }
    const walletAddress = this.auth.getWalletAddress();
    if (!walletAddress) {
      throw new Error("Wallet address not configured");
    }
    const jupiterSymbol = this.symbolToExchange(request.symbol);
    if (!isValidMarket(jupiterSymbol)) {
      throw new Error(`Invalid market: ${request.symbol}`);
    }
    const leverage = request.leverage || 1;
    const validation = validateOrderParams({
      symbol: request.symbol,
      side: request.side === "buy" ? "long" : "short",
      sizeUsd: request.amount * (request.price || await this.getCurrentPrice(request.symbol)),
      leverage
    });
    if (!validation.valid) {
      throw new Error(`Order validation failed: ${validation.errors.join(", ")}`);
    }
    try {
      const currentPrice = request.price || await this.getCurrentPrice(request.symbol);
      const sizeUsd = request.amount * currentPrice;
      const collateralUsd = sizeUsd / leverage;
      const side = request.side === "buy" ? "long" : "short";
      const accounts = await this.instructionBuilder.resolvePositionAccounts(
        walletAddress,
        request.symbol,
        side
      );
      accounts.ownerTokenAccount = await this.auth.getAssociatedTokenAddress(JUPITER_TOKEN_MINTS.USDC);
      const instruction = await this.instructionBuilder.buildOpenPositionInstruction(
        {
          owner: walletAddress,
          side,
          symbol: request.symbol,
          sizeUsd,
          collateralAmount: collateralUsd,
          priceLimit: request.price
        },
        accounts
      );
      const transaction = await this.solanaClient.createTransaction();
      await this.solanaClient.addInstructions(transaction, [instruction]);
      const { PublicKey } = await import("@solana/web3.js");
      transaction.feePayer = new PublicKey(walletAddress);
      const signedTx = await this.auth.signTransaction(transaction);
      const keypair = this.auth.getKeypair();
      if (!keypair) {
        throw new Error("Keypair not available");
      }
      const result = await this.solanaClient.sendTransaction(signedTx, [keypair]);
      const orderId = result.signature;
      const timestamp = Date.now();
      return {
        id: orderId,
        clientOrderId: request.clientOrderId,
        timestamp,
        symbol: request.symbol,
        type: "market",
        // Jupiter uses instant execution
        side: request.side,
        price: currentPrice,
        amount: request.amount,
        filled: request.amount,
        // Instant execution
        remaining: 0,
        status: "closed",
        averagePrice: currentPrice,
        reduceOnly: request.reduceOnly || false,
        postOnly: false,
        info: {
          txSignature: result.signature,
          slot: result.slot,
          leverage,
          collateralUsd,
          cost: sizeUsd,
          fee: sizeUsd * 6e-4
          // 0.06% fee
        }
      };
    } catch (error) {
      throw mapJupiterError(error);
    }
  }
  async cancelOrder(_orderId, _symbol) {
    throw new Error("Jupiter uses instant execution - no orders to cancel");
  }
  async cancelAllOrders(_symbol) {
    throw new Error("Jupiter uses instant execution - no orders to cancel");
  }
  /**
   * Close a position
   */
  async closePosition(positionId, params) {
    this.ensureInitialized();
    if (!this.auth?.canSign()) {
      throw new Error("Private key required for trading");
    }
    if (!this.solanaClient || !this.instructionBuilder) {
      throw new Error("Solana client not initialized");
    }
    const walletAddress = this.auth.getWalletAddress();
    if (!walletAddress) {
      throw new Error("Wallet address not configured");
    }
    try {
      const positions = await this.fetchPositions();
      const position = positions.find((p) => p.info?.id === positionId);
      if (!position) {
        throw new Error(`Position not found: ${positionId}`);
      }
      const side = position.side === "long" ? "long" : "short";
      const accounts = await this.instructionBuilder.resolvePositionAccounts(
        walletAddress,
        position.symbol,
        side
      );
      accounts.ownerTokenAccount = await this.auth.getAssociatedTokenAddress(JUPITER_TOKEN_MINTS.USDC);
      const instruction = await this.instructionBuilder.buildClosePositionInstruction(
        {
          owner: walletAddress,
          position: positionId,
          sizeUsd: params?.sizeUsd,
          priceLimit: params?.priceLimit
        },
        accounts
      );
      const transaction = await this.solanaClient.createTransaction();
      await this.solanaClient.addInstructions(transaction, [instruction]);
      const { PublicKey } = await import("@solana/web3.js");
      transaction.feePayer = new PublicKey(walletAddress);
      const signedTx = await this.auth.signTransaction(transaction);
      const keypair = this.auth.getKeypair();
      if (!keypair) {
        throw new Error("Keypair not available");
      }
      const result = await this.solanaClient.sendTransaction(signedTx, [keypair]);
      const timestamp = Date.now();
      const positionSize = Math.abs(position.size);
      const notional = positionSize * position.markPrice;
      return {
        id: result.signature,
        timestamp,
        symbol: position.symbol,
        type: "market",
        side: position.side === "long" ? "sell" : "buy",
        price: position.markPrice,
        amount: positionSize,
        filled: positionSize,
        remaining: 0,
        status: "closed",
        averagePrice: position.markPrice,
        reduceOnly: true,
        postOnly: false,
        info: {
          txSignature: result.signature,
          slot: result.slot,
          closedPositionId: positionId,
          cost: notional,
          fee: notional * 6e-4
        }
      };
    } catch (error) {
      throw mapJupiterError(error);
    }
  }
  async fetchOrderHistory(_symbol, _since, _limit) {
    this.warn("Jupiter Perps does not maintain order history - trades are instant");
    return [];
  }
  async fetchMyTrades(_symbol, _since, _limit) {
    this.warn("Trade history requires indexing on-chain transactions");
    return [];
  }
  async setLeverage(_symbol, _leverage) {
    throw new Error("Jupiter leverage is set per-trade, not globally");
  }
  // ==========================================================================
  // Health Check
  // ==========================================================================
  async performApiHealthCheck() {
    await this.fetchPrices(["SOL"]);
  }
  // ==========================================================================
  // Helper Methods
  // ==========================================================================
  /**
   * Get current price for a symbol
   */
  async getCurrentPrice(symbol) {
    const jupiterSymbol = this.symbolToExchange(symbol);
    const baseToken = jupiterSymbol.replace("-PERP", "");
    const mint = JUPITER_TOKEN_MINTS[baseToken];
    if (!mint) {
      throw new Error(`Unknown token for market: ${symbol}`);
    }
    const priceData = await this.fetchPrice(mint);
    return parseFloat(priceData.price);
  }
  /**
   * Fetch price from Jupiter Price API
   */
  async fetchPrice(tokenMint) {
    const cached = this.priceCache.get(tokenMint);
    if (cached && Date.now() - cached.timestamp < this.priceCacheTTL) {
      return cached.price;
    }
    const prices = await this.fetchPrices([tokenMint]);
    const price = prices[tokenMint];
    if (!price) {
      throw new Error(`Price not available for ${tokenMint}`);
    }
    return price;
  }
  /**
   * Fetch prices for multiple tokens
   */
  async fetchPrices(tokenMints) {
    const mints = tokenMints.map((t) => {
      if (t in JUPITER_TOKEN_MINTS) {
        return JUPITER_TOKEN_MINTS[t];
      }
      return t;
    });
    const url = buildPriceApiUrl(mints);
    const response = await this.request("GET", url);
    for (const [id, data] of Object.entries(response.data)) {
      this.priceCache.set(id, { price: data, timestamp: Date.now() });
    }
    return response.data;
  }
  /**
   * Filter markets by params
   */
  filterMarkets(markets, params) {
    if (!params) return markets;
    let filtered = markets;
    if (params.active !== void 0) {
      filtered = filtered.filter((m) => m.active === params.active);
    }
    if (params.ids && params.ids.length > 0) {
      filtered = filtered.filter((m) => params.ids.includes(m.id));
    }
    return filtered;
  }
  /**
   * Create mock custody account for funding rate calculation
   */
  createMockCustodyForFunding() {
    return {
      pool: "",
      mint: "",
      tokenAccount: "",
      decimals: 6,
      isStable: false,
      oracle: {
        oracleType: "Pyth",
        oracleAccount: "",
        maxPriceAge: 60,
        maxPriceDeviation: 100
      },
      pricing: {
        useEma: true,
        tradeSpread: 10,
        swapSpread: 10,
        minInitialLeverage: 1,
        maxInitialLeverage: 250,
        maxLeverage: 250,
        maxPositionLockedUsd: 1e7,
        maxUtilization: 0.8
      },
      trading: {
        tradingEnabled: true,
        allowOpenPosition: true,
        allowClosePosition: true,
        allowAddCollateral: true,
        allowRemoveCollateral: true,
        allowIncreaseSize: true,
        allowDecreaseSize: true
      },
      fundingRateState: {
        cumulativeInterestRate: "0",
        lastUpdate: Math.floor(Date.now() / 1e3),
        hourlyBorrowRate: "0.0001"
        // 0.01% per hour
      },
      assets: {
        owned: "0",
        locked: "0",
        guaranteedUsd: "0",
        globalShortSizes: "0",
        globalShortAveragePrices: "0"
      },
      bump: 0
    };
  }
  /**
   * Parse position account data from buffer
   */
  parsePositionAccount(data) {
    let offset = 8;
    const owner = data.slice(offset, offset + 32).toString("hex");
    offset += 32;
    const pool = data.slice(offset, offset + 32).toString("hex");
    offset += 32;
    const custody = data.slice(offset, offset + 32).toString("hex");
    offset += 32;
    const collateralCustody = data.slice(offset, offset + 32).toString("hex");
    offset += 32;
    const openTime = Number(data.readBigUInt64LE(offset));
    offset += 8;
    const updateTime = Number(data.readBigUInt64LE(offset));
    offset += 8;
    const sideValue = data.readUInt8(offset);
    offset += 1;
    const side = sideValue === 0 ? "Long" : "Short";
    const priceValue = data.readBigUInt64LE(offset);
    offset += 8;
    const price = (Number(priceValue) / 1e6).toString();
    const sizeUsdValue = data.readBigUInt64LE(offset);
    offset += 8;
    const sizeUsd = (Number(sizeUsdValue) / 1e6).toString();
    const sizeTokensValue = data.readBigUInt64LE(offset);
    offset += 8;
    const sizeTokens = (Number(sizeTokensValue) / 1e9).toString();
    const collateralUsdValue = data.readBigUInt64LE(offset);
    offset += 8;
    const collateralUsd = (Number(collateralUsdValue) / 1e6).toString();
    const unrealizedPnlValue = data.readBigInt64LE(offset);
    offset += 8;
    const unrealizedPnl = (Number(unrealizedPnlValue) / 1e6).toString();
    const realizedPnlValue = data.readBigInt64LE(offset);
    offset += 8;
    const realizedPnl = (Number(realizedPnlValue) / 1e6).toString();
    return {
      owner,
      pool,
      custody,
      collateralCustody,
      openTime,
      updateTime,
      side,
      price,
      sizeUsd,
      sizeTokens,
      collateralUsd,
      unrealizedPnl,
      realizedPnl,
      cumulativeInterestSnapshot: "0",
      lockedAmount: "0",
      bump: 0
    };
  }
  /**
   * Get symbol from custody address
   */
  getSymbolFromCustody(_custody) {
    return "SOL/USD:USD";
  }
  /**
   * Normalize position to SDK format
   */
  normalizePosition(pubkey, data, markPrice, symbol) {
    const side = data.side === "Long" ? "long" : "short";
    const entryPrice = parseFloat(data.price);
    const sizeUsd = parseFloat(data.sizeUsd);
    const sizeTokens = parseFloat(data.sizeTokens);
    const collateralUsd = parseFloat(data.collateralUsd);
    const unrealizedPnl = parseFloat(data.unrealizedPnl);
    const leverage = sizeUsd / collateralUsd;
    const liquidationPrice = calculateLiquidationPrice(
      side,
      entryPrice,
      collateralUsd,
      sizeUsd
    );
    return {
      symbol,
      side,
      size: sizeTokens,
      entryPrice,
      markPrice,
      leverage,
      unrealizedPnl,
      realizedPnl: parseFloat(data.realizedPnl),
      liquidationPrice,
      marginMode: "isolated",
      marginRatio: collateralUsd / sizeUsd,
      margin: collateralUsd,
      maintenanceMargin: sizeUsd * 0.01,
      // 1% maintenance margin
      timestamp: parseOnChainTimestamp(data.updateTime),
      info: {
        id: pubkey,
        owner: data.owner,
        openTime: data.openTime,
        notional: sizeUsd,
        percentage: unrealizedPnl / collateralUsd * 100
      }
    };
  }
  /**
   * Get wallet address (for position queries)
   */
  async getAddress() {
    return this.auth?.getWalletAddress();
  }
};

// src/adapters/drift/constants.ts
var DRIFT_API_URLS = {
  mainnet: {
    dlob: "https://dlob.drift.trade",
    data: "https://data.api.drift.trade",
    swift: "https://swift.drift.trade",
    rpc: "https://api.mainnet-beta.solana.com"
  },
  devnet: {
    dlob: "https://master.dlob.drift.trade",
    data: "https://data.api.drift.trade",
    swift: "https://master.swift.drift.trade",
    rpc: "https://api.devnet.solana.com"
  }
};
var DRIFT_MAINNET_DLOB_API = DRIFT_API_URLS.mainnet.dlob;
var DRIFT_MAINNET_DATA_API = DRIFT_API_URLS.mainnet.data;
var DRIFT_DEVNET_DLOB_API = DRIFT_API_URLS.devnet.dlob;
var DRIFT_PRECISION = {
  BASE: 1e9,
  // BASE_PRECISION - for perp base asset amounts
  QUOTE: 1e6,
  // QUOTE_PRECISION - for quote/USD amounts
  PRICE: 1e6,
  // PRICE_PRECISION - for prices
  FUNDING_RATE: 1e9,
  // FUNDING_RATE_PRECISION
  MARGIN: 1e4,
  // MARGIN_PRECISION - for margin ratios (basis points)
  PEG: 1e6,
  // PEG_PRECISION - for AMM peg
  PERCENTAGE: 1e6
  // PERCENTAGE_PRECISION
};
var DRIFT_PERP_MARKETS = {
  "SOL-PERP": {
    marketIndex: 0,
    symbol: "SOL/USD:USD",
    baseAsset: "SOL",
    maxLeverage: 20,
    minOrderSize: 0.1,
    tickSize: 1e-3,
    stepSize: 0.1,
    contractTier: "B",
    maintenanceMarginRatio: 0.05,
    // 5%
    initialMarginRatio: 0.1
    // 10%
  },
  "BTC-PERP": {
    marketIndex: 1,
    symbol: "BTC/USD:USD",
    baseAsset: "BTC",
    maxLeverage: 20,
    minOrderSize: 1e-3,
    tickSize: 0.1,
    stepSize: 1e-3,
    contractTier: "A",
    maintenanceMarginRatio: 0.05,
    initialMarginRatio: 0.1
  },
  "ETH-PERP": {
    marketIndex: 2,
    symbol: "ETH/USD:USD",
    baseAsset: "ETH",
    maxLeverage: 20,
    minOrderSize: 0.01,
    tickSize: 0.01,
    stepSize: 0.01,
    contractTier: "B",
    maintenanceMarginRatio: 0.05,
    initialMarginRatio: 0.1
  },
  "APT-PERP": {
    marketIndex: 3,
    symbol: "APT/USD:USD",
    baseAsset: "APT",
    maxLeverage: 10,
    minOrderSize: 1,
    tickSize: 1e-3,
    stepSize: 1,
    contractTier: "B",
    maintenanceMarginRatio: 0.1,
    initialMarginRatio: 0.2
  },
  "1MBONK-PERP": {
    marketIndex: 4,
    symbol: "1MBONK/USD:USD",
    baseAsset: "1MBONK",
    maxLeverage: 10,
    minOrderSize: 1,
    tickSize: 1e-5,
    stepSize: 1,
    contractTier: "C",
    maintenanceMarginRatio: 0.1,
    initialMarginRatio: 0.2
  },
  "MATIC-PERP": {
    marketIndex: 5,
    symbol: "MATIC/USD:USD",
    baseAsset: "MATIC",
    maxLeverage: 10,
    minOrderSize: 10,
    tickSize: 1e-4,
    stepSize: 10,
    contractTier: "B",
    maintenanceMarginRatio: 0.1,
    initialMarginRatio: 0.2
  },
  "ARB-PERP": {
    marketIndex: 6,
    symbol: "ARB/USD:USD",
    baseAsset: "ARB",
    maxLeverage: 10,
    minOrderSize: 10,
    tickSize: 1e-4,
    stepSize: 10,
    contractTier: "B",
    maintenanceMarginRatio: 0.1,
    initialMarginRatio: 0.2
  },
  "DOGE-PERP": {
    marketIndex: 7,
    symbol: "DOGE/USD:USD",
    baseAsset: "DOGE",
    maxLeverage: 10,
    minOrderSize: 100,
    tickSize: 1e-5,
    stepSize: 100,
    contractTier: "B",
    maintenanceMarginRatio: 0.1,
    initialMarginRatio: 0.2
  },
  "BNB-PERP": {
    marketIndex: 8,
    symbol: "BNB/USD:USD",
    baseAsset: "BNB",
    maxLeverage: 10,
    minOrderSize: 0.1,
    tickSize: 0.01,
    stepSize: 0.1,
    contractTier: "B",
    maintenanceMarginRatio: 0.1,
    initialMarginRatio: 0.2
  },
  "SUI-PERP": {
    marketIndex: 9,
    symbol: "SUI/USD:USD",
    baseAsset: "SUI",
    maxLeverage: 10,
    minOrderSize: 10,
    tickSize: 1e-4,
    stepSize: 10,
    contractTier: "B",
    maintenanceMarginRatio: 0.1,
    initialMarginRatio: 0.2
  },
  "PEPE-PERP": {
    marketIndex: 10,
    symbol: "1MPEPE/USD:USD",
    baseAsset: "1MPEPE",
    maxLeverage: 10,
    minOrderSize: 1,
    tickSize: 1e-5,
    stepSize: 1,
    contractTier: "C",
    maintenanceMarginRatio: 0.1,
    initialMarginRatio: 0.2
  }
};
var DRIFT_MARKET_INDEX_MAP = Object.entries(
  DRIFT_PERP_MARKETS
).reduce(
  (acc, [key, config]) => {
    acc[config.marketIndex] = key;
    return acc;
  },
  {}
);
function unifiedToDrift(symbol) {
  const parts = symbol.split("/");
  const base = parts[0];
  if (!base) {
    throw new Error(`Invalid symbol format: ${symbol}`);
  }
  return `${base}-PERP`;
}
function driftToUnified(exchangeSymbol) {
  const base = exchangeSymbol.replace("-PERP", "");
  return `${base}/USD:USD`;
}
function getMarketIndex(symbol) {
  const driftSymbol = symbol.includes("-PERP") ? symbol : unifiedToDrift(symbol);
  const market = DRIFT_PERP_MARKETS[driftSymbol];
  if (!market) {
    throw new Error(`Unknown market: ${symbol}`);
  }
  return market.marketIndex;
}
var DRIFT_ERROR_MESSAGES = {
  "insufficient collateral": "INSUFFICIENT_MARGIN",
  "insufficient balance": "INSUFFICIENT_BALANCE",
  "position does not exist": "POSITION_NOT_FOUND",
  "order does not exist": "ORDER_NOT_FOUND",
  "max leverage exceeded": "MAX_LEVERAGE_EXCEEDED",
  "min order size": "MIN_ORDER_SIZE",
  "oracle price unavailable": "ORACLE_ERROR",
  "market paused": "MARKET_PAUSED",
  "reduce only": "REDUCE_ONLY_VIOLATION",
  "post only": "POST_ONLY_VIOLATION",
  "rate limit": "RATE_LIMIT_EXCEEDED",
  "transaction failed": "TRANSACTION_FAILED",
  "liquidation": "LIQUIDATION"
};

// src/adapters/drift/DriftNormalizer.ts
var DriftNormalizer = class {
  /**
   * Normalize perp market account to unified Market
   */
  normalizeMarket(market) {
    const marketKey = DRIFT_MARKET_INDEX_MAP[market.marketIndex];
    const config = marketKey ? DRIFT_PERP_MARKETS[marketKey] : void 0;
    const symbol = config?.symbol || driftToUnified(marketKey || `MARKET-${market.marketIndex}`);
    const tickSize = config?.tickSize || parseFloat(market.amm.orderTickSize) / DRIFT_PRECISION.PRICE;
    const stepSize = config?.stepSize || parseFloat(market.amm.orderStepSize) / DRIFT_PRECISION.BASE;
    const minOrderSize = config?.minOrderSize || parseFloat(market.amm.minOrderSize) / DRIFT_PRECISION.BASE;
    return {
      id: marketKey || `PERP-${market.marketIndex}`,
      symbol,
      base: config?.baseAsset || market.name?.split("-")[0] || `ASSET${market.marketIndex}`,
      quote: "USD",
      settle: "USD",
      active: market.status === "active",
      minAmount: minOrderSize,
      maxAmount: parseFloat(market.amm.maxPositionSize) / DRIFT_PRECISION.BASE,
      pricePrecision: this.getPrecisionFromTickSize(tickSize),
      amountPrecision: this.getPrecisionFromTickSize(stepSize),
      priceTickSize: tickSize,
      amountStepSize: stepSize,
      makerFee: -2e-4,
      // Drift rebates makers (-0.02%)
      takerFee: 1e-3,
      // 0.1% taker fee (varies by tier)
      maxLeverage: config?.maxLeverage || Math.floor(DRIFT_PRECISION.MARGIN / market.marginRatioInitial),
      fundingIntervalHours: 1,
      contractSize: 1,
      info: {
        marketIndex: market.marketIndex,
        contractTier: config?.contractTier || market.contractTier,
        marginRatioInitial: market.marginRatioInitial / DRIFT_PRECISION.MARGIN,
        marginRatioMaintenance: market.marginRatioMaintenance / DRIFT_PRECISION.MARGIN,
        imfFactor: market.imfFactor,
        numberOfUsers: market.numberOfUsers
      }
    };
  }
  /**
   * Normalize multiple markets
   */
  normalizeMarkets(markets) {
    return markets.map((m) => this.normalizeMarket(m));
  }
  /**
   * Normalize perp position to unified Position
   */
  normalizePosition(position, markPrice, _oraclePrice) {
    const marketKey = DRIFT_MARKET_INDEX_MAP[position.marketIndex];
    const config = marketKey ? DRIFT_PERP_MARKETS[marketKey] : void 0;
    const symbol = config?.symbol || driftToUnified(marketKey || `MARKET-${position.marketIndex}`);
    const baseAmount = parseFloat(position.baseAssetAmount) / DRIFT_PRECISION.BASE;
    const quoteAmount = parseFloat(position.quoteAssetAmount) / DRIFT_PRECISION.QUOTE;
    const quoteEntry = parseFloat(position.quoteEntryAmount) / DRIFT_PRECISION.QUOTE;
    const settledPnl = parseFloat(position.settledPnl) / DRIFT_PRECISION.QUOTE;
    const side = baseAmount >= 0 ? "long" : "short";
    const size = Math.abs(baseAmount);
    const entryPrice = size > 0 ? Math.abs(quoteEntry) / size : 0;
    const notional = size * markPrice;
    const unrealizedPnl = this.calculateUnrealizedPnl(side, size, entryPrice, markPrice);
    const margin = Math.abs(quoteAmount);
    const leverage = margin > 0 ? notional / margin : 0;
    const maintenanceMargin = config?.maintenanceMarginRatio || 0.05;
    const liquidationPrice = this.calculateLiquidationPrice(
      side,
      entryPrice,
      leverage,
      maintenanceMargin
    );
    const marginRatio = this.calculateMarginRatio(side, entryPrice, markPrice, leverage, maintenanceMargin);
    return {
      symbol,
      side,
      size,
      entryPrice,
      markPrice,
      liquidationPrice,
      leverage,
      marginMode: "cross",
      // Drift uses cross margin
      margin,
      maintenanceMargin: notional * maintenanceMargin,
      marginRatio,
      unrealizedPnl,
      realizedPnl: settledPnl,
      timestamp: Date.now(),
      info: {
        marketIndex: position.marketIndex,
        baseAssetAmount: position.baseAssetAmount,
        quoteAssetAmount: position.quoteAssetAmount,
        lpShares: position.lpShares,
        openOrders: position.openOrders
      }
    };
  }
  /**
   * Normalize order to unified Order
   */
  normalizeOrder(order, marketPrice) {
    const marketKey = DRIFT_MARKET_INDEX_MAP[order.marketIndex];
    const config = marketKey ? DRIFT_PERP_MARKETS[marketKey] : void 0;
    const symbol = config?.symbol || driftToUnified(marketKey || `MARKET-${order.marketIndex}`);
    const baseAmount = parseFloat(order.baseAssetAmount) / DRIFT_PRECISION.BASE;
    const filledAmount = parseFloat(order.baseAssetAmountFilled) / DRIFT_PRECISION.BASE;
    const price = parseFloat(order.price) / DRIFT_PRECISION.PRICE;
    let type = "limit";
    if (order.orderType === "market") type = "market";
    else if (order.orderType === "triggerMarket") type = "stopMarket";
    else if (order.orderType === "triggerLimit") type = "stopLimit";
    let status = "open";
    if (order.status === "filled") status = filledAmount >= baseAmount ? "filled" : "partiallyFilled";
    else if (order.status === "canceled") status = "canceled";
    else if (order.status === "expired") status = "expired";
    return {
      id: order.orderId.toString(),
      symbol,
      type,
      side: order.direction === "long" ? "buy" : "sell",
      amount: baseAmount,
      price: price > 0 ? price : marketPrice,
      stopPrice: order.triggerPrice !== "0" ? parseFloat(order.triggerPrice) / DRIFT_PRECISION.PRICE : void 0,
      status,
      filled: filledAmount,
      remaining: baseAmount - filledAmount,
      averagePrice: filledAmount > 0 ? parseFloat(order.quoteAssetAmountFilled) / DRIFT_PRECISION.QUOTE / filledAmount : void 0,
      reduceOnly: order.reduceOnly,
      postOnly: order.postOnly !== "none",
      clientOrderId: order.userOrderId > 0 ? order.userOrderId.toString() : void 0,
      timestamp: order.slot * 400,
      // Approximate ms from slot
      info: {
        orderId: order.orderId,
        userOrderId: order.userOrderId,
        marketIndex: order.marketIndex,
        orderType: order.orderType,
        auctionDuration: order.auctionDuration,
        oraclePriceOffset: order.oraclePriceOffset
      }
    };
  }
  /**
   * Normalize L2 orderbook
   */
  normalizeOrderBook(orderbook) {
    const marketKey = DRIFT_MARKET_INDEX_MAP[orderbook.marketIndex];
    const config = marketKey ? DRIFT_PERP_MARKETS[marketKey] : void 0;
    const symbol = config?.symbol || driftToUnified(marketKey || `MARKET-${orderbook.marketIndex}`);
    const bids = orderbook.bids.map((b) => [
      parseFloat(b.price) / DRIFT_PRECISION.PRICE,
      parseFloat(b.size) / DRIFT_PRECISION.BASE
    ]);
    const asks = orderbook.asks.map((a) => [
      parseFloat(a.price) / DRIFT_PRECISION.PRICE,
      parseFloat(a.size) / DRIFT_PRECISION.BASE
    ]);
    return {
      symbol,
      exchange: "drift",
      bids,
      asks,
      timestamp: Date.now(),
      sequenceId: orderbook.slot
    };
  }
  /**
   * Normalize trade
   */
  normalizeTrade(trade) {
    const marketKey = DRIFT_MARKET_INDEX_MAP[trade.marketIndex];
    const config = marketKey ? DRIFT_PERP_MARKETS[marketKey] : void 0;
    const symbol = config?.symbol || driftToUnified(marketKey || `MARKET-${trade.marketIndex}`);
    const amount = parseFloat(trade.baseAssetAmount) / DRIFT_PRECISION.BASE;
    const price = parseFloat(trade.fillPrice) / DRIFT_PRECISION.PRICE;
    return {
      id: trade.fillRecordId,
      symbol,
      side: trade.takerOrderDirection === "long" ? "buy" : "sell",
      price,
      amount,
      cost: amount * price,
      timestamp: trade.ts * 1e3,
      info: {
        recordId: trade.recordId,
        taker: trade.taker,
        maker: trade.maker,
        txSig: trade.txSig,
        slot: trade.slot
      }
    };
  }
  /**
   * Normalize funding rate
   */
  normalizeFundingRate(funding, oraclePrice) {
    const marketKey = DRIFT_MARKET_INDEX_MAP[funding.marketIndex];
    const config = marketKey ? DRIFT_PERP_MARKETS[marketKey] : void 0;
    const symbol = config?.symbol || driftToUnified(marketKey || `MARKET-${funding.marketIndex}`);
    const fundingRate = parseFloat(funding.fundingRate) / DRIFT_PRECISION.FUNDING_RATE;
    const markPrice = "markPriceTwap" in funding ? parseFloat(funding.markPriceTwap) / DRIFT_PRECISION.PRICE : oraclePrice || 0;
    const indexPrice = "oraclePrice" in funding ? parseFloat(funding.oraclePrice) / DRIFT_PRECISION.PRICE : parseFloat(funding.oraclePriceTwap) / DRIFT_PRECISION.PRICE;
    const ts = funding.ts * 1e3;
    return {
      symbol,
      fundingRate,
      fundingTimestamp: ts,
      nextFundingTimestamp: ts + 36e5,
      // Next hour
      markPrice,
      indexPrice,
      fundingIntervalHours: 1,
      info: {
        marketIndex: funding.marketIndex,
        fundingRateLong: funding.fundingRateLong,
        fundingRateShort: funding.fundingRateShort,
        cumulativeFundingRateLong: funding.cumulativeFundingRateLong,
        cumulativeFundingRateShort: funding.cumulativeFundingRateShort
      }
    };
  }
  /**
   * Normalize ticker from market stats
   */
  normalizeTicker(stats) {
    const marketKey = DRIFT_MARKET_INDEX_MAP[stats.marketIndex];
    const config = marketKey ? DRIFT_PERP_MARKETS[marketKey] : void 0;
    const symbol = config?.symbol || driftToUnified(marketKey || `MARKET-${stats.marketIndex}`);
    const markPrice = parseFloat(stats.markPrice) / DRIFT_PRECISION.PRICE;
    const oraclePrice = parseFloat(stats.oraclePrice) / DRIFT_PRECISION.PRICE;
    const bidPrice = parseFloat(stats.bidPrice) / DRIFT_PRECISION.PRICE;
    const askPrice = parseFloat(stats.askPrice) / DRIFT_PRECISION.PRICE;
    const volume = parseFloat(stats.volume24h) / DRIFT_PRECISION.QUOTE;
    return {
      symbol,
      timestamp: stats.ts * 1e3,
      last: markPrice,
      bid: bidPrice,
      ask: askPrice,
      high: markPrice,
      // Would need historical data
      low: markPrice,
      open: oraclePrice,
      close: markPrice,
      change: markPrice - oraclePrice,
      percentage: oraclePrice > 0 ? (markPrice - oraclePrice) / oraclePrice * 100 : 0,
      baseVolume: volume / markPrice,
      quoteVolume: volume,
      info: {
        marketIndex: stats.marketIndex,
        oraclePrice,
        openInterest: parseFloat(stats.openInterest) / DRIFT_PRECISION.BASE,
        openInterestLong: parseFloat(stats.openInterestLong) / DRIFT_PRECISION.BASE,
        openInterestShort: parseFloat(stats.openInterestShort) / DRIFT_PRECISION.BASE,
        fundingRate: parseFloat(stats.fundingRate) / DRIFT_PRECISION.FUNDING_RATE,
        nextFundingTs: stats.nextFundingTs
      }
    };
  }
  /**
   * Normalize balance from spot position
   */
  normalizeBalance(position, tokenPrice, tokenSymbol) {
    const scaledBalance = parseFloat(position.scaledBalance);
    const isDeposit = position.balanceType === "deposit";
    const total = isDeposit ? scaledBalance : -scaledBalance;
    return {
      currency: tokenSymbol,
      total,
      free: isDeposit ? total : 0,
      used: isDeposit ? 0 : Math.abs(total),
      usdValue: total * tokenPrice,
      info: {
        marketIndex: position.marketIndex,
        balanceType: position.balanceType,
        cumulativeDeposits: position.cumulativeDeposits
      }
    };
  }
  /**
   * Normalize candle to OHLCV
   */
  normalizeCandle(candle) {
    return [
      candle.start * 1e3,
      parseFloat(candle.open) / DRIFT_PRECISION.PRICE,
      parseFloat(candle.high) / DRIFT_PRECISION.PRICE,
      parseFloat(candle.low) / DRIFT_PRECISION.PRICE,
      parseFloat(candle.close) / DRIFT_PRECISION.PRICE,
      parseFloat(candle.volume) / DRIFT_PRECISION.QUOTE
    ];
  }
  // ==========================================================================
  // Helper Methods
  // ==========================================================================
  /**
   * Calculate unrealized PnL
   */
  calculateUnrealizedPnl(side, size, entryPrice, currentPrice) {
    if (side === "long") {
      return size * (currentPrice - entryPrice);
    } else {
      return size * (entryPrice - currentPrice);
    }
  }
  /**
   * Calculate liquidation price
   */
  calculateLiquidationPrice(side, entryPrice, leverage, maintenanceMargin) {
    if (leverage <= 0) return 0;
    const liquidationThreshold = 1 - maintenanceMargin;
    if (side === "long") {
      return entryPrice * (1 - liquidationThreshold / leverage);
    } else {
      return entryPrice * (1 + liquidationThreshold / leverage);
    }
  }
  /**
   * Calculate margin ratio (percentage until liquidation)
   */
  calculateMarginRatio(side, entryPrice, currentPrice, leverage, maintenanceMargin) {
    if (leverage <= 0 || entryPrice <= 0) return 100;
    const pnlPercent = side === "long" ? (currentPrice - entryPrice) / entryPrice : (entryPrice - currentPrice) / entryPrice;
    const marginUsed = 1 / leverage;
    const currentMargin = marginUsed + pnlPercent;
    return Math.max(0, (currentMargin - maintenanceMargin) / marginUsed * 100);
  }
  /**
   * Get precision from tick size
   */
  getPrecisionFromTickSize(tickSize) {
    if (tickSize >= 1) return 0;
    return Math.max(0, -Math.floor(Math.log10(tickSize)));
  }
};

// src/adapters/drift/orderBuilder.ts
var DriftOrderBuilder = class {
  config;
  constructor(config = {}) {
    this.config = {
      subAccountId: config.subAccountId ?? 0,
      slippageTolerance: config.slippageTolerance ?? 0.01,
      auctionDuration: config.auctionDuration ?? 60
    };
  }
  /**
   * Build order parameters from a unified OrderRequest
   */
  buildOrderParams(request, oraclePrice) {
    const marketKey = unifiedToDrift(request.symbol);
    const marketConfig = DRIFT_PERP_MARKETS[marketKey];
    if (!marketConfig) {
      throw new Error(`Unknown market: ${request.symbol}`);
    }
    this.validateOrder(request, marketConfig);
    const baseAssetAmount = BigInt(
      Math.floor(request.amount * DRIFT_PRECISION.BASE)
    );
    const orderType = this.mapOrderType(request.type);
    const direction = this.getDirection(request.side, request.reduceOnly);
    let price;
    if (request.price) {
      price = BigInt(Math.floor(request.price * DRIFT_PRECISION.PRICE));
    } else if (request.type === "market" && oraclePrice) {
      const slippageMultiplier = direction === "long" ? 1 + this.config.slippageTolerance : 1 - this.config.slippageTolerance;
      price = BigInt(Math.floor(oraclePrice * slippageMultiplier * DRIFT_PRECISION.PRICE));
    }
    let triggerPrice;
    let triggerCondition;
    if (request.stopPrice) {
      triggerPrice = BigInt(Math.floor(request.stopPrice * DRIFT_PRECISION.PRICE));
      triggerCondition = direction === "long" ? "below" : "above";
    }
    const orderParams = {
      orderType,
      marketIndex: marketConfig.marketIndex,
      marketType: "perp",
      direction,
      baseAssetAmount,
      price,
      triggerPrice,
      triggerCondition,
      reduceOnly: request.reduceOnly ?? false,
      postOnly: request.postOnly ?? false,
      immediateOrCancel: request.timeInForce === "IOC",
      userOrderId: request.clientOrderId ? parseInt(request.clientOrderId) : void 0
    };
    if (orderType === "limit") {
      orderParams.auctionDuration = this.config.auctionDuration;
      if (oraclePrice && price) {
        const auctionStartMultiplier = direction === "long" ? 0.995 : 1.005;
        orderParams.auctionStartPrice = BigInt(
          Math.floor(oraclePrice * auctionStartMultiplier * DRIFT_PRECISION.PRICE)
        );
        orderParams.auctionEndPrice = price;
      }
    }
    return orderParams;
  }
  /**
   * Build parameters for closing a position
   */
  buildClosePositionParams(symbol, size, isLong, oraclePrice) {
    const marketKey = unifiedToDrift(symbol);
    const marketConfig = DRIFT_PERP_MARKETS[marketKey];
    if (!marketConfig) {
      throw new Error(`Unknown market: ${symbol}`);
    }
    const baseAssetAmount = BigInt(Math.floor(Math.abs(size) * DRIFT_PRECISION.BASE));
    const direction = isLong ? "short" : "long";
    let price;
    if (oraclePrice) {
      const slippageMultiplier = direction === "long" ? 1 + this.config.slippageTolerance : 1 - this.config.slippageTolerance;
      price = BigInt(Math.floor(oraclePrice * slippageMultiplier * DRIFT_PRECISION.PRICE));
    }
    return {
      orderType: "market",
      marketIndex: marketConfig.marketIndex,
      marketType: "perp",
      direction,
      baseAssetAmount,
      price,
      reduceOnly: true
      // Always reduce-only for closing
    };
  }
  /**
   * Validate order parameters
   */
  validateOrder(request, marketConfig) {
    if (request.amount < marketConfig.minOrderSize) {
      throw new Error(
        `Order size ${request.amount} is below minimum ${marketConfig.minOrderSize} for ${request.symbol}`
      );
    }
    if (request.leverage && request.leverage > marketConfig.maxLeverage) {
      throw new Error(
        `Leverage ${request.leverage}x exceeds maximum ${marketConfig.maxLeverage}x for ${request.symbol}`
      );
    }
    if (request.type === "limit" && !request.price) {
      throw new Error("Price is required for limit orders");
    }
    if ((request.type === "stopMarket" || request.type === "stopLimit") && !request.stopPrice) {
      throw new Error("Stop price is required for trigger orders");
    }
    const stepSize = marketConfig.stepSize;
    const remainder = request.amount % stepSize;
    if (remainder !== 0 && remainder / stepSize > 1e-3) {
      throw new Error(
        `Order amount ${request.amount} does not conform to step size ${stepSize}`
      );
    }
    if (request.price) {
      const tickSize = marketConfig.tickSize;
      const priceRemainder = request.price % tickSize;
      if (priceRemainder !== 0 && priceRemainder / tickSize > 1e-3) {
        throw new Error(
          `Order price ${request.price} does not conform to tick size ${tickSize}`
        );
      }
    }
  }
  /**
   * Map unified order type to Drift order type
   */
  mapOrderType(type) {
    switch (type) {
      case "market":
        return "market";
      case "limit":
        return "limit";
      case "stopMarket":
        return "triggerMarket";
      case "stopLimit":
        return "triggerLimit";
      default:
        return "market";
    }
  }
  /**
   * Get direction based on side and reduce-only flag
   */
  getDirection(side, _reduceOnly) {
    return side === "buy" ? "long" : "short";
  }
  /**
   * Calculate required margin for an order
   */
  calculateRequiredMargin(symbol, amount, price, leverage) {
    const marketKey = unifiedToDrift(symbol);
    const marketConfig = DRIFT_PERP_MARKETS[marketKey];
    if (!marketConfig) {
      throw new Error(`Unknown market: ${symbol}`);
    }
    const notional = amount * price;
    const effectiveLeverage = leverage || 1 / marketConfig.initialMarginRatio;
    const actualLeverage = Math.min(effectiveLeverage, marketConfig.maxLeverage);
    const margin = notional / actualLeverage;
    return {
      margin,
      leverage: actualLeverage
    };
  }
  /**
   * Calculate liquidation price for a position
   */
  calculateLiquidationPrice(symbol, entryPrice, leverage, isLong) {
    const marketKey = unifiedToDrift(symbol);
    const marketConfig = DRIFT_PERP_MARKETS[marketKey];
    if (!marketConfig) {
      throw new Error(`Unknown market: ${symbol}`);
    }
    const maintenanceMargin = marketConfig.maintenanceMarginRatio;
    const liquidationThreshold = 1 - maintenanceMargin;
    if (isLong) {
      return entryPrice * (1 - liquidationThreshold / leverage);
    } else {
      return entryPrice * (1 + liquidationThreshold / leverage);
    }
  }
  /**
   * Get market configuration
   */
  getMarketConfig(symbol) {
    const marketKey = unifiedToDrift(symbol);
    return DRIFT_PERP_MARKETS[marketKey];
  }
  /**
   * Get market index from symbol
   */
  getMarketIndex(symbol) {
    return getMarketIndex(symbol);
  }
  /**
   * Round amount to step size
   */
  roundToStepSize(amount, symbol) {
    const config = this.getMarketConfig(symbol);
    if (!config) {
      return amount;
    }
    const stepSize = config.stepSize;
    return Math.floor(amount / stepSize) * stepSize;
  }
  /**
   * Round price to tick size
   */
  roundToTickSize(price, symbol) {
    const config = this.getMarketConfig(symbol);
    if (!config) {
      return price;
    }
    const tickSize = config.tickSize;
    return Math.round(price / tickSize) * tickSize;
  }
};

// src/adapters/drift/error-codes.ts
function mapDriftError(error) {
  if (error instanceof PerpDEXError) {
    return error;
  }
  if (error instanceof Error) {
    const message = error.message.toLowerCase();
    for (const [pattern, code] of Object.entries(DRIFT_ERROR_MESSAGES)) {
      if (message.includes(pattern)) {
        switch (code) {
          case "INSUFFICIENT_MARGIN":
            return new InsufficientMarginError(error.message, code, "drift", error);
          case "INSUFFICIENT_BALANCE":
            return new InsufficientBalanceError(error.message, code, "drift", void 0, void 0, error);
          case "POSITION_NOT_FOUND":
            return new PositionNotFoundError(error.message, code, "drift", error);
          case "ORDER_NOT_FOUND":
            return new OrderNotFoundError(error.message, code, "drift", error);
          case "MAX_LEVERAGE_EXCEEDED":
          case "MIN_ORDER_SIZE":
          case "REDUCE_ONLY_VIOLATION":
          case "POST_ONLY_VIOLATION":
            return new InvalidOrderError(error.message, code, "drift", error);
          case "ORACLE_ERROR":
          case "MARKET_PAUSED":
            return new ExchangeUnavailableError(error.message, code, "drift", error);
          case "RATE_LIMIT_EXCEEDED":
            return new RateLimitError(error.message, code, "drift", void 0, error);
          case "TRANSACTION_FAILED":
            return new TransactionFailedError(error.message, code, "drift", void 0, error);
          case "LIQUIDATION":
            return new LiquidationError(error.message, code, "drift", error);
        }
      }
    }
    if (message.includes("blockhash") || message.includes("expired")) {
      return new TransactionFailedError(
        "Transaction expired",
        "TRANSACTION_EXPIRED",
        "drift",
        void 0,
        error
      );
    }
    if (message.includes("signature verification")) {
      return new InvalidSignatureError(
        "Invalid transaction signature",
        "INVALID_SIGNATURE",
        "drift",
        error
      );
    }
    if (message.includes("insufficient lamports") || message.includes("insufficient sol")) {
      return new InsufficientBalanceError(
        "Insufficient SOL for transaction fees",
        "INSUFFICIENT_SOL",
        "drift",
        void 0,
        void 0,
        error
      );
    }
    if (message.includes("user account not found")) {
      return new PerpDEXError(
        "Drift user account not initialized",
        "USER_NOT_INITIALIZED",
        "drift",
        error
      );
    }
    if (message.includes("account not found") || message.includes("account does not exist")) {
      return new PerpDEXError(
        "Account not found on chain",
        "ACCOUNT_NOT_FOUND",
        "drift",
        error
      );
    }
    if (message.includes("429") || message.includes("too many requests")) {
      return new RateLimitError("RPC rate limit exceeded", "RATE_LIMIT", "drift", void 0, error);
    }
    if (message.includes("503") || message.includes("502") || message.includes("504")) {
      return new ExchangeUnavailableError(
        "Solana RPC temporarily unavailable",
        "RPC_UNAVAILABLE",
        "drift",
        error
      );
    }
    if (message.includes("timeout") || message.includes("timed out")) {
      return new ExchangeUnavailableError(
        "Request timeout",
        "TIMEOUT",
        "drift",
        error
      );
    }
    if (message.includes("max number of positions")) {
      return new InvalidOrderError(
        "Maximum number of positions reached",
        "MAX_POSITIONS",
        "drift",
        error
      );
    }
    if (message.includes("market not active")) {
      return new ExchangeUnavailableError(
        "Market is not active",
        "MARKET_NOT_ACTIVE",
        "drift",
        error
      );
    }
    if (message.includes("price bands")) {
      return new InvalidOrderError(
        "Order price outside allowed bands",
        "PRICE_BANDS_BREACHED",
        "drift",
        error
      );
    }
    if (message.includes("order would be filled at worse price")) {
      return new InvalidOrderError(
        "Order would be filled at worse price than limit",
        "SLIPPAGE_EXCEEDED",
        "drift",
        error
      );
    }
  }
  return new ExchangeUnavailableError(
    "Unknown exchange error",
    "UNKNOWN_ERROR",
    "drift",
    error
  );
}

// src/adapters/drift/utils.ts
function getMarketConfig2(symbol) {
  const driftSymbol = symbol.includes("-PERP") ? symbol : unifiedToDrift(symbol);
  return DRIFT_PERP_MARKETS[driftSymbol];
}
function isValidMarket2(symbol) {
  const driftSymbol = symbol.includes("-PERP") ? symbol : unifiedToDrift(symbol);
  return driftSymbol in DRIFT_PERP_MARKETS;
}
function buildOrderbookUrl(baseUrl, marketIndex, marketType = "perp", depth) {
  const params = new URLSearchParams({
    marketIndex: marketIndex.toString(),
    marketType
  });
  if (depth) {
    params.set("depth", depth.toString());
  }
  return `${baseUrl}/l2?${params.toString()}`;
}
function buildTradesUrl(baseUrl, marketIndex, marketType = "perp", limit) {
  const params = new URLSearchParams({
    marketIndex: marketIndex.toString(),
    marketType
  });
  if (limit) {
    params.set("limit", limit.toString());
  }
  return `${baseUrl}/trades?${params.toString()}`;
}

// src/adapters/drift/DriftAuth.ts
var DriftAuth = class {
  keypair;
  walletAddress;
  publicKey;
  subAccountId;
  rpcEndpoint;
  isDevnet;
  connection;
  isInitialized = false;
  logger = new Logger("DriftAuth");
  constructor(config) {
    const apiUrls = config.isDevnet ? DRIFT_API_URLS.devnet : DRIFT_API_URLS.mainnet;
    this.rpcEndpoint = config.rpcEndpoint || apiUrls.rpc;
    this.subAccountId = config.subAccountId ?? 0;
    this.isDevnet = config.isDevnet ?? false;
    if (config.privateKey) {
      this.initializeFromPrivateKey(config.privateKey);
    } else if (config.walletAddress) {
      this.walletAddress = config.walletAddress;
    }
  }
  /**
   * Initialize keypair from private key
   */
  initializeFromPrivateKey(privateKey) {
    try {
      const bytes = this.parsePrivateKey(privateKey);
      void this.initKeypairAsync(bytes);
    } catch (error) {
      this.logger.warn(`Failed to initialize keypair: ${error instanceof Error ? error.message : String(error)}`);
    }
  }
  /**
   * Async initialization of keypair (for dynamic import)
   */
  async initKeypairAsync(bytes) {
    try {
      const { Keypair, Connection } = await import("@solana/web3.js");
      this.keypair = Keypair.fromSecretKey(bytes);
      this.publicKey = this.keypair.publicKey;
      this.walletAddress = this.publicKey.toBase58();
      this.connection = new Connection(this.rpcEndpoint, "confirmed");
      this.isInitialized = true;
    } catch (error) {
      this.logger.warn(`Failed to initialize Solana keypair: ${error instanceof Error ? error.message : String(error)}`);
    }
  }
  /**
   * Ensure async initialization is complete
   */
  async ensureInitialized() {
    if (!this.isInitialized && this.walletAddress) {
      try {
        const { Connection, PublicKey } = await import("@solana/web3.js");
        this.connection = new Connection(this.rpcEndpoint, "confirmed");
        if (this.walletAddress) {
          this.publicKey = new PublicKey(this.walletAddress);
        }
        this.isInitialized = true;
      } catch (error) {
        throw new Error(`Failed to initialize Solana connection: ${error instanceof Error ? error.message : String(error)}`);
      }
    }
  }
  /**
   * Sign a request (required by IAuthStrategy interface)
   * Drift uses on-chain transaction signing, not HTTP request signing
   */
  async sign(request) {
    return {
      ...request,
      headers: {}
    };
  }
  /**
   * Drift doesn't use HTTP header authentication
   * All authentication is done via transaction signing
   */
  getHeaders() {
    return {};
  }
  /**
   * Sign a message
   */
  async signMessage(message) {
    if (!this.keypair) {
      throw new Error("Private key required for signing");
    }
    const { sign: sign2 } = await Promise.resolve().then(() => (init_ed25519(), ed25519_exports));
    const messageBytes = new TextEncoder().encode(message);
    return sign2(messageBytes, this.keypair.secretKey.slice(0, 32));
  }
  /**
   * Sign bytes (for transaction signing)
   */
  async signBytes(bytes) {
    if (!this.keypair) {
      throw new Error("Private key required for signing");
    }
    const { sign: sign2 } = await Promise.resolve().then(() => (init_ed25519(), ed25519_exports));
    return sign2(bytes, this.keypair.secretKey.slice(0, 32));
  }
  /**
   * Get the wallet address
   */
  getWalletAddress() {
    return this.walletAddress;
  }
  /**
   * Get the public key
   */
  getPublicKey() {
    return this.publicKey;
  }
  /**
   * Get the keypair (for SDK usage)
   */
  getKeypair() {
    return this.keypair;
  }
  /**
   * Get sub-account ID
   */
  getSubAccountId() {
    return this.subAccountId;
  }
  /**
   * Check if authentication is configured for trading
   */
  canSign() {
    return this.keypair !== void 0;
  }
  /**
   * Check if authentication is configured for read operations
   */
  canRead() {
    return this.walletAddress !== void 0;
  }
  /**
   * Get RPC endpoint
   */
  getRpcEndpoint() {
    return this.rpcEndpoint;
  }
  /**
   * Get whether using devnet
   */
  getIsDevnet() {
    return this.isDevnet;
  }
  /**
   * Get Solana connection
   */
  async getConnection() {
    await this.ensureInitialized();
    if (!this.connection) {
      throw new Error("Connection not initialized");
    }
    return this.connection;
  }
  /**
   * Get SOL balance
   */
  async getSolBalance() {
    await this.ensureInitialized();
    if (!this.connection || !this.publicKey) {
      throw new Error("Connection or public key not initialized");
    }
    const balance = await this.connection.getBalance(this.publicKey);
    return balance / 1e9;
  }
  /**
   * Get token balance for an SPL token
   */
  async getTokenBalance(tokenMint) {
    await this.ensureInitialized();
    if (!this.connection || !this.publicKey) {
      throw new Error("Connection or public key not initialized");
    }
    const { PublicKey } = await import("@solana/web3.js");
    const tokenMintPubkey = new PublicKey(tokenMint);
    const tokenAccounts = await this.connection.getTokenAccountsByOwner(
      this.publicKey,
      { mint: tokenMintPubkey }
    );
    if (tokenAccounts.value.length === 0) {
      return 0;
    }
    const accountInfo = tokenAccounts.value[0];
    if (!accountInfo) {
      return 0;
    }
    const data = accountInfo.account.data;
    const amountBytes = data.slice(64, 72);
    const amount = Buffer.from(amountBytes).readBigUInt64LE();
    return Number(amount);
  }
  /**
   * Create user account PDA info
   */
  getUserAccountInfo() {
    if (!this.walletAddress) return void 0;
    return {
      authority: this.walletAddress,
      subAccountId: this.subAccountId
    };
  }
  // ==========================================================================
  // Private Methods
  // ==========================================================================
  /**
   * Parse private key from various formats
   */
  parsePrivateKey(key) {
    if (key instanceof Uint8Array) {
      return key;
    }
    if (key.startsWith("[")) {
      try {
        const parsed = JSON.parse(key);
        return new Uint8Array(parsed);
      } catch {
        throw new Error("Invalid private key JSON array format");
      }
    }
    if (/^[1-9A-HJ-NP-Za-km-z]+$/.test(key)) {
      try {
        const bs58 = require_cjs2();
        return bs58.decode(key);
      } catch {
        throw new Error("Invalid base58 private key format");
      }
    }
    if (/^(0x)?[0-9a-fA-F]+$/.test(key)) {
      const hex = key.startsWith("0x") ? key.slice(2) : key;
      const bytes = new Uint8Array(hex.length / 2);
      for (let i = 0; i < bytes.length; i++) {
        bytes[i] = parseInt(hex.slice(i * 2, i * 2 + 2), 16);
      }
      return bytes;
    }
    throw new Error("Unsupported private key format");
  }
};

// src/adapters/drift/DriftClientWrapper.ts
var DriftClientWrapper = class {
  config;
  driftClient;
  // Would be DriftClient type
  isInitialized = false;
  logger = new Logger("DriftClientWrapper");
  constructor(config) {
    this.config = config;
  }
  /**
   * Initialize the Drift client and subscribe to user account
   */
  async initialize() {
    if (this.isInitialized) {
      return;
    }
    try {
      const driftSdk = await import("@drift-labs/sdk");
      const {
        DriftClient,
        Wallet: Wallet4,
        BulkAccountLoader,
        getMarketsAndOraclesForSubscription
      } = driftSdk;
      const wallet = new Wallet4(this.config.keypair);
      const { perpMarketIndexes, spotMarketIndexes, oracleInfos } = getMarketsAndOraclesForSubscription(this.config.isDevnet ? "devnet" : "mainnet-beta");
      const bulkAccountLoader = new BulkAccountLoader(
        this.config.connection,
        "confirmed",
        1e3
        // 1 second polling interval
      );
      this.driftClient = new DriftClient({
        connection: this.config.connection,
        wallet,
        programID: new (await import("@solana/web3.js")).PublicKey(
          "dRiftyHA39MWEi3m9aunc5MzRF1JYuBsbn6VPcn33UH"
        ),
        accountSubscription: {
          type: "polling",
          accountLoader: bulkAccountLoader
        },
        perpMarketIndexes,
        spotMarketIndexes,
        oracleInfos,
        env: this.config.isDevnet ? "devnet" : "mainnet-beta",
        subAccountIds: [this.config.subAccountId ?? 0],
        activeSubAccountId: this.config.subAccountId ?? 0
      });
      await this.driftClient.subscribe();
      const userAccountExists = await this.driftClient.getUserAccountExists();
      if (!userAccountExists) {
        this.logger.warn(
          "Drift user account does not exist. Please deposit funds first to create an account."
        );
      } else {
        await this.driftClient.addUser(this.config.subAccountId ?? 0);
      }
      this.isInitialized = true;
    } catch (error) {
      throw new Error(`Failed to initialize Drift client: ${error instanceof Error ? error.message : String(error)}`);
    }
  }
  /**
   * Ensure client is initialized
   */
  ensureInitialized() {
    if (!this.isInitialized) {
      throw new Error("DriftClientWrapper not initialized. Call initialize() first.");
    }
  }
  // ==========================================================================
  // Order Management
  // ==========================================================================
  /**
   * Place a perp order
   */
  async placePerpOrder(params) {
    this.ensureInitialized();
    const driftSdk = await import("@drift-labs/sdk");
    const {
      OrderType: OrderType2,
      PositionDirection,
      MarketType,
      OrderTriggerCondition,
      PostOnlyParams
    } = driftSdk;
    const orderTypeMap = {
      market: OrderType2.MARKET,
      limit: OrderType2.LIMIT,
      triggerMarket: OrderType2.TRIGGER_MARKET,
      triggerLimit: OrderType2.TRIGGER_LIMIT,
      oracle: OrderType2.ORACLE
    };
    const directionMap = {
      long: PositionDirection.LONG,
      short: PositionDirection.SHORT
    };
    const orderParams = {
      orderType: orderTypeMap[params.orderType] || OrderType2.MARKET,
      marketIndex: params.marketIndex,
      marketType: MarketType.PERP,
      direction: directionMap[params.direction] || PositionDirection.LONG,
      baseAssetAmount: params.baseAssetAmount,
      price: params.price,
      triggerPrice: params.triggerPrice,
      triggerCondition: params.triggerCondition === "above" ? OrderTriggerCondition.ABOVE : OrderTriggerCondition.BELOW,
      reduceOnly: params.reduceOnly ?? false,
      postOnly: params.postOnly ? PostOnlyParams.MUST_POST_ONLY : PostOnlyParams.NONE,
      immediateOrCancel: params.immediateOrCancel ?? false,
      maxTs: params.maxTs,
      userOrderId: params.userOrderId,
      oraclePriceOffset: params.oraclePriceOffset,
      auctionDuration: params.auctionDuration,
      auctionStartPrice: params.auctionStartPrice,
      auctionEndPrice: params.auctionEndPrice
    };
    const txSig = await this.driftClient.placePerpOrder(orderParams);
    const confirmation = await this.config.connection.confirmTransaction(txSig, "confirmed");
    return {
      txSig,
      slot: confirmation.context.slot
    };
  }
  /**
   * Cancel an order by ID
   */
  async cancelOrder(orderId) {
    this.ensureInitialized();
    const txSig = await this.driftClient.cancelOrder(orderId);
    await this.config.connection.confirmTransaction(txSig, "confirmed");
    return {
      txSig,
      orderId
    };
  }
  /**
   * Cancel all orders for a market
   */
  async cancelOrdersForMarket(marketIndex) {
    this.ensureInitialized();
    const driftSdk = await import("@drift-labs/sdk");
    const { MarketType } = driftSdk;
    const txSig = await this.driftClient.cancelOrders(
      MarketType.PERP,
      marketIndex
    );
    await this.config.connection.confirmTransaction(txSig, "confirmed");
    const user = this.driftClient.getUser();
    const orders = user.getOpenOrders();
    const canceledIds = orders.filter((o) => o.marketIndex === marketIndex).map((o) => o.orderId);
    return canceledIds.map((orderId) => ({
      txSig,
      orderId
    }));
  }
  /**
   * Cancel all perp orders
   */
  async cancelAllPerpOrders() {
    this.ensureInitialized();
    const driftSdk = await import("@drift-labs/sdk");
    const { MarketType } = driftSdk;
    const txSig = await this.driftClient.cancelOrders(MarketType.PERP);
    await this.config.connection.confirmTransaction(txSig, "confirmed");
    return txSig;
  }
  /**
   * Modify an existing order
   */
  async modifyOrder(orderId, newParams) {
    this.ensureInitialized();
    await this.cancelOrder(orderId);
    const user = this.driftClient.getUser();
    const orders = user.getOpenOrders();
    const originalOrder = orders.find((o) => o.orderId === orderId);
    if (!originalOrder) {
      throw new Error(`Order ${orderId} not found`);
    }
    const mergedParams = {
      orderType: newParams.orderType || originalOrder.orderType,
      marketIndex: newParams.marketIndex ?? originalOrder.marketIndex,
      marketType: "perp",
      direction: newParams.direction || (originalOrder.direction.long ? "long" : "short"),
      baseAssetAmount: newParams.baseAssetAmount ?? originalOrder.baseAssetAmount,
      price: newParams.price ?? originalOrder.price,
      triggerPrice: newParams.triggerPrice ?? originalOrder.triggerPrice,
      reduceOnly: newParams.reduceOnly ?? originalOrder.reduceOnly,
      postOnly: newParams.postOnly ?? originalOrder.postOnly !== "none"
    };
    return this.placePerpOrder(mergedParams);
  }
  // ==========================================================================
  // Account Data
  // ==========================================================================
  /**
   * Get user's perp positions
   */
  async getPerpPositions() {
    this.ensureInitialized();
    const user = this.driftClient.getUser();
    return user.getActivePerpPositions();
  }
  /**
   * Get user's spot positions (balances)
   */
  async getSpotPositions() {
    this.ensureInitialized();
    const user = this.driftClient.getUser();
    return user.getActiveSpotPositions();
  }
  /**
   * Get user's open orders
   */
  async getOpenOrders() {
    this.ensureInitialized();
    const user = this.driftClient.getUser();
    return user.getOpenOrders();
  }
  /**
   * Get free collateral
   */
  async getFreeCollateral() {
    this.ensureInitialized();
    const user = this.driftClient.getUser();
    return user.getFreeCollateral();
  }
  /**
   * Get total collateral
   */
  async getTotalCollateral() {
    this.ensureInitialized();
    const user = this.driftClient.getUser();
    return user.getTotalCollateral();
  }
  /**
   * Get leverage
   */
  async getLeverage() {
    this.ensureInitialized();
    const user = this.driftClient.getUser();
    return user.getLeverage().toNumber() / 1e4;
  }
  /**
   * Get unrealized PnL
   */
  async getUnrealizedPnL() {
    this.ensureInitialized();
    const user = this.driftClient.getUser();
    return user.getUnrealizedPNL();
  }
  // ==========================================================================
  // Market Data
  // ==========================================================================
  /**
   * Get oracle price for a perp market
   */
  async getOraclePrice(marketIndex) {
    this.ensureInitialized();
    const perpMarket = this.driftClient.getPerpMarketAccount(marketIndex);
    if (!perpMarket) {
      throw new Error(`Perp market ${marketIndex} not found`);
    }
    const oracleData = this.driftClient.getOracleDataForPerpMarket(marketIndex);
    return oracleData.price;
  }
  /**
   * Get mark price for a perp market
   */
  async getMarkPrice(marketIndex) {
    this.ensureInitialized();
    const driftSdk = await import("@drift-labs/sdk");
    const { calculateReservePrice } = driftSdk;
    const perpMarket = this.driftClient.getPerpMarketAccount(marketIndex);
    if (!perpMarket) {
      throw new Error(`Perp market ${marketIndex} not found`);
    }
    const price = calculateReservePrice(perpMarket, this.driftClient.getOracleDataForPerpMarket(marketIndex));
    return BigInt(price.toString());
  }
  // ==========================================================================
  // Deposits and Withdrawals
  // ==========================================================================
  /**
   * Deposit collateral
   */
  async deposit(amount, spotMarketIndex, userTokenAccount) {
    this.ensureInitialized();
    const txSig = await this.driftClient.deposit(
      amount,
      spotMarketIndex,
      userTokenAccount
    );
    await this.config.connection.confirmTransaction(txSig, "confirmed");
    return txSig;
  }
  /**
   * Withdraw collateral
   */
  async withdraw(amount, spotMarketIndex, userTokenAccount) {
    this.ensureInitialized();
    const txSig = await this.driftClient.withdraw(
      amount,
      spotMarketIndex,
      userTokenAccount
    );
    await this.config.connection.confirmTransaction(txSig, "confirmed");
    return txSig;
  }
  // ==========================================================================
  // Cleanup
  // ==========================================================================
  /**
   * Unsubscribe and cleanup
   */
  async disconnect() {
    if (this.driftClient && this.isInitialized) {
      await this.driftClient.unsubscribe();
      this.isInitialized = false;
    }
  }
  /**
   * Check if client is initialized
   */
  getIsInitialized() {
    return this.isInitialized;
  }
  /**
   * Get the underlying DriftClient (for advanced usage)
   */
  getDriftClient() {
    this.ensureInitialized();
    return this.driftClient;
  }
};

// src/adapters/drift/DriftAdapter.ts
var DriftAdapter = class extends BaseAdapter {
  id = "drift";
  name = "Drift Protocol";
  has = {
    // Market data
    fetchMarkets: true,
    fetchTicker: true,
    fetchOrderBook: true,
    fetchTrades: true,
    fetchFundingRate: true,
    fetchFundingRateHistory: true,
    fetchOHLCV: false,
    // Requires historical data API
    // Trading (enabled with private key)
    createOrder: true,
    cancelOrder: true,
    cancelAllOrders: true,
    createBatchOrders: false,
    cancelBatchOrders: false,
    // Account data
    fetchPositions: true,
    fetchBalance: true,
    fetchOpenOrders: true,
    fetchOrderHistory: false,
    fetchMyTrades: false,
    // Position management
    setLeverage: false,
    // Cross-margin, no per-market leverage
    setMarginMode: false,
    // Always cross margin
    // WebSocket (via DLOB server)
    watchOrderBook: false,
    watchTrades: false,
    watchTicker: false,
    watchPositions: false,
    watchOrders: false,
    watchBalance: false
  };
  normalizer;
  auth;
  driftClient;
  orderBuilder;
  dlobBaseUrl;
  isTestnet;
  constructor(config = {}) {
    super({
      timeout: 3e4,
      ...config
    });
    this.isTestnet = config.testnet || false;
    this.dlobBaseUrl = this.isTestnet ? DRIFT_API_URLS.devnet.dlob : DRIFT_API_URLS.mainnet.dlob;
    this.normalizer = new DriftNormalizer();
    if (config.privateKey || config.walletAddress) {
      this.auth = new DriftAuth({
        privateKey: config.privateKey,
        walletAddress: config.walletAddress,
        subAccountId: config.subAccountId,
        rpcEndpoint: config.rpcEndpoint || (this.isTestnet ? DRIFT_API_URLS.devnet.rpc : DRIFT_API_URLS.mainnet.rpc),
        isDevnet: this.isTestnet
      });
    }
    this.orderBuilder = new DriftOrderBuilder(config.orderConfig);
  }
  // ==========================================================================
  // Connection Management
  // ==========================================================================
  async initialize() {
    if (this._isReady) {
      this.debug("Already initialized");
      return;
    }
    this.debug("Initializing Drift adapter...");
    try {
      await this.request(
        "GET",
        buildOrderbookUrl(this.dlobBaseUrl, 0, "perp", 5)
      );
      if (this.auth?.canSign()) {
        await this.initializeDriftClient();
      }
      this._isReady = true;
      this.info("Drift adapter initialized successfully");
    } catch (error) {
      const mappedError = mapDriftError(error);
      this.error("Failed to initialize Drift adapter", mappedError);
      throw mappedError;
    }
  }
  /**
   * Initialize the Drift SDK client for trading
   */
  async initializeDriftClient() {
    if (!this.auth) {
      throw new Error("Auth not configured");
    }
    try {
      const { Connection } = await import("@solana/web3.js");
      const connection = new Connection(this.auth.getRpcEndpoint(), "confirmed");
      const keypair = this.auth.getKeypair();
      if (!keypair) {
        throw new Error("Keypair not available");
      }
      this.driftClient = new DriftClientWrapper({
        connection,
        keypair,
        subAccountId: this.auth.getSubAccountId(),
        isDevnet: this.isTestnet
      });
      await this.driftClient.initialize();
      this.debug("Drift SDK client initialized");
    } catch (error) {
      this.warn(`Failed to initialize Drift SDK client: ${error instanceof Error ? error.message : String(error)}`);
    }
  }
  async disconnect() {
    if (this.driftClient) {
      await this.driftClient.disconnect();
    }
    this._isReady = false;
    this.debug("Drift adapter disconnected");
  }
  // ==========================================================================
  // Symbol Conversion
  // ==========================================================================
  symbolToExchange(symbol) {
    return unifiedToDrift(symbol);
  }
  symbolFromExchange(exchangeSymbol) {
    return driftToUnified(exchangeSymbol);
  }
  // ==========================================================================
  // Market Data
  // ==========================================================================
  async fetchMarkets(params) {
    this.ensureInitialized();
    const cached = this.getPreloadedMarkets();
    if (cached) {
      return this.filterMarkets(cached, params);
    }
    try {
      const markets = Object.entries(DRIFT_PERP_MARKETS).map(([key, config]) => ({
        id: key,
        symbol: config.symbol,
        base: config.baseAsset,
        quote: "USD",
        settle: "USD",
        active: true,
        minAmount: config.minOrderSize,
        maxAmount: 1e6,
        // Varies by market
        pricePrecision: Math.max(0, -Math.floor(Math.log10(config.tickSize))),
        amountPrecision: Math.max(0, -Math.floor(Math.log10(config.stepSize))),
        priceTickSize: config.tickSize,
        amountStepSize: config.stepSize,
        makerFee: -2e-4,
        // Maker rebate
        takerFee: 1e-3,
        // 0.1% taker
        maxLeverage: config.maxLeverage,
        fundingIntervalHours: 1,
        contractSize: 1,
        info: {
          marketIndex: config.marketIndex,
          contractTier: config.contractTier,
          initialMarginRatio: config.initialMarginRatio,
          maintenanceMarginRatio: config.maintenanceMarginRatio
        }
      }));
      return this.filterMarkets(markets, params);
    } catch (error) {
      throw mapDriftError(error);
    }
  }
  async fetchTicker(symbol) {
    this.ensureInitialized();
    const driftSymbol = this.symbolToExchange(symbol);
    if (!isValidMarket2(driftSymbol)) {
      throw new Error(`Invalid market: ${symbol}`);
    }
    try {
      const marketIndex = getMarketIndex(symbol);
      const orderbook = await this.request(
        "GET",
        buildOrderbookUrl(this.dlobBaseUrl, marketIndex, "perp", 1)
      );
      const oraclePrice = parseFloat(orderbook.oraclePrice) / DRIFT_PRECISION.PRICE;
      const bestBid = orderbook.bids[0] ? parseFloat(orderbook.bids[0].price) / DRIFT_PRECISION.PRICE : oraclePrice * 0.999;
      const bestAsk = orderbook.asks[0] ? parseFloat(orderbook.asks[0].price) / DRIFT_PRECISION.PRICE : oraclePrice * 1.001;
      const markPrice = (bestBid + bestAsk) / 2;
      const config = getMarketConfig2(symbol);
      return {
        symbol: config?.symbol || symbol,
        timestamp: Date.now(),
        last: markPrice,
        bid: bestBid,
        ask: bestAsk,
        high: markPrice,
        // Would need historical data
        low: markPrice,
        open: oraclePrice,
        close: markPrice,
        change: markPrice - oraclePrice,
        percentage: oraclePrice > 0 ? (markPrice - oraclePrice) / oraclePrice * 100 : 0,
        baseVolume: 0,
        // Would need stats API
        quoteVolume: 0,
        info: {
          marketIndex,
          oraclePrice,
          slot: orderbook.slot
        }
      };
    } catch (error) {
      throw mapDriftError(error);
    }
  }
  async fetchOrderBook(symbol, params) {
    this.ensureInitialized();
    const driftSymbol = this.symbolToExchange(symbol);
    if (!isValidMarket2(driftSymbol)) {
      throw new Error(`Invalid market: ${symbol}`);
    }
    try {
      const marketIndex = getMarketIndex(symbol);
      const depth = params?.limit || 20;
      const orderbook = await this.request(
        "GET",
        buildOrderbookUrl(this.dlobBaseUrl, marketIndex, "perp", depth)
      );
      return this.normalizer.normalizeOrderBook(orderbook);
    } catch (error) {
      throw mapDriftError(error);
    }
  }
  async fetchTrades(symbol, params) {
    this.ensureInitialized();
    const driftSymbol = this.symbolToExchange(symbol);
    if (!isValidMarket2(driftSymbol)) {
      throw new Error(`Invalid market: ${symbol}`);
    }
    try {
      const marketIndex = getMarketIndex(symbol);
      const limit = params?.limit || 50;
      const url = buildTradesUrl(this.dlobBaseUrl, marketIndex, "perp", limit);
      const trades = await this.request("GET", url);
      return trades.map((t) => this.normalizer.normalizeTrade(t));
    } catch (error) {
      throw mapDriftError(error);
    }
  }
  async fetchFundingRate(symbol) {
    this.ensureInitialized();
    const driftSymbol = this.symbolToExchange(symbol);
    if (!isValidMarket2(driftSymbol)) {
      throw new Error(`Invalid market: ${symbol}`);
    }
    try {
      const marketIndex = getMarketIndex(symbol);
      const url = `${this.dlobBaseUrl}/fundingRate?marketIndex=${marketIndex}`;
      const funding = await this.request("GET", url);
      return this.normalizer.normalizeFundingRate(funding);
    } catch (error) {
      throw mapDriftError(error);
    }
  }
  async fetchFundingRateHistory(symbol, _since, limit) {
    this.ensureInitialized();
    const driftSymbol = this.symbolToExchange(symbol);
    if (!isValidMarket2(driftSymbol)) {
      throw new Error(`Invalid market: ${symbol}`);
    }
    try {
      const marketIndex = getMarketIndex(symbol);
      const params = new URLSearchParams({
        marketIndex: marketIndex.toString()
      });
      if (limit) params.set("limit", limit.toString());
      const url = `${this.dlobBaseUrl}/fundingRateHistory?${params.toString()}`;
      const history = await this.request("GET", url);
      return history.map((f) => this.normalizer.normalizeFundingRate(f));
    } catch (error) {
      throw mapDriftError(error);
    }
  }
  // ==========================================================================
  // Account Data
  // ==========================================================================
  async fetchPositions(symbols) {
    this.ensureInitialized();
    if (!this.auth?.canRead()) {
      throw new Error("Wallet address required to fetch positions");
    }
    const walletAddress = this.auth.getWalletAddress();
    const subAccountId = this.auth.getSubAccountId();
    if (!walletAddress) {
      throw new Error("Wallet address not configured");
    }
    try {
      const url = `${this.dlobBaseUrl}/user?userAccount=${walletAddress}&subAccountId=${subAccountId}`;
      const userData = await this.request("GET", url);
      const positions = [];
      for (const pos of userData.perpPositions) {
        if (parseFloat(pos.baseAssetAmount) === 0) continue;
        const orderbook = await this.request(
          "GET",
          buildOrderbookUrl(this.dlobBaseUrl, pos.marketIndex, "perp", 1)
        );
        const oraclePrice = parseFloat(orderbook.oraclePrice) / DRIFT_PRECISION.PRICE;
        const position = this.normalizer.normalizePosition(
          {
            ...pos,
            lastCumulativeFundingRate: "0",
            openBids: "0",
            openAsks: "0",
            perLpBase: 0
          },
          oraclePrice,
          oraclePrice
        );
        if (!symbols || symbols.includes(position.symbol)) {
          positions.push(position);
        }
      }
      return positions;
    } catch (error) {
      throw mapDriftError(error);
    }
  }
  async fetchBalance() {
    this.ensureInitialized();
    if (!this.auth?.canRead()) {
      throw new Error("Wallet address required to fetch balance");
    }
    const walletAddress = this.auth.getWalletAddress();
    const subAccountId = this.auth.getSubAccountId();
    if (!walletAddress) {
      throw new Error("Wallet address not configured");
    }
    try {
      const url = `${this.dlobBaseUrl}/user?userAccount=${walletAddress}&subAccountId=${subAccountId}`;
      const userData = await this.request("GET", url);
      const balances = [];
      const usdcPosition = userData.spotPositions.find((p) => p.marketIndex === 0);
      if (usdcPosition) {
        const total = parseFloat(usdcPosition.scaledBalance) / DRIFT_PRECISION.QUOTE;
        balances.push({
          currency: "USDC",
          total: usdcPosition.balanceType === "deposit" ? total : -total,
          free: parseFloat(userData.freeCollateral) / DRIFT_PRECISION.QUOTE,
          used: parseFloat(userData.totalCollateral) / DRIFT_PRECISION.QUOTE - parseFloat(userData.freeCollateral) / DRIFT_PRECISION.QUOTE,
          usdValue: usdcPosition.balanceType === "deposit" ? total : -total
        });
      }
      return balances;
    } catch (error) {
      throw mapDriftError(error);
    }
  }
  async fetchOpenOrders(symbol) {
    this.ensureInitialized();
    if (!this.auth?.canRead()) {
      throw new Error("Wallet address required to fetch orders");
    }
    const walletAddress = this.auth.getWalletAddress();
    const subAccountId = this.auth.getSubAccountId();
    if (!walletAddress) {
      throw new Error("Wallet address not configured");
    }
    try {
      const url = `${this.dlobBaseUrl}/orders?userAccount=${walletAddress}&subAccountId=${subAccountId}`;
      const ordersData = await this.request("GET", url);
      const orders = ordersData.orders.filter((o) => o.marketType === "perp").map((o) => this.normalizer.normalizeOrder({
        ...o,
        orderType: o.orderType,
        direction: o.direction,
        status: o.status,
        triggerCondition: o.triggerCondition,
        postOnly: o.postOnly,
        existingPositionDirection: o.existingPositionDirection
      }));
      if (symbol) {
        const marketIndex = getMarketIndex(symbol);
        return orders.filter((o) => o.info?.marketIndex === marketIndex);
      }
      return orders;
    } catch (error) {
      throw mapDriftError(error);
    }
  }
  // ==========================================================================
  // Trading Operations
  // ==========================================================================
  async createOrder(request) {
    this.ensureInitialized();
    if (!this.auth?.canSign()) {
      throw new Error("Private key required for trading");
    }
    if (!this.driftClient) {
      throw new Error("Drift SDK client not initialized. Ensure private key is provided.");
    }
    if (!this.orderBuilder) {
      throw new Error("Order builder not initialized");
    }
    try {
      const marketIndex = getMarketIndex(request.symbol);
      const orderbook = await this.request(
        "GET",
        buildOrderbookUrl(this.dlobBaseUrl, marketIndex, "perp", 1)
      );
      const oraclePrice = parseFloat(orderbook.oraclePrice) / DRIFT_PRECISION.PRICE;
      const orderParams = this.orderBuilder.buildOrderParams(request, oraclePrice);
      this.debug("Placing order via Drift SDK...");
      const result = await this.driftClient.placePerpOrder(orderParams);
      return {
        id: result.orderId?.toString() || result.txSig,
        symbol: request.symbol,
        type: request.type,
        side: request.side,
        amount: request.amount,
        price: request.price,
        status: "open",
        filled: 0,
        remaining: request.amount,
        reduceOnly: request.reduceOnly || false,
        postOnly: request.postOnly || false,
        clientOrderId: request.clientOrderId,
        timestamp: Date.now(),
        info: {
          txSig: result.txSig,
          slot: result.slot,
          orderParams
        }
      };
    } catch (error) {
      throw mapDriftError(error);
    }
  }
  async cancelOrder(orderId, symbol) {
    this.ensureInitialized();
    if (!this.auth?.canSign()) {
      throw new Error("Private key required for trading");
    }
    if (!this.driftClient) {
      throw new Error("Drift SDK client not initialized");
    }
    try {
      const result = await this.driftClient.cancelOrder(parseInt(orderId));
      return {
        id: orderId,
        symbol: symbol || "UNKNOWN",
        type: "limit",
        side: "buy",
        amount: 0,
        status: "canceled",
        filled: 0,
        remaining: 0,
        reduceOnly: false,
        postOnly: false,
        timestamp: Date.now(),
        info: {
          txSig: result.txSig
        }
      };
    } catch (error) {
      throw mapDriftError(error);
    }
  }
  async cancelAllOrders(symbol) {
    this.ensureInitialized();
    if (!this.auth?.canSign()) {
      throw new Error("Private key required for trading");
    }
    if (!this.driftClient) {
      throw new Error("Drift SDK client not initialized");
    }
    try {
      let txSig;
      if (symbol) {
        const marketIndex = getMarketIndex(symbol);
        const results = await this.driftClient.cancelOrdersForMarket(marketIndex);
        return results.map((r) => ({
          id: r.orderId.toString(),
          symbol,
          type: "limit",
          side: "buy",
          amount: 0,
          status: "canceled",
          filled: 0,
          remaining: 0,
          reduceOnly: false,
          postOnly: false,
          timestamp: Date.now(),
          info: { txSig: r.txSig }
        }));
      } else {
        txSig = await this.driftClient.cancelAllPerpOrders();
        return [{
          id: "all",
          symbol: "ALL",
          type: "limit",
          side: "buy",
          amount: 0,
          status: "canceled",
          filled: 0,
          remaining: 0,
          reduceOnly: false,
          postOnly: false,
          timestamp: Date.now(),
          info: { txSig }
        }];
      }
    } catch (error) {
      throw mapDriftError(error);
    }
  }
  async fetchOrderHistory(_symbol, _since, _limit) {
    this.warn("Order history requires indexing on-chain transactions");
    return [];
  }
  async fetchMyTrades(_symbol, _since, _limit) {
    this.warn("Trade history requires indexing on-chain transactions");
    return [];
  }
  async setLeverage(_symbol, _leverage) {
    throw new Error("Drift uses cross-margin. Leverage is determined by position size relative to collateral.");
  }
  // ==========================================================================
  // Health Check
  // ==========================================================================
  async performApiHealthCheck() {
    await this.request(
      "GET",
      buildOrderbookUrl(this.dlobBaseUrl, 0, "perp", 1)
    );
  }
  // ==========================================================================
  // Helper Methods
  // ==========================================================================
  /**
   * Filter markets by params
   */
  filterMarkets(markets, params) {
    if (!params) return markets;
    let filtered = markets;
    if (params.active !== void 0) {
      filtered = filtered.filter((m) => m.active === params.active);
    }
    if (params.ids && params.ids.length > 0) {
      filtered = filtered.filter((m) => params.ids.includes(m.id));
    }
    return filtered;
  }
  /**
   * Get wallet address (for position queries)
   */
  async getAddress() {
    return this.auth?.getWalletAddress();
  }
  /**
   * Get sub-account ID
   */
  getSubAccountId() {
    return this.auth?.getSubAccountId() ?? 0;
  }
};

// src/adapters/gmx/constants.ts
var GMX_API_URLS = {
  arbitrum: {
    api: "https://arbitrum-api.gmxinfra.io",
    subgraph: "https://gmx.squids.live/gmx-synthetics-arbitrum:prod/api/graphql",
    rpc: "https://arb1.arbitrum.io/rpc",
    chainId: 42161
  },
  avalanche: {
    api: "https://avalanche-api.gmxinfra.io",
    subgraph: "https://gmx.squids.live/gmx-synthetics-avalanche:prod/api/graphql",
    rpc: "https://api.avax.network/ext/bc/C/rpc",
    chainId: 43114
  },
  arbitrumSepolia: {
    api: "https://arbitrum-sepolia-api.gmxinfra.io",
    subgraph: "https://gmx.squids.live/gmx-synthetics-arbitrum-sepolia:prod/api/graphql",
    rpc: "https://sepolia-rollup.arbitrum.io/rpc",
    chainId: 421614
  }
};
var GMX_ARBITRUM_API = GMX_API_URLS.arbitrum.api;
var GMX_AVALANCHE_API = GMX_API_URLS.avalanche.api;
var GMX_PRECISION = {
  PRICE: 1e30,
  // Oracle price precision (30 decimals)
  USD: 1e30,
  // USD amounts
  FACTOR: 1e30,
  // General factor precision
  BASIS_POINTS: 1e4,
  // 10000 = 100%
  FLOAT: 1e8,
  // Float precision for percentages
  TOKEN_DECIMALS: {
    ETH: 18,
    WETH: 18,
    BTC: 8,
    WBTC: 8,
    USDC: 6,
    USDT: 6,
    DAI: 18,
    AVAX: 18,
    ARB: 18,
    SOL: 9,
    LINK: 18,
    UNI: 18
  }
};
var GMX_MARKETS = {
  // Arbitrum Markets
  "ETH/USD:ETH": {
    marketAddress: "0x70d95587d40A2caf56bd97485aB3Eec10Bee6336",
    indexToken: "0x82aF49447D8a07e3bd95BD0d56f35241523fBab1",
    // WETH
    longToken: "0x82aF49447D8a07e3bd95BD0d56f35241523fBab1",
    // WETH
    shortToken: "0xaf88d065e77c8cC2239327C5EDb3A432268e5831",
    // USDC
    symbol: "ETH/USD:ETH",
    baseAsset: "ETH",
    quoteAsset: "USD",
    settleAsset: "ETH",
    maxLeverage: 100,
    minOrderSize: 1e-3,
    tickSize: 0.01,
    stepSize: 1e-4,
    chain: "arbitrum"
  },
  "BTC/USD:BTC": {
    marketAddress: "0x47c031236e19d024b42f8AE6780E44A573170703",
    indexToken: "0x47904963fc8b2340414262125aF798B9655E58Cd",
    // WBTC
    longToken: "0x47904963fc8b2340414262125aF798B9655E58Cd",
    // WBTC
    shortToken: "0xaf88d065e77c8cC2239327C5EDb3A432268e5831",
    // USDC
    symbol: "BTC/USD:BTC",
    baseAsset: "BTC",
    quoteAsset: "USD",
    settleAsset: "BTC",
    maxLeverage: 100,
    minOrderSize: 1e-4,
    tickSize: 0.1,
    stepSize: 1e-5,
    chain: "arbitrum"
  },
  "SOL/USD:ETH": {
    marketAddress: "0x09400D9DB990D5ed3f35D7be61DfAEB900Af03C9",
    indexToken: "0x2bcC6D6CdBbDC0a4071e48bb3B969b06B3330c07",
    // SOL
    longToken: "0x82aF49447D8a07e3bd95BD0d56f35241523fBab1",
    // WETH
    shortToken: "0xaf88d065e77c8cC2239327C5EDb3A432268e5831",
    // USDC
    symbol: "SOL/USD:ETH",
    baseAsset: "SOL",
    quoteAsset: "USD",
    settleAsset: "ETH",
    maxLeverage: 50,
    minOrderSize: 0.1,
    tickSize: 1e-3,
    stepSize: 0.01,
    chain: "arbitrum"
  },
  "ARB/USD:ARB": {
    marketAddress: "0xC25cEf6061Cf5dE5eb761b50E4743c1F5D7E5407",
    indexToken: "0x912CE59144191C1204E64559FE8253a0e49E6548",
    // ARB
    longToken: "0x912CE59144191C1204E64559FE8253a0e49E6548",
    // ARB
    shortToken: "0xaf88d065e77c8cC2239327C5EDb3A432268e5831",
    // USDC
    symbol: "ARB/USD:ARB",
    baseAsset: "ARB",
    quoteAsset: "USD",
    settleAsset: "ARB",
    maxLeverage: 50,
    minOrderSize: 1,
    tickSize: 1e-4,
    stepSize: 0.1,
    chain: "arbitrum"
  },
  "LINK/USD:ETH": {
    marketAddress: "0x7f1fa204bb700853D36994DA19F830b6Ad18455C",
    indexToken: "0xf97f4df75117a78c1A5a0DBb814Af92458539FB4",
    // LINK
    longToken: "0x82aF49447D8a07e3bd95BD0d56f35241523fBab1",
    // WETH
    shortToken: "0xaf88d065e77c8cC2239327C5EDb3A432268e5831",
    // USDC
    symbol: "LINK/USD:ETH",
    baseAsset: "LINK",
    quoteAsset: "USD",
    settleAsset: "ETH",
    maxLeverage: 50,
    minOrderSize: 0.1,
    tickSize: 1e-3,
    stepSize: 0.01,
    chain: "arbitrum"
  },
  "DOGE/USD:ETH": {
    marketAddress: "0x6853EA96FF216fAb11D2d930CE3C508556A4bdc4",
    indexToken: "0xC4da4c24fd591125c3F47b340b6f4f76111883d8",
    // DOGE
    longToken: "0x82aF49447D8a07e3bd95BD0d56f35241523fBab1",
    // WETH
    shortToken: "0xaf88d065e77c8cC2239327C5EDb3A432268e5831",
    // USDC
    symbol: "DOGE/USD:ETH",
    baseAsset: "DOGE",
    quoteAsset: "USD",
    settleAsset: "ETH",
    maxLeverage: 50,
    minOrderSize: 10,
    tickSize: 1e-5,
    stepSize: 1,
    chain: "arbitrum"
  },
  "XRP/USD:ETH": {
    marketAddress: "0x0CCB4fAa6f1F1B30911619f1184082aB4E25813c",
    indexToken: "0xc14e065b0067dE91534e032868f5Ac6ecf2c6868",
    // XRP
    longToken: "0x82aF49447D8a07e3bd95BD0d56f35241523fBab1",
    // WETH
    shortToken: "0xaf88d065e77c8cC2239327C5EDb3A432268e5831",
    // USDC
    symbol: "XRP/USD:ETH",
    baseAsset: "XRP",
    quoteAsset: "USD",
    settleAsset: "ETH",
    maxLeverage: 50,
    minOrderSize: 1,
    tickSize: 1e-4,
    stepSize: 0.1,
    chain: "arbitrum"
  },
  "LTC/USD:ETH": {
    marketAddress: "0xD9535bB5f58A1a75032416F2dFe7880C30575a41",
    indexToken: "0xB46A094Bc4B0adBD801E14b9DB95e05E28962764",
    // LTC
    longToken: "0x82aF49447D8a07e3bd95BD0d56f35241523fBab1",
    // WETH
    shortToken: "0xaf88d065e77c8cC2239327C5EDb3A432268e5831",
    // USDC
    symbol: "LTC/USD:ETH",
    baseAsset: "LTC",
    quoteAsset: "USD",
    settleAsset: "ETH",
    maxLeverage: 50,
    minOrderSize: 0.01,
    tickSize: 0.01,
    stepSize: 1e-3,
    chain: "arbitrum"
  },
  // Avalanche Markets
  "AVAX/USD:AVAX": {
    marketAddress: "0xD996ff47A1F763E1e55415BC4437c59292D1F415",
    indexToken: "0xB31f66AA3C1e785363F0875A1B74E27b85FD66c7",
    // WAVAX
    longToken: "0xB31f66AA3C1e785363F0875A1B74E27b85FD66c7",
    // WAVAX
    shortToken: "0xB97EF9Ef8734C71904D8002F8b6Bc66Dd9c48a6E",
    // USDC
    symbol: "AVAX/USD:AVAX",
    baseAsset: "AVAX",
    quoteAsset: "USD",
    settleAsset: "AVAX",
    maxLeverage: 100,
    minOrderSize: 0.1,
    tickSize: 0.01,
    stepSize: 0.01,
    chain: "avalanche"
  },
  "ETH/USD:AVAX": {
    marketAddress: "0xB7e69749E3d2EDd90ea59A4932EFEa2D41E245d7",
    indexToken: "0x49D5c2BdFfac6CE2BFdB6640F4F80f226bc10bAB",
    // WETH.e
    longToken: "0xB31f66AA3C1e785363F0875A1B74E27b85FD66c7",
    // WAVAX
    shortToken: "0xB97EF9Ef8734C71904D8002F8b6Bc66Dd9c48a6E",
    // USDC
    symbol: "ETH/USD:AVAX",
    baseAsset: "ETH",
    quoteAsset: "USD",
    settleAsset: "AVAX",
    maxLeverage: 100,
    minOrderSize: 1e-3,
    tickSize: 0.01,
    stepSize: 1e-4,
    chain: "avalanche"
  },
  "BTC/USD:AVAX": {
    marketAddress: "0xFb02132333A79C8B5Bd5b6BD5e895bE3936F97c0",
    indexToken: "0x152b9d0FdC40C096757F570A51E494bd4b943E50",
    // BTC.b
    longToken: "0xB31f66AA3C1e785363F0875A1B74E27b85FD66c7",
    // WAVAX
    shortToken: "0xB97EF9Ef8734C71904D8002F8b6Bc66Dd9c48a6E",
    // USDC
    symbol: "BTC/USD:AVAX",
    baseAsset: "BTC",
    quoteAsset: "USD",
    settleAsset: "AVAX",
    maxLeverage: 100,
    minOrderSize: 1e-4,
    tickSize: 0.1,
    stepSize: 1e-5,
    chain: "avalanche"
  }
};
var GMX_MARKET_ADDRESS_MAP = Object.entries(
  GMX_MARKETS
).reduce(
  (acc, [key, config]) => {
    acc[config.marketAddress.toLowerCase()] = key;
    return acc;
  },
  {}
);
var GMX_ORDER_TYPES = {
  MARKET_INCREASE: 0,
  // Open/increase position at market
  MARKET_DECREASE: 1,
  // Close/decrease position at market
  LIMIT_INCREASE: 2,
  // Limit order to open/increase
  LIMIT_DECREASE: 3,
  // Limit order to close/decrease
  STOP_LOSS: 4,
  // Stop loss order
  LIQUIDATION: 5
  // Liquidation order
};
var GMX_DECREASE_POSITION_SWAP_TYPES = {
  NO_SWAP: 0,
  SWAP_PNL_TOKEN_TO_COLLATERAL: 1,
  SWAP_COLLATERAL_TO_PNL_TOKEN: 2
};
function unifiedToGmx(symbol) {
  if (symbol in GMX_MARKETS) {
    return symbol;
  }
  const base = symbol.split("/")[0]?.toUpperCase();
  if (!base) return void 0;
  for (const [key, market] of Object.entries(GMX_MARKETS)) {
    if (market.baseAsset === base) {
      return key;
    }
  }
  return void 0;
}
function gmxToUnified(marketKey) {
  const market = GMX_MARKETS[marketKey];
  return market?.symbol || marketKey;
}
function getMarketByAddress(address) {
  const key = GMX_MARKET_ADDRESS_MAP[address.toLowerCase()];
  return key ? GMX_MARKETS[key] : void 0;
}
var GMX_CONTRACTS = {
  arbitrum: {
    exchangeRouter: "0x7C68C7866A64FA2160F78EEaE12217FFbf871fa8",
    router: "0x7452c558d45f8afC8c83dAe62C3f8A5BE19c71f6",
    dataStore: "0xFD70de6b91282D8017aA4E741e9Ae325CAb992d8",
    reader: "0xf60becbba223EEA9495Da3f606753867eC10d139",
    orderVault: "0x31eF83a530Fde1B38EE9A18093A333D8Bbbc40D5",
    positionRouter: "0xb87a436B93fFE9D75c5cFA7bAcFff96430b09868"
  },
  avalanche: {
    exchangeRouter: "0x79be2F4eC8A4143BaF963206c6e0d8b3b8a74a38",
    router: "0x820F5FfC5b525cD4d88Cd91aCd2119b38cB97b10",
    dataStore: "0x2F0b22339414AcD8fc5b7F5a299fdF5A96E0DfB6",
    reader: "0xdCf06A4A40579A5F4F53F3D57f2C2f145f404757",
    orderVault: "0xD3D60D22d415aD43b7e64b510D86A30f19B1B12C",
    positionRouter: "0xffF6D276Bc37c61A23f06410Dce4A400f66420f8"
  }
};
var GMX_ERROR_MESSAGES = {
  "insufficient collateral": "INSUFFICIENT_MARGIN",
  "insufficient balance": "INSUFFICIENT_BALANCE",
  "position not found": "POSITION_NOT_FOUND",
  "order not found": "ORDER_NOT_FOUND",
  "max leverage exceeded": "MAX_LEVERAGE_EXCEEDED",
  "min order size": "MIN_ORDER_SIZE",
  "oracle error": "ORACLE_ERROR",
  "market disabled": "MARKET_PAUSED",
  "execution failed": "TRANSACTION_FAILED",
  "slippage": "SLIPPAGE_EXCEEDED",
  "liquidation": "LIQUIDATION",
  "invalid price": "INVALID_PRICE",
  "keeper": "KEEPER_ERROR"
};

// src/adapters/gmx/GmxNormalizer.ts
var GmxNormalizer = class {
  /**
   * Extract base symbol from market name
   * @example "ENA/USD [ETH-USDC]" -> "ENA"
   * @example "ETH/USD" -> "ETH"
   */
  extractBaseFromName(name) {
    if (!name) return "UNKNOWN";
    const match = name.match(/^([A-Z0-9]+)\//);
    return match?.[1] ?? "UNKNOWN";
  }
  /**
   * Normalize market info to unified Market
   */
  normalizeMarket(market, chain) {
    const marketKey = GMX_MARKET_ADDRESS_MAP[market.marketToken.toLowerCase()];
    const config = marketKey ? GMX_MARKETS[marketKey] : void 0;
    const baseSymbol = config?.baseAsset || this.extractBaseFromName(market.name);
    const symbol = config?.symbol || `${baseSymbol}/USD`;
    const maxOI = parseFloat(market.maxOpenInterestLong) / GMX_PRECISION.USD;
    return {
      id: market.marketToken,
      symbol,
      base: baseSymbol,
      quote: "USD",
      settle: config?.settleAsset || "USD",
      active: !market.isDisabled,
      minAmount: config?.minOrderSize || 1e-3,
      maxAmount: maxOI > 0 ? maxOI : 1e6,
      // Fallback if price unavailable
      pricePrecision: this.getPrecisionFromTickSize(config?.tickSize || 0.01),
      amountPrecision: this.getPrecisionFromTickSize(config?.stepSize || 1e-4),
      priceTickSize: config?.tickSize || 0.01,
      amountStepSize: config?.stepSize || 1e-4,
      makerFee: 5e-4,
      // 0.05% base fee (varies with price impact)
      takerFee: 7e-4,
      // 0.07% base fee (varies with price impact)
      maxLeverage: config?.maxLeverage || 100,
      fundingIntervalHours: 1,
      // Continuous funding, normalized to 1h
      contractSize: 1,
      info: {
        marketToken: market.marketToken,
        indexToken: market.indexToken,
        longToken: market.longToken,
        shortToken: market.shortToken,
        chain,
        longPoolAmount: market.longPoolAmount,
        shortPoolAmount: market.shortPoolAmount,
        longInterestUsd: market.longInterestUsd,
        shortInterestUsd: market.shortInterestUsd,
        fundingFactor: market.fundingFactor,
        borrowingFactorLong: market.borrowingFactorLong,
        borrowingFactorShort: market.borrowingFactorShort
      }
    };
  }
  /**
   * Normalize multiple markets
   */
  normalizeMarkets(markets, chain) {
    return markets.map((m) => this.normalizeMarket(m, chain));
  }
  /**
   * Normalize position to unified Position
   */
  normalizePosition(position, markPrice, chain) {
    const marketKey = GMX_MARKET_ADDRESS_MAP[position.market.toLowerCase()];
    const config = marketKey ? GMX_MARKETS[marketKey] : void 0;
    const symbol = config?.symbol || gmxToUnified(marketKey);
    const sizeInUsd = parseFloat(position.sizeInUsd) / GMX_PRECISION.USD;
    const sizeInTokens = parseFloat(position.sizeInTokens) / 10 ** 18;
    const collateral = parseFloat(position.collateralAmount) / 10 ** 18;
    const side = position.isLong ? "long" : "short";
    const entryPrice = sizeInTokens > 0 ? sizeInUsd / sizeInTokens : markPrice;
    const notional = sizeInTokens * markPrice;
    const unrealizedPnl = this.calculateUnrealizedPnl(side, sizeInTokens, entryPrice, markPrice);
    const collateralUsd = collateral * markPrice;
    const leverage = collateralUsd > 0 ? notional / collateralUsd : 0;
    const maintenanceMargin = 0.01;
    const liquidationPrice = this.calculateLiquidationPrice(side, entryPrice, leverage, maintenanceMargin);
    return {
      symbol,
      side,
      size: sizeInTokens,
      entryPrice,
      markPrice,
      liquidationPrice,
      leverage,
      marginMode: "cross",
      // GMX uses cross-margin
      margin: collateralUsd,
      maintenanceMargin: notional * maintenanceMargin,
      marginRatio: this.calculateMarginRatio(side, entryPrice, markPrice, leverage, maintenanceMargin),
      unrealizedPnl,
      realizedPnl: 0,
      // Would need historical data
      timestamp: Date.now(),
      info: {
        marketAddress: position.market,
        collateralToken: position.collateralToken,
        borrowingFactor: position.borrowingFactor,
        fundingFeeAmountPerSize: position.fundingFeeAmountPerSize,
        chain
      }
    };
  }
  /**
   * Normalize order to unified Order
   */
  normalizeOrder(order, marketPrice) {
    const marketKey = GMX_MARKET_ADDRESS_MAP[order.market.toLowerCase()];
    const config = marketKey ? GMX_MARKETS[marketKey] : void 0;
    const symbol = config?.symbol || gmxToUnified(marketKey);
    const sizeDeltaUsd = parseFloat(order.sizeDeltaUsd) / GMX_PRECISION.USD;
    const triggerPrice = parseFloat(order.triggerPrice) / GMX_PRECISION.PRICE;
    const acceptablePrice = parseFloat(order.acceptablePrice) / GMX_PRECISION.PRICE;
    let type = "market";
    if (order.orderType === 0 || order.orderType === 1) {
      type = "market";
    } else if (order.orderType === 2 || order.orderType === 3) {
      type = "limit";
    } else if (order.orderType === 4) {
      type = "stopMarket";
    }
    const isIncrease = order.orderType === 0 || order.orderType === 2;
    const side = isIncrease && order.isLong || !isIncrease && !order.isLong ? "buy" : "sell";
    let status = "open";
    if (order.status === "Executed") status = "filled";
    else if (order.status === "Cancelled") status = "canceled";
    else if (order.status === "Expired") status = "expired";
    else if (order.isFrozen) status = "rejected";
    const price = triggerPrice > 0 ? triggerPrice : marketPrice || acceptablePrice;
    const amount = price > 0 ? sizeDeltaUsd / price : 0;
    return {
      id: order.key,
      symbol,
      type,
      side,
      amount,
      price,
      stopPrice: order.orderType === 4 ? triggerPrice : void 0,
      status,
      filled: status === "filled" ? amount : 0,
      remaining: status === "filled" ? 0 : amount,
      averagePrice: void 0,
      reduceOnly: order.orderType === 1 || order.orderType === 3 || order.orderType === 4,
      postOnly: false,
      timestamp: parseInt(order.updatedAtBlock) * 1e3,
      // Approximate
      info: {
        orderKey: order.key,
        orderType: order.orderType,
        marketAddress: order.market,
        isLong: order.isLong,
        decreasePositionSwapType: order.decreasePositionSwapType,
        executionFee: order.executionFee,
        acceptablePrice: order.acceptablePrice
      }
    };
  }
  /**
   * Normalize trade to unified Trade
   */
  normalizeTrade(trade) {
    const marketKey = GMX_MARKET_ADDRESS_MAP[trade.market.toLowerCase()];
    const config = marketKey ? GMX_MARKETS[marketKey] : void 0;
    const symbol = config?.symbol || gmxToUnified(marketKey);
    const sizeDeltaUsd = parseFloat(trade.sizeDeltaUsd) / GMX_PRECISION.USD;
    const executionPrice = parseFloat(trade.executionPrice) / GMX_PRECISION.PRICE;
    const sizeDeltaInTokens = parseFloat(trade.sizeDeltaInTokens) / 10 ** 18;
    const isIncrease = trade.orderType === 0 || trade.orderType === 2;
    const side = isIncrease && trade.isLong || !isIncrease && !trade.isLong ? "buy" : "sell";
    return {
      id: trade.id,
      symbol,
      side,
      price: executionPrice,
      amount: Math.abs(sizeDeltaInTokens),
      cost: sizeDeltaUsd,
      timestamp: trade.timestamp * 1e3,
      info: {
        marketAddress: trade.market,
        isLong: trade.isLong,
        orderType: trade.orderType,
        pnlUsd: trade.pnlUsd,
        priceImpactUsd: trade.priceImpactUsd,
        transactionHash: trade.transactionHash
      }
    };
  }
  /**
   * Normalize funding rate
   */
  normalizeFundingRate(funding, indexPrice) {
    const marketKey = GMX_MARKET_ADDRESS_MAP[funding.market.toLowerCase()];
    const config = marketKey ? GMX_MARKETS[marketKey] : void 0;
    const symbol = config?.symbol || gmxToUnified(marketKey);
    const fundingFactorPerSecond = parseFloat(funding.fundingFactorPerSecond) / GMX_PRECISION.FACTOR;
    const hourlyRate = fundingFactorPerSecond * 3600;
    const fundingRate = funding.longsPayShorts ? hourlyRate : -hourlyRate;
    return {
      symbol,
      fundingRate,
      fundingTimestamp: funding.timestamp * 1e3,
      nextFundingTimestamp: (funding.timestamp + 3600) * 1e3,
      // Next hour (continuous)
      markPrice: indexPrice,
      indexPrice,
      fundingIntervalHours: 1,
      info: {
        marketAddress: funding.market,
        fundingFactorPerSecond: funding.fundingFactorPerSecond,
        longsPayShorts: funding.longsPayShorts,
        fundingFeeAmountPerSizeLong: funding.fundingFeeAmountPerSizeLong,
        fundingFeeAmountPerSizeShort: funding.fundingFeeAmountPerSizeShort
      }
    };
  }
  /**
   * Normalize market info to ticker
   * Note: Price data requires separate fetch from tickers endpoint
   */
  normalizeTicker(market, priceData) {
    const marketKey = GMX_MARKET_ADDRESS_MAP[market.marketToken.toLowerCase()];
    const config = marketKey ? GMX_MARKETS[marketKey] : void 0;
    const baseSymbol = config?.baseAsset || this.extractBaseFromName(market.name);
    const symbol = config?.symbol || `${baseSymbol}/USD`;
    const minPrice = priceData?.minPrice ?? 0;
    const maxPrice = priceData?.maxPrice ?? 0;
    const midPrice = (minPrice + maxPrice) / 2;
    const spread = maxPrice - minPrice;
    const longOI = parseFloat(market.longInterestUsd) / GMX_PRECISION.USD;
    const shortOI = parseFloat(market.shortInterestUsd) / GMX_PRECISION.USD;
    return {
      symbol,
      timestamp: Date.now(),
      last: midPrice,
      bid: minPrice,
      ask: maxPrice,
      high: midPrice,
      // Would need historical data
      low: midPrice,
      open: midPrice,
      close: midPrice,
      change: 0,
      // Would need historical data
      percentage: 0,
      baseVolume: 0,
      // Would need volume data
      quoteVolume: 0,
      info: {
        marketToken: market.marketToken,
        minPrice,
        maxPrice,
        spread,
        spreadPercent: midPrice > 0 ? spread / midPrice * 100 : 0,
        longOpenInterestUsd: longOI,
        shortOpenInterestUsd: shortOI,
        totalOpenInterestUsd: longOI + shortOI,
        imbalance: longOI - shortOI
      }
    };
  }
  /**
   * Normalize candlesticks to OHLCV
   */
  normalizeCandle(candle) {
    return [
      candle.timestamp * 1e3,
      candle.open,
      candle.high,
      candle.low,
      candle.close,
      0
      // GMX candlestick endpoint doesn't include volume
    ];
  }
  /**
   * Normalize candlesticks array
   */
  normalizeCandles(candles) {
    return candles.map((c) => this.normalizeCandle(c));
  }
  // ==========================================================================
  // Helper Methods
  // ==========================================================================
  /**
   * Calculate unrealized PnL
   */
  calculateUnrealizedPnl(side, size, entryPrice, currentPrice) {
    if (side === "long") {
      return size * (currentPrice - entryPrice);
    } else {
      return size * (entryPrice - currentPrice);
    }
  }
  /**
   * Calculate liquidation price
   */
  calculateLiquidationPrice(side, entryPrice, leverage, maintenanceMargin) {
    if (leverage <= 0) return 0;
    const liquidationThreshold = 1 - maintenanceMargin;
    if (side === "long") {
      return entryPrice * (1 - liquidationThreshold / leverage);
    } else {
      return entryPrice * (1 + liquidationThreshold / leverage);
    }
  }
  /**
   * Calculate margin ratio (percentage until liquidation)
   */
  calculateMarginRatio(side, entryPrice, currentPrice, leverage, maintenanceMargin) {
    if (leverage <= 0 || entryPrice <= 0) return 100;
    const pnlPercent = side === "long" ? (currentPrice - entryPrice) / entryPrice : (entryPrice - currentPrice) / entryPrice;
    const marginUsed = 1 / leverage;
    const currentMargin = marginUsed + pnlPercent;
    return Math.max(0, (currentMargin - maintenanceMargin) / marginUsed * 100);
  }
  /**
   * Get precision from tick size
   */
  getPrecisionFromTickSize(tickSize) {
    if (tickSize >= 1) return 0;
    return Math.max(0, -Math.floor(Math.log10(tickSize)));
  }
};

// src/adapters/gmx/GmxAuth.ts
var import_ethers6 = require("ethers");
var GmxAuth = class {
  wallet;
  walletAddress;
  chain;
  provider;
  rpcEndpoint;
  constructor(config) {
    this.chain = config.chain;
    this.rpcEndpoint = config.rpcEndpoint || GMX_API_URLS[config.chain].rpc;
    this.provider = new import_ethers6.ethers.JsonRpcProvider(this.rpcEndpoint);
    if (config.wallet) {
      this.wallet = config.wallet.connect(this.provider);
      this.walletAddress = config.wallet.address;
    } else if (config.privateKey) {
      this.wallet = new import_ethers6.ethers.Wallet(config.privateKey, this.provider);
      this.walletAddress = this.wallet.address;
    } else if (config.walletAddress) {
      this.walletAddress = config.walletAddress;
    }
  }
  /**
   * Sign a request (required by IAuthStrategy interface)
   * GMX uses on-chain transaction signing, not HTTP request signing
   */
  async sign(request) {
    return {
      ...request,
      headers: {}
    };
  }
  /**
   * GMX doesn't use HTTP header authentication
   * All authentication is done via transaction signing
   */
  getHeaders() {
    return {};
  }
  /**
   * Sign a message
   */
  async signMessage(message) {
    if (!this.wallet) {
      throw new Error("Wallet required for signing");
    }
    return this.wallet.signMessage(message);
  }
  /**
   * Sign typed data (EIP-712)
   */
  async signTypedData(domain, types, value) {
    if (!this.wallet) {
      throw new Error("Wallet required for signing");
    }
    return this.wallet.signTypedData(domain, types, value);
  }
  /**
   * Get the wallet address
   */
  getWalletAddress() {
    return this.walletAddress;
  }
  /**
   * Get the wallet instance (for contract interactions)
   */
  getWallet() {
    return this.wallet;
  }
  /**
   * Get the signer (for contract interactions)
   */
  getSigner() {
    return this.wallet;
  }
  /**
   * Get the provider
   */
  getProvider() {
    return this.provider;
  }
  /**
   * Get the chain
   */
  getChain() {
    return this.chain;
  }
  /**
   * Get chain ID
   */
  getChainId() {
    return GMX_API_URLS[this.chain].chainId;
  }
  /**
   * Get RPC endpoint
   */
  getRpcEndpoint() {
    return this.rpcEndpoint;
  }
  /**
   * Check if authentication is configured for trading
   */
  canSign() {
    return this.wallet !== void 0;
  }
  /**
   * Check if authentication is configured for read operations
   */
  canRead() {
    return this.walletAddress !== void 0;
  }
  /**
   * Estimate gas for a transaction
   */
  async estimateGas(tx) {
    return this.provider.estimateGas(tx);
  }
  /**
   * Get current gas price
   */
  async getGasPrice() {
    const feeData = await this.provider.getFeeData();
    return feeData.gasPrice || 0n;
  }
  /**
   * Get current block number
   */
  async getBlockNumber() {
    return this.provider.getBlockNumber();
  }
  /**
   * Wait for a transaction to be confirmed
   */
  async waitForTransaction(txHash, confirmations = 1) {
    return this.provider.waitForTransaction(txHash, confirmations);
  }
  /**
   * Get ETH balance of wallet
   */
  async getBalance() {
    if (!this.walletAddress) {
      throw new Error("Wallet address required");
    }
    return this.provider.getBalance(this.walletAddress);
  }
  /**
   * Get token balance
   */
  async getTokenBalance(tokenAddress) {
    if (!this.walletAddress) {
      throw new Error("Wallet address required");
    }
    const erc20Abi = ["function balanceOf(address owner) view returns (uint256)"];
    const contract = new import_ethers6.ethers.Contract(tokenAddress, erc20Abi, this.provider);
    return contract.balanceOf(this.walletAddress);
  }
  /**
   * Get token allowance
   */
  async getTokenAllowance(tokenAddress, spenderAddress) {
    if (!this.walletAddress) {
      throw new Error("Wallet address required");
    }
    const erc20Abi = ["function allowance(address owner, address spender) view returns (uint256)"];
    const contract = new import_ethers6.ethers.Contract(tokenAddress, erc20Abi, this.provider);
    return contract.allowance(this.walletAddress, spenderAddress);
  }
  /**
   * Approve token spending
   */
  async approveToken(tokenAddress, spenderAddress, amount) {
    if (!this.wallet) {
      throw new Error("Wallet required for approval");
    }
    const erc20Abi = ["function approve(address spender, uint256 amount) returns (bool)"];
    const contract = new import_ethers6.ethers.Contract(tokenAddress, erc20Abi, this.wallet);
    return contract.approve(spenderAddress, amount);
  }
};

// src/adapters/gmx/GmxContracts.ts
var import_ethers7 = require("ethers");
var EXCHANGE_ROUTER_ABI = [
  // Create order
  "function createOrder(tuple(address[] addresses, uint256[] numbers, bytes32 orderType, bytes32 decreasePositionSwapType, bool isLong, bool shouldUnwrapNativeToken, bytes32 referralCode) params) payable returns (bytes32)",
  // Cancel order
  "function cancelOrder(bytes32 key) external",
  // Multicall for batch operations
  "function multicall(bytes[] calldata data) external payable returns (bytes[] memory results)",
  // Send tokens to WNT
  "function sendWnt(address receiver, uint256 amount) external payable",
  // Send tokens
  "function sendTokens(address token, address receiver, uint256 amount) external payable"
];
var READER_ABI = [
  // Get market info
  "function getMarket(address dataStore, address marketKey) external view returns (tuple(address marketToken, address indexToken, address longToken, address shortToken))",
  // Get market prices
  "function getMarketTokenPrice(address dataStore, tuple(address marketToken, address indexToken, address longToken, address shortToken) market, tuple(uint256 min, uint256 max) indexTokenPrice, tuple(uint256 min, uint256 max) longTokenPrice, tuple(uint256 min, uint256 max) shortTokenPrice, bytes32 pnlFactorType, bool maximize) external view returns (int256, tuple(int256 poolValue, int256 longPnl, int256 shortPnl, int256 netPnl, int256 longTokenAmount, int256 shortTokenAmount, int256 longTokenUsd, int256 shortTokenUsd, int256 totalBorrowingFees, int256 borrowingFeePoolFactor, int256 impactPoolAmount))",
  // Get position
  "function getPosition(address dataStore, bytes32 positionKey) external view returns (tuple(address account, address market, address collateralToken, bool isLong, uint256 sizeInUsd, uint256 sizeInTokens, uint256 collateralAmount, uint256 borrowingFactor, uint256 fundingFeeAmountPerSize, uint256 longTokenClaimableFundingAmountPerSize, uint256 shortTokenClaimableFundingAmountPerSize, uint256 increasedAtBlock, uint256 decreasedAtBlock))",
  // Get positions
  "function getAccountPositions(address dataStore, address account, uint256 start, uint256 end) external view returns (tuple(address account, address market, address collateralToken, bool isLong, uint256 sizeInUsd, uint256 sizeInTokens, uint256 collateralAmount, uint256 borrowingFactor, uint256 fundingFeeAmountPerSize, uint256 longTokenClaimableFundingAmountPerSize, uint256 shortTokenClaimableFundingAmountPerSize, uint256 increasedAtBlock, uint256 decreasedAtBlock)[])",
  // Get orders
  "function getAccountOrders(address dataStore, address account, uint256 start, uint256 end) external view returns (tuple(bytes32 key, address account, address receiver, address callbackContract, address uiFeeReceiver, address market, address initialCollateralToken, address[] swapPath, uint8 orderType, uint8 decreasePositionSwapType, uint256 sizeDeltaUsd, uint256 initialCollateralDeltaAmount, uint256 triggerPrice, uint256 acceptablePrice, uint256 executionFee, uint256 callbackGasLimit, uint256 minOutputAmount, uint256 updatedAtBlock, bool isLong, bool isFrozen)[])"
];
var DATA_STORE_ABI = [
  "function getUint(bytes32 key) external view returns (uint256)",
  "function getInt(bytes32 key) external view returns (int256)",
  "function getAddress(bytes32 key) external view returns (address)",
  "function getBool(bytes32 key) external view returns (bool)",
  "function getBytes32(bytes32 key) external view returns (bytes32)",
  "function getBytes32Count(bytes32 setKey) external view returns (uint256)",
  "function getBytes32ValuesAt(bytes32 setKey, uint256 start, uint256 end) external view returns (bytes32[])"
];
var ORDER_VAULT_ABI = [
  "function recordTransferIn(address token) external returns (uint256)"
];
var GmxContracts = class {
  chain;
  provider;
  signer;
  addresses;
  exchangeRouter;
  reader;
  dataStore;
  orderVault;
  constructor(chain, provider, signer) {
    this.chain = chain;
    this.provider = provider;
    this.signer = signer;
    this.addresses = GMX_CONTRACTS[chain];
  }
  // ==========================================================================
  // Contract Getters
  // ==========================================================================
  /**
   * Get ExchangeRouter contract instance
   */
  getExchangeRouter() {
    if (!this.exchangeRouter) {
      this.exchangeRouter = new import_ethers7.ethers.Contract(
        this.addresses.exchangeRouter,
        EXCHANGE_ROUTER_ABI,
        this.signer || this.provider
      );
    }
    return this.exchangeRouter;
  }
  /**
   * Get Reader contract instance
   */
  getReader() {
    if (!this.reader) {
      this.reader = new import_ethers7.ethers.Contract(
        this.addresses.reader,
        READER_ABI,
        this.provider
      );
    }
    return this.reader;
  }
  /**
   * Get DataStore contract instance
   */
  getDataStore() {
    if (!this.dataStore) {
      this.dataStore = new import_ethers7.ethers.Contract(
        this.addresses.dataStore,
        DATA_STORE_ABI,
        this.provider
      );
    }
    return this.dataStore;
  }
  /**
   * Get OrderVault contract instance
   */
  getOrderVault() {
    if (!this.orderVault) {
      this.orderVault = new import_ethers7.ethers.Contract(
        this.addresses.orderVault,
        ORDER_VAULT_ABI,
        this.signer || this.provider
      );
    }
    return this.orderVault;
  }
  // ==========================================================================
  // Trading Operations
  // ==========================================================================
  /**
   * Create a new order
   */
  async createOrder(params, executionFee) {
    if (!this.signer) {
      throw new Error("Signer required for trading operations");
    }
    const exchangeRouter = this.getExchangeRouter();
    const orderParams = {
      addresses: [
        params.receiver,
        params.callbackContract,
        params.uiFeeReceiver,
        params.market,
        params.initialCollateralToken,
        ...params.swapPath
      ],
      numbers: [
        params.sizeDeltaUsd,
        params.initialCollateralDeltaAmount,
        params.triggerPrice,
        params.acceptablePrice,
        params.executionFee,
        params.callbackGasLimit,
        params.minOutputAmount
      ],
      orderType: this.encodeOrderType(params.orderType),
      decreasePositionSwapType: this.encodeDecreaseSwapType(params.decreasePositionSwapType),
      isLong: params.isLong,
      shouldUnwrapNativeToken: params.shouldUnwrapNativeToken,
      referralCode: params.referralCode || import_ethers7.ethers.ZeroHash
    };
    return exchangeRouter.createOrder(orderParams, { value: executionFee });
  }
  /**
   * Cancel an existing order
   */
  async cancelOrder(orderKey) {
    if (!this.signer) {
      throw new Error("Signer required for trading operations");
    }
    const exchangeRouter = this.getExchangeRouter();
    return exchangeRouter.cancelOrder(orderKey);
  }
  /**
   * Send WETH/WAVAX for order execution fee
   */
  async sendWnt(receiver, amount) {
    if (!this.signer) {
      throw new Error("Signer required for trading operations");
    }
    const exchangeRouter = this.getExchangeRouter();
    return exchangeRouter.sendWnt(receiver, amount, { value: amount });
  }
  /**
   * Send tokens to a receiver
   */
  async sendTokens(token, receiver, amount) {
    if (!this.signer) {
      throw new Error("Signer required for trading operations");
    }
    const exchangeRouter = this.getExchangeRouter();
    return exchangeRouter.sendTokens(token, receiver, amount);
  }
  // ==========================================================================
  // Read Operations
  // ==========================================================================
  /**
   * Get account positions
   */
  async getAccountPositions(account, start = 0, end = 100) {
    const reader = this.getReader();
    const positions = await reader.getAccountPositions(
      this.addresses.dataStore,
      account,
      start,
      end
    );
    return positions;
  }
  /**
   * Get account orders
   */
  async getAccountOrders(account, start = 0, end = 100) {
    const reader = this.getReader();
    const orders = await reader.getAccountOrders(
      this.addresses.dataStore,
      account,
      start,
      end
    );
    return orders;
  }
  /**
   * Get a specific position
   */
  async getPosition(positionKey) {
    const reader = this.getReader();
    try {
      const position = await reader.getPosition(this.addresses.dataStore, positionKey);
      return position;
    } catch {
      return null;
    }
  }
  /**
   * Calculate position key
   */
  getPositionKey(account, market, collateralToken, isLong) {
    return import_ethers7.ethers.keccak256(
      import_ethers7.ethers.solidityPacked(
        ["address", "address", "address", "bool"],
        [account, market, collateralToken, isLong]
      )
    );
  }
  // ==========================================================================
  // DataStore Operations
  // ==========================================================================
  /**
   * Get a uint value from DataStore
   */
  async getDataStoreUint(key) {
    const dataStore = this.getDataStore();
    return dataStore.getUint(key);
  }
  /**
   * Get execution fee for a given gas limit
   */
  async getExecutionFee(gasLimit) {
    const gasPrice = await this.provider.getFeeData();
    const baseGasLimit = 500000n;
    const totalGasLimit = baseGasLimit + gasLimit;
    const executionFee = totalGasLimit * (gasPrice.gasPrice || 0n);
    return executionFee * 120n / 100n;
  }
  // ==========================================================================
  // Helpers
  // ==========================================================================
  /**
   * Encode order type to bytes32
   */
  encodeOrderType(orderType) {
    const orderTypes = {
      0: import_ethers7.ethers.encodeBytes32String("MarketIncrease"),
      1: import_ethers7.ethers.encodeBytes32String("MarketDecrease"),
      2: import_ethers7.ethers.encodeBytes32String("LimitIncrease"),
      3: import_ethers7.ethers.encodeBytes32String("LimitDecrease"),
      4: import_ethers7.ethers.encodeBytes32String("StopLossDecrease"),
      5: import_ethers7.ethers.encodeBytes32String("Liquidation")
    };
    return orderTypes[orderType] || import_ethers7.ethers.encodeBytes32String("MarketIncrease");
  }
  /**
   * Encode decrease position swap type
   */
  encodeDecreaseSwapType(swapType) {
    const swapTypes = {
      0: import_ethers7.ethers.encodeBytes32String("NoSwap"),
      1: import_ethers7.ethers.encodeBytes32String("SwapPnlTokenToCollateralToken"),
      2: import_ethers7.ethers.encodeBytes32String("SwapCollateralTokenToPnlToken")
    };
    return swapTypes[swapType] || import_ethers7.ethers.encodeBytes32String("NoSwap");
  }
  /**
   * Get contract addresses
   */
  getAddresses() {
    return this.addresses;
  }
  /**
   * Get chain ID
   */
  getChainId() {
    return GMX_API_URLS[this.chain].chainId;
  }
};

// src/adapters/gmx/GmxSubgraph.ts
var POSITIONS_QUERY = `
  query GetPositions($account: String!) {
    positions(
      where: { account: $account }
      orderBy: increasedAtBlock
      orderDirection: desc
    ) {
      id
      account
      market
      collateralToken
      sizeInUsd
      sizeInTokens
      collateralAmount
      borrowingFactor
      fundingFeeAmountPerSize
      longTokenClaimableFundingAmountPerSize
      shortTokenClaimableFundingAmountPerSize
      increasedAtBlock
      decreasedAtBlock
      isLong
    }
  }
`;
var ORDERS_QUERY = `
  query GetOrders($account: String!, $status: String) {
    orders(
      where: {
        account: $account
        status: $status
      }
      orderBy: updatedAtBlock
      orderDirection: desc
      first: 100
    ) {
      key
      account
      receiver
      callbackContract
      uiFeeReceiver
      market
      initialCollateralToken
      swapPath
      orderType
      decreasePositionSwapType
      sizeDeltaUsd
      initialCollateralDeltaAmount
      triggerPrice
      acceptablePrice
      executionFee
      callbackGasLimit
      minOutputAmount
      updatedAtBlock
      isLong
      isFrozen
      status
      createdTxn
      cancelledTxn
      executedTxn
    }
  }
`;
var ORDER_HISTORY_QUERY = `
  query GetOrderHistory($account: String!, $since: BigInt) {
    orders(
      where: {
        account: $account
        updatedAtBlock_gte: $since
      }
      orderBy: updatedAtBlock
      orderDirection: desc
      first: 100
    ) {
      key
      account
      receiver
      callbackContract
      uiFeeReceiver
      market
      initialCollateralToken
      swapPath
      orderType
      decreasePositionSwapType
      sizeDeltaUsd
      initialCollateralDeltaAmount
      triggerPrice
      acceptablePrice
      executionFee
      callbackGasLimit
      minOutputAmount
      updatedAtBlock
      isLong
      isFrozen
      status
      createdTxn
      cancelledTxn
      executedTxn
    }
  }
`;
var TRADES_QUERY = `
  query GetTrades($account: String!, $since: BigInt, $limit: Int) {
    tradeActions(
      where: {
        account: $account
        timestamp_gte: $since
      }
      orderBy: timestamp
      orderDirection: desc
      first: $limit
    ) {
      id
      account
      marketAddress
      collateralTokenAddress
      sizeDeltaUsd
      collateralDeltaAmount
      orderType
      isLong
      executionPrice
      priceImpactUsd
      pnlUsd
      timestamp
      transactionHash
    }
  }
`;
var MARKET_TRADES_QUERY = `
  query GetMarketTrades($market: String!, $since: BigInt, $limit: Int) {
    tradeActions(
      where: {
        marketAddress: $market
        timestamp_gte: $since
      }
      orderBy: timestamp
      orderDirection: desc
      first: $limit
    ) {
      id
      account
      marketAddress
      collateralTokenAddress
      sizeDeltaUsd
      collateralDeltaAmount
      orderType
      isLong
      executionPrice
      priceImpactUsd
      pnlUsd
      timestamp
      transactionHash
    }
  }
`;
var GmxSubgraph = class {
  subgraphUrl;
  constructor(chain) {
    this.subgraphUrl = GMX_API_URLS[chain].subgraph;
  }
  // ==========================================================================
  // Position Queries
  // ==========================================================================
  /**
   * Fetch all positions for an account
   */
  async fetchPositions(account) {
    const response = await this.query(
      POSITIONS_QUERY,
      { account: account.toLowerCase() }
    );
    return response.positions.filter(
      (p) => (
        // Filter out closed positions (size = 0)
        parseFloat(p.sizeInUsd) > 0
      )
    );
  }
  // ==========================================================================
  // Order Queries
  // ==========================================================================
  /**
   * Fetch open orders for an account
   */
  async fetchOpenOrders(account) {
    const response = await this.query(
      ORDERS_QUERY,
      {
        account: account.toLowerCase(),
        status: "Created"
      }
    );
    return response.orders;
  }
  /**
   * Fetch all orders (including filled/cancelled) for an account
   */
  async fetchOrderHistory(account, since) {
    const sinceBlock = since ? Math.floor(since / 1e3) : 0;
    const response = await this.query(
      ORDER_HISTORY_QUERY,
      {
        account: account.toLowerCase(),
        since: sinceBlock.toString()
      }
    );
    return response.orders;
  }
  // ==========================================================================
  // Trade Queries
  // ==========================================================================
  /**
   * Fetch trades for an account
   */
  async fetchAccountTrades(account, since, limit = 50) {
    const sinceTimestamp = since ? Math.floor(since / 1e3) : 0;
    const response = await this.query(
      TRADES_QUERY,
      {
        account: account.toLowerCase(),
        since: sinceTimestamp.toString(),
        limit
      }
    );
    return response.tradeActions;
  }
  /**
   * Fetch trades for a specific market
   */
  async fetchMarketTrades(marketAddress, since, limit = 50) {
    const sinceTimestamp = since ? Math.floor(since / 1e3) : 0;
    const response = await this.query(
      MARKET_TRADES_QUERY,
      {
        market: marketAddress.toLowerCase(),
        since: sinceTimestamp.toString(),
        limit
      }
    );
    return response.tradeActions;
  }
  // ==========================================================================
  // Helper Methods
  // ==========================================================================
  /**
   * Execute a GraphQL query
   */
  async query(query, variables) {
    const response = await fetch(this.subgraphUrl, {
      method: "POST",
      headers: {
        "Content-Type": "application/json"
      },
      body: JSON.stringify({
        query,
        variables
      })
    });
    if (!response.ok) {
      throw new Error(`Subgraph request failed: ${response.status} ${response.statusText}`);
    }
    const json = await response.json();
    if (json.errors && json.errors.length > 0) {
      throw new Error(`Subgraph query error: ${json.errors[0]?.message || "Unknown error"}`);
    }
    if (!json.data) {
      throw new Error("No data returned from subgraph");
    }
    return json.data;
  }
  /**
   * Convert subgraph position to normalized format
   */
  normalizePosition(position, markPrice) {
    const sizeUsd = parseFloat(position.sizeInUsd) / GMX_PRECISION.USD;
    const sizeInTokens = parseFloat(position.sizeInTokens);
    const collateralAmount = parseFloat(position.collateralAmount);
    const entryPrice = sizeInTokens > 0 ? sizeUsd / sizeInTokens : 0;
    const priceDiff = position.isLong ? markPrice - entryPrice : entryPrice - markPrice;
    const unrealizedPnl = sizeInTokens * priceDiff;
    const unrealizedPnlPercent = collateralAmount > 0 ? unrealizedPnl / collateralAmount * 100 : 0;
    const marketConfig = getMarketByAddress(position.market);
    return {
      symbol: marketConfig?.symbol || position.market,
      marketAddress: position.market,
      side: position.isLong ? "long" : "short",
      size: sizeInTokens,
      sizeUsd,
      collateral: collateralAmount,
      collateralToken: position.collateralToken,
      entryPrice,
      markPrice,
      unrealizedPnl,
      unrealizedPnlPercent,
      leverage: collateralAmount > 0 ? sizeUsd / collateralAmount : 0,
      isLong: position.isLong
    };
  }
  /**
   * Convert subgraph order to normalized format
   */
  normalizeOrder(order) {
    const sizeDeltaUsd = parseFloat(order.sizeDeltaUsd) / GMX_PRECISION.USD;
    const triggerPrice = parseFloat(order.triggerPrice) / GMX_PRECISION.PRICE;
    const acceptablePrice = parseFloat(order.acceptablePrice) / GMX_PRECISION.PRICE;
    const marketConfig = getMarketByAddress(order.market);
    const orderTypeMap = {
      0: "market",
      // MarketIncrease
      1: "market",
      // MarketDecrease
      2: "limit",
      // LimitIncrease
      3: "limit",
      // LimitDecrease
      4: "stopMarket",
      // StopLossDecrease
      5: "market"
      // Liquidation
    };
    const statusMap = {
      "Created": "open",
      "Executed": "filled",
      "Cancelled": "cancelled",
      "Frozen": "open",
      "Expired": "expired"
    };
    const isIncrease = order.orderType === 0 || order.orderType === 2;
    const side = isIncrease ? order.isLong ? "buy" : "sell" : order.isLong ? "sell" : "buy";
    return {
      id: order.key,
      symbol: marketConfig?.symbol || order.market,
      marketAddress: order.market,
      type: orderTypeMap[order.orderType] || "limit",
      side,
      isLong: order.isLong,
      amount: sizeDeltaUsd,
      price: triggerPrice || acceptablePrice,
      triggerPrice: triggerPrice > 0 ? triggerPrice : void 0,
      status: statusMap[order.status] || "open",
      createdTxn: order.createdTxn,
      executedTxn: order.executedTxn,
      cancelledTxn: order.cancelledTxn
    };
  }
  /**
   * Convert subgraph trade to normalized format
   */
  normalizeTrade(trade) {
    const sizeDeltaUsd = parseFloat(trade.sizeDeltaUsd) / GMX_PRECISION.USD;
    const executionPrice = parseFloat(trade.executionPrice) / GMX_PRECISION.PRICE;
    const pnlUsd = parseFloat(trade.pnlUsd || "0") / GMX_PRECISION.USD;
    const priceImpactUsd = parseFloat(trade.priceImpactUsd || "0") / GMX_PRECISION.USD;
    const marketConfig = getMarketByAddress(trade.marketAddress);
    const isIncrease = trade.orderType === 0 || trade.orderType === 2;
    const side = isIncrease ? trade.isLong ? "buy" : "sell" : trade.isLong ? "sell" : "buy";
    return {
      id: trade.id,
      symbol: marketConfig?.symbol || trade.marketAddress,
      marketAddress: trade.marketAddress,
      side,
      isLong: trade.isLong,
      amount: executionPrice > 0 ? sizeDeltaUsd / executionPrice : 0,
      price: executionPrice,
      cost: sizeDeltaUsd,
      pnl: pnlUsd,
      priceImpact: priceImpactUsd,
      timestamp: parseInt(trade.timestamp) * 1e3,
      transactionHash: trade.transactionHash
    };
  }
};

// src/adapters/gmx/GmxOrderBuilder.ts
var import_ethers8 = require("ethers");
var GmxOrderBuilder = class {
  chain;
  auth;
  config;
  constructor(chain, auth, _contracts, config = {}) {
    this.chain = chain;
    this.auth = auth;
    this.config = {
      slippageTolerance: config.slippageTolerance ?? 3e-3,
      callbackGasLimit: config.callbackGasLimit ?? 0n,
      referralCode: config.referralCode ?? ""
    };
  }
  // ==========================================================================
  // Order Building
  // ==========================================================================
  /**
   * Build create order parameters for a new position or position increase
   */
  buildCreateOrderParams(request, prices) {
    const marketKey = unifiedToGmx(request.symbol);
    if (!marketKey) {
      throw new Error(`Invalid market: ${request.symbol}`);
    }
    const marketConfig = GMX_MARKETS[marketKey];
    const walletAddress = this.auth.getWalletAddress();
    if (!walletAddress) {
      throw new Error("Wallet address required");
    }
    const isLong = request.side === "buy";
    const isIncrease = !request.reduceOnly;
    const orderType = this.getOrderType(request.type, isIncrease);
    const sizeUsd = request.amount * prices.indexPrice;
    const sizeDeltaUsd = BigInt(Math.floor(sizeUsd * GMX_PRECISION.USD));
    const leverage = request.leverage || 10;
    const collateralUsd = isIncrease ? sizeUsd / leverage : 0;
    const collateralToken = marketConfig.shortToken;
    const collateralDecimals = 6;
    const initialCollateralDeltaAmount = BigInt(
      Math.floor(collateralUsd * Math.pow(10, collateralDecimals))
    );
    const acceptablePrice = this.calculateAcceptablePrice(
      prices.indexPrice,
      isLong,
      isIncrease,
      this.config.slippageTolerance
    );
    const triggerPrice = this.calculateTriggerPrice(request, isLong);
    return {
      receiver: walletAddress,
      callbackContract: import_ethers8.ethers.ZeroAddress,
      uiFeeReceiver: import_ethers8.ethers.ZeroAddress,
      market: marketConfig.marketAddress,
      initialCollateralToken: collateralToken,
      swapPath: [],
      // No swap needed when using USDC as collateral
      sizeDeltaUsd,
      initialCollateralDeltaAmount,
      triggerPrice: BigInt(Math.floor(triggerPrice * GMX_PRECISION.PRICE)),
      acceptablePrice: BigInt(Math.floor(acceptablePrice * GMX_PRECISION.PRICE)),
      executionFee: 0n,
      // Set later
      callbackGasLimit: this.config.callbackGasLimit,
      minOutputAmount: 0n,
      orderType,
      decreasePositionSwapType: GMX_DECREASE_POSITION_SWAP_TYPES.NO_SWAP,
      isLong,
      shouldUnwrapNativeToken: false,
      referralCode: this.config.referralCode ? import_ethers8.ethers.encodeBytes32String(this.config.referralCode) : import_ethers8.ethers.ZeroHash
    };
  }
  /**
   * Build parameters for closing a position
   */
  buildClosePositionParams(symbol, sizeUsd, isLong, prices) {
    const marketKey = unifiedToGmx(symbol);
    if (!marketKey) {
      throw new Error(`Invalid market: ${symbol}`);
    }
    const marketConfig = GMX_MARKETS[marketKey];
    const walletAddress = this.auth.getWalletAddress();
    if (!walletAddress) {
      throw new Error("Wallet address required");
    }
    const acceptablePrice = this.calculateAcceptablePrice(
      prices.indexPrice,
      isLong,
      false,
      // decrease
      this.config.slippageTolerance
    );
    return {
      receiver: walletAddress,
      callbackContract: import_ethers8.ethers.ZeroAddress,
      uiFeeReceiver: import_ethers8.ethers.ZeroAddress,
      market: marketConfig.marketAddress,
      initialCollateralToken: marketConfig.shortToken,
      swapPath: [],
      sizeDeltaUsd: BigInt(Math.floor(sizeUsd * GMX_PRECISION.USD)),
      initialCollateralDeltaAmount: 0n,
      // Will receive collateral back
      triggerPrice: 0n,
      acceptablePrice: BigInt(Math.floor(acceptablePrice * GMX_PRECISION.PRICE)),
      executionFee: 0n,
      // Set later
      callbackGasLimit: this.config.callbackGasLimit,
      minOutputAmount: 0n,
      orderType: GMX_ORDER_TYPES.MARKET_DECREASE,
      decreasePositionSwapType: GMX_DECREASE_POSITION_SWAP_TYPES.NO_SWAP,
      isLong,
      shouldUnwrapNativeToken: false,
      referralCode: import_ethers8.ethers.ZeroHash
    };
  }
  // ==========================================================================
  // Execution Fee Calculation
  // ==========================================================================
  /**
   * Calculate execution fee for order
   */
  async calculateExecutionFee() {
    const gasPrice = await this.auth.getGasPrice();
    const gasLimit = 1500000n;
    const executionFee = gasLimit * gasPrice;
    return executionFee * 130n / 100n;
  }
  /**
   * Calculate minimum execution fee based on current network conditions
   */
  async getMinExecutionFee() {
    const minFees = {
      arbitrum: import_ethers8.ethers.parseEther("0.0003"),
      // ~$0.50
      avalanche: import_ethers8.ethers.parseEther("0.01")
      // ~$0.30
    };
    const minFee = minFees[this.chain];
    const calculatedFee = await this.calculateExecutionFee();
    return calculatedFee > minFee ? calculatedFee : minFee;
  }
  // ==========================================================================
  // Helper Methods
  // ==========================================================================
  /**
   * Get GMX order type based on request type
   */
  getOrderType(orderType, isIncrease) {
    switch (orderType) {
      case "market":
        return isIncrease ? GMX_ORDER_TYPES.MARKET_INCREASE : GMX_ORDER_TYPES.MARKET_DECREASE;
      case "limit":
        return isIncrease ? GMX_ORDER_TYPES.LIMIT_INCREASE : GMX_ORDER_TYPES.LIMIT_DECREASE;
      case "stopMarket":
      case "stopLimit":
        return GMX_ORDER_TYPES.STOP_LOSS;
      default:
        return isIncrease ? GMX_ORDER_TYPES.MARKET_INCREASE : GMX_ORDER_TYPES.MARKET_DECREASE;
    }
  }
  /**
   * Calculate acceptable price with slippage
   */
  calculateAcceptablePrice(currentPrice, isLong, isIncrease, slippage) {
    const multiplier = isLong === isIncrease ? 1 + slippage : 1 - slippage;
    return currentPrice * multiplier;
  }
  /**
   * Calculate trigger price for limit/stop orders
   */
  calculateTriggerPrice(request, _isLong) {
    if (request.type === "market") {
      return 0;
    }
    if (request.price) {
      return request.price;
    }
    if (request.stopPrice) {
      return request.stopPrice;
    }
    return 0;
  }
  /**
   * Validate order parameters
   */
  validateOrderParams(request) {
    const marketKey = unifiedToGmx(request.symbol);
    if (!marketKey) {
      throw new Error(`Invalid market: ${request.symbol}`);
    }
    const marketConfig = GMX_MARKETS[marketKey];
    if (request.amount < marketConfig.minOrderSize) {
      throw new Error(
        `Order size ${request.amount} is below minimum ${marketConfig.minOrderSize} for ${request.symbol}`
      );
    }
    const leverage = request.leverage || 10;
    if (leverage > marketConfig.maxLeverage) {
      throw new Error(
        `Leverage ${leverage}x exceeds maximum ${marketConfig.maxLeverage}x for ${request.symbol}`
      );
    }
    if (request.type === "limit" && !request.price) {
      throw new Error("Price required for limit orders");
    }
    if ((request.type === "stopMarket" || request.type === "stopLimit") && !request.stopPrice) {
      throw new Error("Stop price required for stop orders");
    }
  }
  /**
   * Get market configuration
   */
  getMarketConfig(symbol) {
    const marketKey = unifiedToGmx(symbol);
    if (!marketKey) {
      throw new Error(`Invalid market: ${symbol}`);
    }
    return GMX_MARKETS[marketKey];
  }
  /**
   * Calculate required collateral for a position
   */
  calculateRequiredCollateral(sizeUsd, leverage, _isLong) {
    const collateralUsd = sizeUsd / leverage;
    return {
      collateralUsd,
      collateralToken: "USDC"
    };
  }
  /**
   * Calculate position's liquidation price
   */
  calculateLiquidationPrice(entryPrice, leverage, isLong, maintenanceMarginRate = 0.01) {
    const lossRate = (1 - maintenanceMarginRate) / leverage;
    return isLong ? entryPrice * (1 - lossRate) : entryPrice * (1 + lossRate);
  }
};

// src/adapters/gmx/error-codes.ts
function mapGmxError(error) {
  if (error instanceof PerpDEXError) {
    return error;
  }
  if (error instanceof Error) {
    const message = error.message.toLowerCase();
    for (const [pattern, code] of Object.entries(GMX_ERROR_MESSAGES)) {
      if (message.includes(pattern)) {
        switch (code) {
          case "INSUFFICIENT_MARGIN":
            return new InsufficientMarginError(error.message, code, "gmx", error);
          case "INSUFFICIENT_BALANCE":
            return new InsufficientBalanceError(error.message, code, "gmx", void 0, void 0, error);
          case "POSITION_NOT_FOUND":
            return new PositionNotFoundError(error.message, code, "gmx", error);
          case "ORDER_NOT_FOUND":
            return new OrderNotFoundError(error.message, code, "gmx", error);
          case "MAX_LEVERAGE_EXCEEDED":
          case "MIN_ORDER_SIZE":
          case "SLIPPAGE_EXCEEDED":
          case "INVALID_PRICE":
            return new InvalidOrderError(error.message, code, "gmx", error);
          case "ORACLE_ERROR":
          case "MARKET_PAUSED":
          case "KEEPER_ERROR":
            return new ExchangeUnavailableError(error.message, code, "gmx", error);
          case "TRANSACTION_FAILED":
            return new TransactionFailedError(error.message, code, "gmx", void 0, error);
          case "LIQUIDATION":
            return new LiquidationError(error.message, code, "gmx", error);
        }
      }
    }
    if (message.includes("insufficient funds") || message.includes("insufficient gas")) {
      return new InsufficientBalanceError(
        "Insufficient funds for transaction",
        "INSUFFICIENT_GAS",
        "gmx",
        void 0,
        void 0,
        error
      );
    }
    if (message.includes("nonce") || message.includes("already known")) {
      return new TransactionFailedError(
        "Transaction nonce error",
        "NONCE_ERROR",
        "gmx",
        void 0,
        error
      );
    }
    if (message.includes("signature") || message.includes("unauthorized")) {
      return new InvalidSignatureError(
        "Invalid transaction signature",
        "INVALID_SIGNATURE",
        "gmx",
        error
      );
    }
    if (message.includes("429") || message.includes("rate limit") || message.includes("too many requests")) {
      return new RateLimitError("Rate limit exceeded", "RATE_LIMIT", "gmx", void 0, error);
    }
    if (message.includes("503") || message.includes("502") || message.includes("504") || message.includes("service unavailable")) {
      return new ExchangeUnavailableError(
        "GMX API temporarily unavailable",
        "API_UNAVAILABLE",
        "gmx",
        error
      );
    }
    if (message.includes("timeout") || message.includes("timed out")) {
      return new ExchangeUnavailableError(
        "Request timeout",
        "TIMEOUT",
        "gmx",
        error
      );
    }
    if (message.includes("network") || message.includes("connection")) {
      return new ExchangeUnavailableError(
        "Network connection error",
        "NETWORK_ERROR",
        "gmx",
        error
      );
    }
    if (message.includes("graphql") || message.includes("query")) {
      return new ExchangeUnavailableError(
        "Subgraph query error",
        "SUBGRAPH_ERROR",
        "gmx",
        error
      );
    }
    if (message.includes("reverted") || message.includes("revert")) {
      return new TransactionFailedError(
        "Transaction reverted",
        "TX_REVERTED",
        "gmx",
        void 0,
        error
      );
    }
    if (message.includes("keeper") || message.includes("execution failed")) {
      return new TransactionFailedError(
        "Order execution failed by keeper",
        "KEEPER_EXECUTION_FAILED",
        "gmx",
        void 0,
        error
      );
    }
    if (message.includes("market not found") || message.includes("invalid market")) {
      return new InvalidOrderError(
        "Invalid or unsupported market",
        "INVALID_MARKET",
        "gmx",
        error
      );
    }
    if (message.includes("disabled") || message.includes("paused")) {
      return new ExchangeUnavailableError(
        "Market is disabled or paused",
        "MARKET_DISABLED",
        "gmx",
        error
      );
    }
    if (message.includes("position size") || message.includes("exceeds")) {
      return new InvalidOrderError(
        "Position size exceeds limit",
        "MAX_POSITION_SIZE",
        "gmx",
        error
      );
    }
    if (message.includes("min collateral")) {
      return new InsufficientMarginError(
        "Below minimum collateral requirement",
        "MIN_COLLATERAL",
        "gmx",
        error
      );
    }
  }
  return new ExchangeUnavailableError(
    "Unknown exchange error",
    "UNKNOWN_ERROR",
    "gmx",
    error
  );
}

// src/adapters/gmx/GmxAdapter.ts
var GmxAdapter = class extends BaseAdapter {
  id = "gmx";
  name = "GMX v2";
  has = {
    // Market data
    fetchMarkets: true,
    fetchTicker: true,
    fetchOrderBook: false,
    // GMX doesn't have a traditional orderbook
    fetchTrades: false,
    // Requires subgraph query
    fetchFundingRate: true,
    fetchFundingRateHistory: false,
    fetchOHLCV: true,
    // Trading (enabled with private key)
    createOrder: true,
    cancelOrder: true,
    cancelAllOrders: true,
    createBatchOrders: false,
    cancelBatchOrders: false,
    // Account data
    fetchPositions: true,
    fetchBalance: true,
    fetchOpenOrders: true,
    fetchOrderHistory: true,
    fetchMyTrades: false,
    // Position management
    setLeverage: false,
    // Leverage is per-position
    setMarginMode: false,
    // Always cross margin
    // WebSocket (not available via REST)
    watchOrderBook: false,
    watchTrades: false,
    watchTicker: false,
    watchPositions: false,
    watchOrders: false,
    watchBalance: false
  };
  normalizer;
  chain;
  apiBaseUrl;
  walletAddress;
  auth;
  contracts;
  subgraph;
  orderBuilder;
  orderConfig;
  marketsCache = /* @__PURE__ */ new Map();
  marketsCacheTimestamp = 0;
  marketsCacheTTL = 6e4;
  // 1 minute
  pricesCache = /* @__PURE__ */ new Map();
  pricesCacheTimestamp = 0;
  pricesCacheTTL = 5e3;
  // 5 seconds for price data
  constructor(config = {}) {
    super({
      timeout: 3e4,
      ...config
    });
    this.chain = config.chain || "arbitrum";
    this.apiBaseUrl = GMX_API_URLS[this.chain].api;
    this.walletAddress = config.walletAddress;
    this.orderConfig = config.orderConfig;
    this.normalizer = new GmxNormalizer();
    if (config.privateKey) {
      this.auth = new GmxAuth({
        privateKey: config.privateKey,
        chain: this.chain,
        rpcEndpoint: config.rpcEndpoint
      });
      this.walletAddress = this.auth.getWalletAddress();
    } else if (config.walletAddress) {
      this.auth = new GmxAuth({
        walletAddress: config.walletAddress,
        chain: this.chain,
        rpcEndpoint: config.rpcEndpoint
      });
    }
  }
  // ==========================================================================
  // Connection Management
  // ==========================================================================
  async initialize() {
    if (this._isReady) {
      this.debug("Already initialized");
      return;
    }
    this.debug("Initializing GMX adapter...");
    try {
      await this.fetchMarketsInfo();
      if (this.auth) {
        this.contracts = new GmxContracts(
          this.chain,
          this.auth.getProvider(),
          this.auth.getSigner()
        );
        this.subgraph = new GmxSubgraph(this.chain);
        if (this.auth.canSign() && this.contracts) {
          this.orderBuilder = new GmxOrderBuilder(
            this.chain,
            this.auth,
            this.contracts,
            this.orderConfig
          );
        }
      }
      this._isReady = true;
      this.info(`GMX adapter initialized successfully (${this.chain})`);
    } catch (error) {
      this.error("Failed to initialize GMX adapter", error instanceof Error ? error : void 0);
      throw mapGmxError(error);
    }
  }
  async disconnect() {
    this._isReady = false;
    this.marketsCache.clear();
    this.pricesCache.clear();
    this.info("GMX adapter disconnected");
  }
  // ==========================================================================
  // Market Data
  // ==========================================================================
  async fetchMarkets(params) {
    this.ensureInitialized();
    try {
      const marketsInfo = await this.fetchMarketsInfo();
      let markets = this.normalizer.normalizeMarkets(marketsInfo, this.chain);
      if (params?.active !== void 0) {
        markets = markets.filter((m) => m.active === params.active);
      }
      return markets;
    } catch (error) {
      throw mapGmxError(error);
    }
  }
  async fetchTicker(symbol) {
    this.ensureInitialized();
    const marketKey = unifiedToGmx(symbol);
    if (!marketKey) {
      throw new Error(`Invalid market: ${symbol}`);
    }
    try {
      const [marketsInfo, prices] = await Promise.all([
        this.fetchMarketsInfo(),
        this.fetchPrices()
      ]);
      const config = GMX_MARKETS[marketKey];
      const marketInfo = marketsInfo.find(
        (m) => m.marketToken.toLowerCase() === config.marketAddress.toLowerCase()
      );
      if (!marketInfo) {
        throw new Error(`Market info not found for ${symbol}`);
      }
      const indexTokenPrice = prices.get(config.indexToken.toLowerCase());
      const priceData = indexTokenPrice ? {
        minPrice: parseFloat(indexTokenPrice.minPrice) / GMX_PRECISION.PRICE,
        maxPrice: parseFloat(indexTokenPrice.maxPrice) / GMX_PRECISION.PRICE
      } : void 0;
      return this.normalizer.normalizeTicker(marketInfo, priceData);
    } catch (error) {
      throw mapGmxError(error);
    }
  }
  async fetchOrderBook(_symbol, _params) {
    throw new Error("GMX does not have a traditional orderbook. Use fetchTicker for price data.");
  }
  async fetchTrades(_symbol, _params) {
    throw new Error("fetchTrades requires subgraph integration. Not available via REST API.");
  }
  async fetchFundingRate(symbol) {
    this.ensureInitialized();
    const marketKey = unifiedToGmx(symbol);
    if (!marketKey) {
      throw new Error(`Invalid market: ${symbol}`);
    }
    try {
      const [marketsInfo, prices] = await Promise.all([
        this.fetchMarketsInfo(),
        this.fetchPrices()
      ]);
      const config = GMX_MARKETS[marketKey];
      const marketInfo = marketsInfo.find(
        (m) => m.marketToken.toLowerCase() === config.marketAddress.toLowerCase()
      );
      if (!marketInfo) {
        throw new Error(`Market info not found for ${symbol}`);
      }
      const indexTokenPrice = prices.get(config.indexToken.toLowerCase());
      let indexPrice = 0;
      if (indexTokenPrice) {
        const minPrice = parseFloat(indexTokenPrice.minPrice) / GMX_PRECISION.PRICE;
        const maxPrice = parseFloat(indexTokenPrice.maxPrice) / GMX_PRECISION.PRICE;
        indexPrice = (minPrice + maxPrice) / 2;
      }
      const longOI = parseFloat(marketInfo.longInterestUsd) / GMX_PRECISION.USD;
      const shortOI = parseFloat(marketInfo.shortInterestUsd) / GMX_PRECISION.USD;
      const fundingFactor = parseFloat(marketInfo.fundingFactor) / GMX_PRECISION.FACTOR;
      const imbalance = longOI - shortOI;
      const totalOI = longOI + shortOI;
      const imbalanceRatio = totalOI > 0 ? Math.abs(imbalance) / totalOI : 0;
      const hourlyRate = fundingFactor * imbalanceRatio * 3600;
      const fundingRate = imbalance > 0 ? hourlyRate : -hourlyRate;
      return {
        symbol: config.symbol,
        fundingRate,
        fundingTimestamp: Date.now(),
        nextFundingTimestamp: Date.now() + 36e5,
        // Next hour
        markPrice: indexPrice,
        indexPrice,
        fundingIntervalHours: 1,
        info: {
          marketAddress: config.marketAddress,
          longOpenInterestUsd: longOI,
          shortOpenInterestUsd: shortOI,
          imbalance,
          imbalanceRatio,
          fundingFactor: marketInfo.fundingFactor
        }
      };
    } catch (error) {
      throw mapGmxError(error);
    }
  }
  async fetchFundingRateHistory(_symbol, _since, _limit) {
    throw new Error("fetchFundingRateHistory requires subgraph integration. Not available via REST API.");
  }
  async fetchOHLCV(symbol, timeframe = "1h", params) {
    this.ensureInitialized();
    const marketKey = unifiedToGmx(symbol);
    if (!marketKey) {
      throw new Error(`Invalid market: ${symbol}`);
    }
    const config = GMX_MARKETS[marketKey];
    try {
      const interval = this.timeframeToInterval(timeframe);
      const queryParams = new URLSearchParams({
        tokenSymbol: config.baseAsset,
        period: interval
      });
      if (params?.since) {
        queryParams.set("from", Math.floor(params.since / 1e3).toString());
      }
      if (params?.limit) {
        queryParams.set("limit", params.limit.toString());
      }
      const url = `${this.apiBaseUrl}/prices/candles?${queryParams.toString()}`;
      const candles = await this.request("GET", url);
      return this.normalizer.normalizeCandles(candles);
    } catch (error) {
      throw mapGmxError(error);
    }
  }
  // ==========================================================================
  // Account Data
  // ==========================================================================
  async fetchPositions(symbols) {
    this.ensureInitialized();
    if (!this.auth || !this.walletAddress) {
      throw new Error("Wallet address required to fetch positions");
    }
    if (!this.subgraph) {
      throw new Error("Subgraph not initialized");
    }
    try {
      const rawPositions = await this.subgraph.fetchPositions(this.walletAddress);
      const prices = await this.fetchPrices();
      const positions = [];
      for (const pos of rawPositions) {
        const marketConfig = Object.values(GMX_MARKETS).find(
          (m) => m.marketAddress.toLowerCase() === pos.market.toLowerCase()
        );
        if (!marketConfig) continue;
        const indexTokenPrice = prices.get(marketConfig.indexToken.toLowerCase());
        let markPrice = 0;
        if (indexTokenPrice) {
          const minPrice = parseFloat(indexTokenPrice.minPrice) / GMX_PRECISION.PRICE;
          const maxPrice = parseFloat(indexTokenPrice.maxPrice) / GMX_PRECISION.PRICE;
          markPrice = (minPrice + maxPrice) / 2;
        }
        const position = this.normalizer.normalizePosition(pos, markPrice, this.chain);
        if (!symbols || symbols.includes(position.symbol)) {
          positions.push(position);
        }
      }
      return positions;
    } catch (error) {
      throw mapGmxError(error);
    }
  }
  async fetchBalance() {
    this.ensureInitialized();
    if (!this.auth || !this.walletAddress) {
      throw new Error("Wallet address required to fetch balance");
    }
    try {
      const ethBalance = await this.auth.getBalance();
      const ethBalanceNum = Number(ethBalance) / 1e18;
      const prices = await this.fetchPrices();
      const wethAddress = this.chain === "arbitrum" ? "0x82aF49447D8a07e3bd95BD0d56f35241523fBab1" : "0xB31f66AA3C1e785363F0875A1B74E27b85FD66c7";
      const ethPriceData = prices.get(wethAddress.toLowerCase());
      let ethPrice = 0;
      if (ethPriceData) {
        const minPrice = parseFloat(ethPriceData.minPrice) / GMX_PRECISION.PRICE;
        const maxPrice = parseFloat(ethPriceData.maxPrice) / GMX_PRECISION.PRICE;
        ethPrice = (minPrice + maxPrice) / 2;
      }
      const balances = [
        {
          currency: this.chain === "arbitrum" ? "ETH" : "AVAX",
          total: ethBalanceNum,
          free: ethBalanceNum,
          used: 0,
          usdValue: ethBalanceNum * ethPrice
        }
      ];
      const usdcAddress = this.chain === "arbitrum" ? "0xaf88d065e77c8cC2239327C5EDb3A432268e5831" : "0xB97EF9Ef8734C71904D8002F8b6Bc66Dd9c48a6E";
      const usdcBalance = await this.auth.getTokenBalance(usdcAddress);
      const usdcBalanceNum = Number(usdcBalance) / 1e6;
      balances.push({
        currency: "USDC",
        total: usdcBalanceNum,
        free: usdcBalanceNum,
        used: 0,
        usdValue: usdcBalanceNum
      });
      return balances;
    } catch (error) {
      throw mapGmxError(error);
    }
  }
  async fetchOpenOrders(symbol) {
    this.ensureInitialized();
    if (!this.auth || !this.walletAddress) {
      throw new Error("Wallet address required to fetch orders");
    }
    if (!this.subgraph) {
      throw new Error("Subgraph not initialized");
    }
    try {
      const orders = await this.subgraph.fetchOpenOrders(this.walletAddress);
      const prices = await this.fetchPrices();
      const normalizedOrders = [];
      for (const order of orders) {
        const marketConfig = Object.values(GMX_MARKETS).find(
          (m) => m.marketAddress.toLowerCase() === order.market.toLowerCase()
        );
        let marketPrice;
        if (marketConfig) {
          const indexTokenPrice = prices.get(marketConfig.indexToken.toLowerCase());
          if (indexTokenPrice) {
            const minPrice = parseFloat(indexTokenPrice.minPrice) / GMX_PRECISION.PRICE;
            const maxPrice = parseFloat(indexTokenPrice.maxPrice) / GMX_PRECISION.PRICE;
            marketPrice = (minPrice + maxPrice) / 2;
          }
        }
        const normalizedOrder = this.normalizer.normalizeOrder(order, marketPrice);
        if (!symbol || normalizedOrder.symbol === symbol) {
          normalizedOrders.push(normalizedOrder);
        }
      }
      return normalizedOrders;
    } catch (error) {
      throw mapGmxError(error);
    }
  }
  async fetchOrderHistory(symbol, since, limit) {
    this.ensureInitialized();
    if (!this.auth || !this.walletAddress) {
      throw new Error("Wallet address required to fetch order history");
    }
    if (!this.subgraph) {
      throw new Error("Subgraph not initialized");
    }
    try {
      const orders = await this.subgraph.fetchOrderHistory(this.walletAddress, since);
      const prices = await this.fetchPrices();
      const normalizedOrders = [];
      for (const order of orders) {
        const marketConfig = Object.values(GMX_MARKETS).find(
          (m) => m.marketAddress.toLowerCase() === order.market.toLowerCase()
        );
        let marketPrice;
        if (marketConfig) {
          const indexTokenPrice = prices.get(marketConfig.indexToken.toLowerCase());
          if (indexTokenPrice) {
            const minPrice = parseFloat(indexTokenPrice.minPrice) / GMX_PRECISION.PRICE;
            const maxPrice = parseFloat(indexTokenPrice.maxPrice) / GMX_PRECISION.PRICE;
            marketPrice = (minPrice + maxPrice) / 2;
          }
        }
        const normalizedOrder = this.normalizer.normalizeOrder(order, marketPrice);
        if (!symbol || normalizedOrder.symbol === symbol) {
          normalizedOrders.push(normalizedOrder);
        }
      }
      if (limit && normalizedOrders.length > limit) {
        return normalizedOrders.slice(0, limit);
      }
      return normalizedOrders;
    } catch (error) {
      throw mapGmxError(error);
    }
  }
  async fetchMyTrades(_symbol, _since, _limit) {
    throw new Error("fetchMyTrades requires subgraph integration. Not available via REST API.");
  }
  // ==========================================================================
  // Trading Operations
  // ==========================================================================
  async createOrder(request) {
    this.ensureInitialized();
    if (!this.auth || !this.auth.canSign()) {
      throw new Error("Private key required for trading");
    }
    if (!this.contracts || !this.orderBuilder) {
      throw new Error("Trading components not initialized");
    }
    try {
      this.orderBuilder.validateOrderParams(request);
      const prices = await this.fetchPrices();
      const marketKey = unifiedToGmx(request.symbol);
      if (!marketKey) {
        throw new Error(`Invalid market: ${request.symbol}`);
      }
      const marketConfig = GMX_MARKETS[marketKey];
      const indexTokenPrice = prices.get(marketConfig.indexToken.toLowerCase());
      if (!indexTokenPrice) {
        throw new Error(`Price not available for ${request.symbol}`);
      }
      const minPrice = parseFloat(indexTokenPrice.minPrice) / GMX_PRECISION.PRICE;
      const maxPrice = parseFloat(indexTokenPrice.maxPrice) / GMX_PRECISION.PRICE;
      const indexPrice = (minPrice + maxPrice) / 2;
      const priceData = {
        indexPrice,
        longTokenPrice: indexPrice,
        // Simplified
        shortTokenPrice: 1
        // USDC = $1
      };
      const orderParams = this.orderBuilder.buildCreateOrderParams(request, priceData);
      const executionFee = await this.orderBuilder.getMinExecutionFee();
      orderParams.executionFee = executionFee;
      if (!request.reduceOnly) {
        const collateralAmount = orderParams.initialCollateralDeltaAmount;
        const usdcAddress = marketConfig.shortToken;
        const allowance = await this.auth.getTokenAllowance(
          usdcAddress,
          GMX_API_URLS[this.chain].api.includes("arbitrum") ? "0x7452c558d45f8afC8c83dAe62C3f8A5BE19c71f6" : "0x820F5FfC5b525cD4d88Cd91aCd2119b38cB97b10"
          // Avalanche Router
        );
        if (allowance < collateralAmount) {
          this.debug("Approving USDC spending...");
          const approveTx = await this.auth.approveToken(
            usdcAddress,
            this.contracts.getAddresses().router,
            collateralAmount * 2n
            // Approve 2x for future orders
          );
          await approveTx.wait();
        }
      }
      this.debug("Creating order on-chain...");
      const tx = await this.contracts.createOrder(orderParams, executionFee);
      const receipt = await tx.wait();
      if (!receipt) {
        throw new Error("Transaction failed");
      }
      const orderKey = receipt.logs[0]?.topics[1] || receipt.hash;
      return {
        id: orderKey,
        symbol: request.symbol,
        type: request.type,
        side: request.side,
        amount: request.amount,
        price: request.price,
        status: "open",
        filled: 0,
        remaining: request.amount,
        reduceOnly: request.reduceOnly || false,
        postOnly: request.postOnly || false,
        clientOrderId: request.clientOrderId,
        timestamp: Date.now(),
        info: {
          txHash: receipt.hash,
          executionFee: executionFee.toString(),
          orderParams
        }
      };
    } catch (error) {
      throw mapGmxError(error);
    }
  }
  async cancelOrder(orderId, symbol) {
    this.ensureInitialized();
    if (!this.auth || !this.auth.canSign()) {
      throw new Error("Private key required for trading");
    }
    if (!this.contracts) {
      throw new Error("Contracts not initialized");
    }
    try {
      const tx = await this.contracts.cancelOrder(orderId);
      const receipt = await tx.wait();
      if (!receipt) {
        throw new Error("Transaction failed");
      }
      return {
        id: orderId,
        symbol: symbol || "UNKNOWN",
        type: "limit",
        side: "buy",
        amount: 0,
        status: "canceled",
        filled: 0,
        remaining: 0,
        reduceOnly: false,
        postOnly: false,
        timestamp: Date.now(),
        info: {
          txHash: receipt.hash
        }
      };
    } catch (error) {
      throw mapGmxError(error);
    }
  }
  async cancelAllOrders(symbol) {
    this.ensureInitialized();
    if (!this.auth || !this.auth.canSign()) {
      throw new Error("Private key required for trading");
    }
    try {
      const openOrders = await this.fetchOpenOrders(symbol);
      const canceledOrders = [];
      for (const order of openOrders) {
        try {
          const canceled = await this.cancelOrder(order.id, order.symbol);
          canceledOrders.push(canceled);
        } catch (error) {
          this.warn(`Failed to cancel order ${order.id}: ${error instanceof Error ? error.message : String(error)}`);
        }
      }
      return canceledOrders;
    } catch (error) {
      throw mapGmxError(error);
    }
  }
  async setLeverage(_symbol, _leverage) {
    throw new Error(
      "GMX v2 does not have account-level leverage settings. Leverage is determined per-position at order creation time."
    );
  }
  // ==========================================================================
  // Helper Methods
  // ==========================================================================
  /**
   * Fetch markets info from API with caching
   */
  async fetchMarketsInfo() {
    const now = Date.now();
    if (this.marketsCache.size > 0 && now - this.marketsCacheTimestamp < this.marketsCacheTTL) {
      return Array.from(this.marketsCache.values());
    }
    const url = `${this.apiBaseUrl}/markets/info`;
    const response = await this.request("GET", url);
    this.marketsCache.clear();
    for (const market of response.markets) {
      this.marketsCache.set(market.marketToken.toLowerCase(), market);
    }
    this.marketsCacheTimestamp = now;
    return response.markets;
  }
  /**
   * Fetch token prices from API with caching
   */
  async fetchPrices() {
    const now = Date.now();
    if (this.pricesCache.size > 0 && now - this.pricesCacheTimestamp < this.pricesCacheTTL) {
      return this.pricesCache;
    }
    try {
      const url = `${this.apiBaseUrl}/prices/tickers`;
      const response = await this.request("GET", url);
      this.pricesCache.clear();
      for (const price of response) {
        this.pricesCache.set(price.tokenAddress.toLowerCase(), price);
      }
      this.pricesCacheTimestamp = now;
    } catch (error) {
      this.debug(`Failed to fetch prices: ${error instanceof Error ? error.message : String(error)}`);
    }
    return this.pricesCache;
  }
  /**
   * Convert timeframe to GMX interval
   */
  timeframeToInterval(timeframe) {
    const mapping = {
      "1m": "1m",
      "3m": "5m",
      // GMX doesn't support 3m, use 5m
      "5m": "5m",
      "15m": "15m",
      "30m": "30m",
      "1h": "1h",
      "2h": "4h",
      // GMX doesn't support 2h, use 4h
      "4h": "4h",
      "6h": "4h",
      // GMX doesn't support 6h, use 4h
      "8h": "1d",
      // GMX doesn't support 8h, use 1d
      "12h": "1d",
      // GMX doesn't support 12h, use 1d
      "1d": "1d",
      "3d": "1w",
      // GMX doesn't support 3d, use 1w
      "1w": "1w",
      "1M": "1w"
      // GMX doesn't support 1M, use 1w
    };
    return mapping[timeframe] || "1h";
  }
  // ==========================================================================
  // Symbol Conversion
  // ==========================================================================
  /**
   * Convert symbol to exchange format
   */
  symbolToExchange(symbol) {
    const gmxSymbol = unifiedToGmx(symbol);
    if (!gmxSymbol) {
      throw new Error(`Invalid market symbol: ${symbol}`);
    }
    return gmxSymbol;
  }
  /**
   * Convert exchange symbol to unified format
   */
  symbolFromExchange(exchangeSymbol) {
    if (exchangeSymbol in GMX_MARKETS) {
      return gmxToUnified(exchangeSymbol);
    }
    return exchangeSymbol;
  }
  /**
   * Get chain info
   */
  getChain() {
    return this.chain;
  }
  /**
   * Get API base URL
   */
  getApiBaseUrl() {
    return this.apiBaseUrl;
  }
};

// src/factory.ts
var adapterRegistry = /* @__PURE__ */ new Map([
  ["hyperliquid", HyperliquidAdapter],
  ["lighter", LighterAdapter],
  ["grvt", GRVTAdapter],
  ["paradex", ParadexAdapter],
  ["edgex", EdgeXAdapter],
  ["backpack", BackpackAdapter],
  ["nado", NadoAdapter],
  ["variational", VariationalAdapter],
  ["extended", ExtendedAdapter],
  ["dydx", DydxAdapter],
  ["jupiter", JupiterAdapter],
  ["drift", DriftAdapter],
  ["gmx", GmxAdapter]
]);
var factoryLogger = new Logger("ExchangeFactory");
function createExchange(exchange, config) {
  const normalizedId = exchange.toLowerCase();
  const Constructor = adapterRegistry.get(normalizedId);
  if (!Constructor) {
    throw new Error(
      `Unknown exchange: ${exchange}. Supported exchanges: ${getSupportedExchanges().join(", ")}. Use registerExchange() to add custom adapters.`
    );
  }
  return new Constructor(config);
}
function getSupportedExchanges() {
  return Array.from(adapterRegistry.keys());
}
function isExchangeSupported(exchange) {
  return adapterRegistry.has(exchange.toLowerCase());
}

// src/types/common.ts
var ORDER_TYPES = ["market", "limit", "stopMarket", "stopLimit", "takeProfit", "trailingStop"];
var ORDER_SIDES = ["buy", "sell"];
var ORDER_STATUSES = [
  "open",
  "closed",
  "canceled",
  "expired",
  "rejected",
  "filled",
  "partiallyFilled"
];
var TIME_IN_FORCE = ["GTC", "IOC", "FOK", "PO"];
var POSITION_SIDES = ["long", "short"];
var MARGIN_MODES = ["cross", "isolated"];

// src/core/retry.ts
var DEFAULT_RETRY_CONFIG2 = {
  maxAttempts: 3,
  baseDelay: 1e3,
  maxDelay: 3e4,
  backoffMultiplier: 2,
  enableJitter: true,
  retryableErrors: [RateLimitError, ExchangeUnavailableError, WebSocketDisconnectedError]
};
function sleep(ms) {
  return new Promise((resolve) => setTimeout(resolve, ms));
}
function calculateDelay(attempt, baseDelay, maxDelay, multiplier, enableJitter) {
  let delay = baseDelay * Math.pow(multiplier, attempt - 1);
  if (enableJitter) {
    const jitter = delay * 0.25 * (Math.random() * 2 - 1);
    delay += jitter;
  }
  return Math.min(Math.max(delay, 0), maxDelay);
}
function isErrorRetryable(error, config) {
  if (config.isRetryable) {
    return config.isRetryable(error);
  }
  return config.retryableErrors.some((ErrorClass) => error instanceof ErrorClass);
}
async function withRetry(fn, config = {}) {
  const fullConfig = {
    ...DEFAULT_RETRY_CONFIG2,
    ...config
  };
  let lastError;
  let attempt = 0;
  while (attempt < fullConfig.maxAttempts) {
    attempt++;
    try {
      return await fn();
    } catch (error) {
      lastError = error;
      const shouldRetry = isErrorRetryable(lastError, fullConfig);
      const isLastAttempt = attempt >= fullConfig.maxAttempts;
      if (!shouldRetry || isLastAttempt) {
        throw error;
      }
      let delay;
      if (error instanceof RateLimitError && error.retryAfter) {
        delay = error.retryAfter;
      } else {
        delay = calculateDelay(
          attempt,
          fullConfig.baseDelay,
          fullConfig.maxDelay,
          fullConfig.backoffMultiplier,
          fullConfig.enableJitter
        );
      }
      if (fullConfig.onRetry) {
        fullConfig.onRetry(attempt, lastError, delay);
      }
      await sleep(delay);
    }
  }
  throw lastError ?? new Error("Retry failed with unknown error");
}
function withRetryWrapper(fn, config = {}) {
  return async (...args) => {
    return withRetry(() => fn(...args), config);
  };
}
async function withLinearRetry(fn, config = {}) {
  return withRetry(fn, {
    ...config,
    backoffMultiplier: 1
    // Linear backoff
  });
}
var RetryStats = class {
  attempts = [];
  successes = 0;
  failures = 0;
  record(attempts, success) {
    this.attempts.push(attempts);
    if (success) {
      this.successes++;
    } else {
      this.failures++;
    }
  }
  getStats() {
    const total = this.attempts.length;
    const avgAttempts = total > 0 ? this.attempts.reduce((a, b) => a + b, 0) / total : 0;
    return {
      total,
      successes: this.successes,
      failures: this.failures,
      successRate: total > 0 ? this.successes / total : 0,
      averageAttempts: avgAttempts
    };
  }
  reset() {
    this.attempts = [];
    this.successes = 0;
    this.failures = 0;
  }
};
async function withRetryStats(fn, stats, config = {}) {
  let attempts = 1;
  const trackingConfig = {
    ...config,
    onRetry: (attempt, error, delay) => {
      attempts = attempt + 1;
      if (config.onRetry) {
        config.onRetry(attempt, error, delay);
      }
    }
  };
  try {
    const result = await withRetry(fn, trackingConfig);
    stats.record(attempts, true);
    return result;
  } catch (error) {
    stats.record(attempts, false);
    throw error;
  }
}

// src/core/resilience.ts
function createResilientExecutor(config = {}) {
  const circuitBreaker = new CircuitBreaker(config.circuitBreaker);
  return async function execute(fn, operationName = "unknown") {
    try {
      return await circuitBreaker.execute(async () => {
        if (config.retry) {
          return await withRetry(fn, config.retry);
        }
        return await fn();
      });
    } catch (error) {
      const err2 = error;
      let context;
      if (err2 instanceof CircuitBreakerError) {
        context = {
          type: "circuit_open",
          circuitState: err2.state,
          operation: operationName
        };
      } else {
        context = {
          type: "retry_exhausted",
          attempts: config.retry?.maxAttempts,
          circuitState: circuitBreaker.getState(),
          operation: operationName
        };
      }
      if (config.onFailure) {
        config.onFailure(err2, context);
      }
      if (config.fallback) {
        try {
          return await config.fallback(err2);
        } catch (fallbackError) {
          if (config.onFailure) {
            config.onFailure(fallbackError, {
              type: "fallback_failed",
              operation: operationName
            });
          }
          throw fallbackError;
        }
      }
      throw error;
    }
  };
}
function withResilience(fn, config = {}, operationName) {
  const executor = createResilientExecutor(config);
  return async (...args) => {
    const name = operationName || fn.name || "anonymous";
    return executor(() => fn(...args), name);
  };
}
function Resilient(config = {}) {
  return function(target, propertyKey, descriptor) {
    const originalMethod = descriptor.value;
    if (typeof originalMethod !== "function") {
      throw new Error(`@Resilient can only be applied to methods`);
    }
    const executor = createResilientExecutor(config);
    descriptor.value = async function(...args) {
      return executor(() => originalMethod.apply(this, args), `${target.constructor.name}.${propertyKey}`);
    };
    return descriptor;
  };
}
var Bulkhead = class {
  constructor(config) {
    this.config = config;
  }
  currentExecutions = 0;
  queue = [];
  async execute(fn) {
    if (this.currentExecutions < this.config.maxConcurrent) {
      return this.executeNow(fn);
    }
    if (this.config.maxQueue && this.queue.length >= this.config.maxQueue) {
      throw new Error("Bulkhead queue is full");
    }
    await new Promise((resolve) => {
      this.queue.push(resolve);
    });
    return this.executeNow(fn);
  }
  async executeNow(fn) {
    this.currentExecutions++;
    try {
      return await fn();
    } finally {
      this.currentExecutions--;
      const next = this.queue.shift();
      if (next) {
        next();
      }
    }
  }
  getMetrics() {
    return {
      currentExecutions: this.currentExecutions,
      queuedExecutions: this.queue.length,
      capacity: this.config.maxConcurrent,
      utilization: this.currentExecutions / this.config.maxConcurrent
    };
  }
};
async function withTimeout(promise, timeoutMs, errorMessage = "Operation timed out") {
  return Promise.race([
    promise,
    new Promise(
      (_, reject) => setTimeout(() => reject(new Error(errorMessage)), timeoutMs)
    )
  ]);
}
function withCache(fn, ttlMs) {
  let cachedValue = null;
  let cacheExpiry = 0;
  return async () => {
    const now = Date.now();
    if (cachedValue !== null && now < cacheExpiry) {
      return cachedValue;
    }
    cachedValue = await fn();
    cacheExpiry = now + ttlMs;
    return cachedValue;
  };
}

// src/monitoring/metrics-server.ts
var import_http = require("http");
var MetricsServer = class {
  server;
  config;
  metrics;
  startTime;
  isRunning = false;
  logger = new Logger("MetricsServer");
  constructor(config = {}) {
    this.config = {
      port: config.port ?? 9090,
      host: config.host ?? "0.0.0.0",
      enableAuth: config.enableAuth ?? false,
      authToken: config.authToken,
      metrics: config.metrics ?? (isMetricsInitialized() ? getMetrics() : void 0),
      healthCheck: config.healthCheck,
      enableCors: config.enableCors ?? false,
      corsOrigin: config.corsOrigin ?? "*"
    };
    if (!this.config.metrics) {
      throw new Error(
        "Metrics not initialized. Call initializeMetrics() or provide metrics instance in config."
      );
    }
    if (this.config.enableAuth && !this.config.authToken) {
      throw new Error("authToken is required when enableAuth is true");
    }
    this.metrics = this.config.metrics;
    this.startTime = Date.now();
  }
  /**
   * Start the metrics server
   */
  async start() {
    if (this.isRunning) {
      throw new Error("Metrics server is already running");
    }
    return new Promise((resolve, reject) => {
      this.server = (0, import_http.createServer)((req, res) => {
        this.handleRequest(req, res).catch((error) => {
          this.logger.error("Error handling request", error instanceof Error ? error : void 0);
          this.sendResponse(res, 500, "Internal Server Error");
        });
      });
      this.server.on("error", (error) => {
        reject(error);
      });
      this.server.listen(this.config.port, this.config.host, () => {
        this.isRunning = true;
        this.logger.info(
          `Metrics server listening on http://${this.config.host}:${this.config.port}`
        );
        resolve();
      });
    });
  }
  /**
   * Stop the metrics server
   */
  async stop() {
    if (!this.isRunning || !this.server) {
      return;
    }
    return new Promise((resolve, reject) => {
      this.server.close((error) => {
        if (error) {
          reject(error);
        } else {
          this.isRunning = false;
          this.logger.info("Metrics server stopped");
          resolve();
        }
      });
    });
  }
  /**
   * Check if server is running
   */
  getIsRunning() {
    return this.isRunning;
  }
  /**
   * Get server address
   */
  getAddress() {
    if (!this.isRunning || !this.server) {
      return null;
    }
    const address = this.server.address();
    if (!address || typeof address === "string") {
      return null;
    }
    return {
      host: address.address,
      port: address.port
    };
  }
  /**
   * Handle incoming HTTP request
   */
  async handleRequest(req, res) {
    if (this.config.enableCors) {
      res.setHeader("Access-Control-Allow-Origin", this.config.corsOrigin);
      res.setHeader("Access-Control-Allow-Methods", "GET, OPTIONS");
      res.setHeader("Access-Control-Allow-Headers", "Authorization, Content-Type");
      if (req.method === "OPTIONS") {
        this.sendResponse(res, 204, "");
        return;
      }
    }
    if (req.method !== "GET") {
      this.sendResponse(res, 405, "Method Not Allowed");
      return;
    }
    if (this.config.enableAuth) {
      const authHeader = req.headers.authorization;
      const expectedAuth = `Bearer ${this.config.authToken}`;
      if (!authHeader || authHeader !== expectedAuth) {
        res.setHeader("WWW-Authenticate", "Bearer");
        this.sendResponse(res, 401, "Unauthorized");
        return;
      }
    }
    const url = req.url || "/";
    if (url === "/metrics") {
      await this.handleMetricsRequest(res);
    } else if (url === "/health") {
      await this.handleHealthRequest(res);
    } else if (url === "/") {
      this.handleRootRequest(res);
    } else {
      this.sendResponse(res, 404, "Not Found");
    }
  }
  /**
   * Handle /metrics endpoint
   */
  async handleMetricsRequest(res) {
    try {
      const metricsText = await this.metrics.getMetrics();
      const contentType = this.metrics.getContentType();
      res.setHeader("Content-Type", contentType);
      this.sendResponse(res, 200, metricsText);
    } catch (error) {
      this.logger.error("Error generating metrics", error instanceof Error ? error : void 0);
      this.sendResponse(res, 500, "Error generating metrics");
    }
  }
  /**
   * Handle /health endpoint
   */
  async handleHealthRequest(res) {
    try {
      const uptime = Date.now() - this.startTime;
      let healthResponse = {
        status: "healthy",
        timestamp: (/* @__PURE__ */ new Date()).toISOString(),
        uptime
      };
      if (this.config.healthCheck) {
        const customHealth = await this.config.healthCheck();
        healthResponse = {
          ...healthResponse,
          ...customHealth
        };
      }
      const statusCode = healthResponse.status === "healthy" ? 200 : 503;
      res.setHeader("Content-Type", "application/json");
      this.sendResponse(res, statusCode, JSON.stringify(healthResponse, null, 2));
    } catch (error) {
      this.logger.error("Error in health check", error instanceof Error ? error : void 0);
      const errorResponse = {
        status: "unhealthy",
        timestamp: (/* @__PURE__ */ new Date()).toISOString(),
        uptime: Date.now() - this.startTime,
        details: {
          error: error instanceof Error ? error.message : "Unknown error"
        }
      };
      res.setHeader("Content-Type", "application/json");
      this.sendResponse(res, 503, JSON.stringify(errorResponse, null, 2));
    }
  }
  /**
   * Handle root endpoint
   */
  handleRootRequest(res) {
    const html = `
<!DOCTYPE html>
<html>
<head>
  <title>Metrics Server</title>
  <style>
    body {
      font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif;
      max-width: 800px;
      margin: 50px auto;
      padding: 20px;
      line-height: 1.6;
    }
    h1 { color: #333; }
    a { color: #0066cc; text-decoration: none; }
    a:hover { text-decoration: underline; }
    .endpoint {
      background: #f5f5f5;
      padding: 15px;
      margin: 10px 0;
      border-radius: 5px;
    }
    code {
      background: #e0e0e0;
      padding: 2px 6px;
      border-radius: 3px;
      font-family: 'Courier New', monospace;
    }
  </style>
</head>
<body>
  <h1>Perp DEX SDK - Metrics Server</h1>
  <p>This server exposes Prometheus metrics and health status.</p>

  <div class="endpoint">
    <h2>\u{1F4CA} <a href="/metrics">Metrics</a></h2>
    <p>Prometheus-compatible metrics endpoint</p>
    <code>GET /metrics</code>
  </div>

  <div class="endpoint">
    <h2>\u{1F3E5} <a href="/health">Health</a></h2>
    <p>Application health status</p>
    <code>GET /health</code>
  </div>

  <hr>
  <p><small>Uptime: ${Math.floor((Date.now() - this.startTime) / 1e3)}s</small></p>
</body>
</html>
    `.trim();
    res.setHeader("Content-Type", "text/html");
    this.sendResponse(res, 200, html);
    return Promise.resolve();
  }
  /**
   * Send HTTP response
   */
  sendResponse(res, statusCode, body) {
    res.statusCode = statusCode;
    res.end(body);
  }
};
async function startMetricsServer(config) {
  const server = new MetricsServer(config);
  await server.start();
  return server;
}

// src/core/calculations/pnl.ts
function calculateUnrealizedPnl(side, entryPrice, currentPrice, size) {
  if (side === "long") {
    return (currentPrice - entryPrice) * size;
  } else {
    return (entryPrice - currentPrice) * size;
  }
}
function calculateLiquidationPrice3(side, entryPrice, leverage, maintenanceMarginRate = 5e-3) {
  const initialMarginRate = 1 / leverage;
  if (side === "long") {
    return entryPrice * (1 - initialMarginRate + maintenanceMarginRate);
  } else {
    return entryPrice * (1 + initialMarginRate - maintenanceMarginRate);
  }
}
function calculateRequiredMargin(positionValue, leverage) {
  return positionValue / leverage;
}
function calculatePositionValue(price, size) {
  return price * size;
}
function calculateROE(pnl, margin) {
  if (margin === 0) return 0;
  return pnl / margin;
}
function calculateMarginRatio(usedMargin, totalMargin) {
  if (totalMargin === 0) return 1;
  return Math.min(1, usedMargin / totalMargin);
}
function calculateEffectiveLeverage(positionValue, margin) {
  if (margin === 0) return 0;
  return positionValue / margin;
}
function calculateFundingPayment2(positionValue, fundingRate, isLong) {
  const payment = positionValue * fundingRate;
  return isLong ? -payment : payment;
}
function calculateBreakEvenPrice(entryPrice, side, takerFeeRate, makerFeeRate = 0) {
  const totalFeeRate = takerFeeRate + makerFeeRate;
  if (side === "long") {
    return entryPrice * (1 + totalFeeRate);
  } else {
    return entryPrice * (1 - totalFeeRate);
  }
}
function calculateMaxPositionSize(availableMargin, leverage, price) {
  const maxPositionValue = availableMargin * leverage;
  return maxPositionValue / price;
}
function calculateAverageEntryPrice(currentSize, currentEntryPrice, addedSize, addedPrice) {
  const totalValue = currentSize * currentEntryPrice + addedSize * addedPrice;
  const totalSize = currentSize + addedSize;
  if (totalSize === 0) return 0;
  return totalValue / totalSize;
}
function calculateMarkToMarket(size, entryPrice, markPrice, side) {
  const pnl = calculateUnrealizedPnl(side, entryPrice, markPrice, size);
  const positionValue = calculatePositionValue(entryPrice, size);
  return positionValue + pnl;
}

// src/utils/symbols.ts
function createSymbol(_exchange, base, quote = "USDT") {
  const normalizedBase = base.toUpperCase().trim();
  const normalizedQuote = quote.toUpperCase().trim();
  if (!normalizedBase) {
    throw new Error("Base currency cannot be empty");
  }
  if (!normalizedQuote) {
    throw new Error("Quote currency cannot be empty");
  }
  if (!/^[A-Z0-9]+$/.test(normalizedBase)) {
    throw new Error(`Invalid base currency: ${base}`);
  }
  if (!/^[A-Z0-9]+$/.test(normalizedQuote)) {
    throw new Error(`Invalid quote currency: ${quote}`);
  }
  return `${normalizedBase}/${normalizedQuote}:${normalizedQuote}`;
}
function parseSymbol(symbol) {
  const parts = symbol.split(":");
  if (parts.length === 2) {
    const [pair, settle] = parts;
    const [base, quote] = (pair ?? "").split("/");
    if (!base || !quote || !settle) {
      throw new Error(`Invalid symbol format: ${symbol}`);
    }
    return {
      base,
      quote,
      settle,
      type: "swap"
    };
  } else if (parts.length === 1) {
    const [base, quote] = (parts[0] ?? "").split("/");
    if (!base || !quote) {
      throw new Error(`Invalid symbol format: ${symbol}`);
    }
    return {
      base,
      quote,
      settle: quote,
      type: "spot"
    };
  } else {
    throw new Error(`Invalid symbol format: ${symbol}`);
  }
}
function buildSymbol(base, quote, settle) {
  if (settle && settle !== quote) {
    return `${base}/${quote}:${settle}`;
  } else if (settle) {
    return `${base}/${quote}:${settle}`;
  } else {
    return `${base}/${quote}`;
  }
}
function isValidSymbol(symbol) {
  try {
    parseSymbol(symbol);
    return true;
  } catch {
    return false;
  }
}
function getBaseCurrency(symbol) {
  const parts = parseSymbol(symbol);
  return parts.base;
}
function getQuoteCurrency(symbol) {
  const parts = parseSymbol(symbol);
  return parts.quote;
}
function getSettleCurrency(symbol) {
  const parts = parseSymbol(symbol);
  return parts.settle;
}
function isPerpetual(symbol) {
  return symbol.includes(":");
}
function normalizeSymbol(symbol) {
  const trimmed = symbol.trim().toUpperCase();
  if (trimmed.includes("PERP") || trimmed.includes("PERPETUAL")) {
    const base = trimmed.split(/[-_]/)[0];
    return `${base}/USDT:USDT`;
  }
  if (isValidSymbol(trimmed)) {
    return trimmed;
  }
  throw new Error(`Cannot normalize symbol: ${symbol}`);
}
function compareSymbols(symbol1, symbol2) {
  try {
    const parts1 = parseSymbol(symbol1);
    const parts2 = parseSymbol(symbol2);
    return parts1.base === parts2.base && parts1.quote === parts2.quote && parts1.settle === parts2.settle && parts1.type === parts2.type;
  } catch {
    return false;
  }
}
function filterByBase(symbols, baseCurrency) {
  return symbols.filter((symbol) => {
    try {
      return getBaseCurrency(symbol) === baseCurrency.toUpperCase();
    } catch {
      return false;
    }
  });
}
function filterByQuote(symbols, quoteCurrency) {
  return symbols.filter((symbol) => {
    try {
      return getQuoteCurrency(symbol) === quoteCurrency.toUpperCase();
    } catch {
      return false;
    }
  });
}
function groupByBase(symbols) {
  const groups = /* @__PURE__ */ new Map();
  for (const symbol of symbols) {
    try {
      const base = getBaseCurrency(symbol);
      const existing = groups.get(base) ?? [];
      existing.push(symbol);
      groups.set(base, existing);
    } catch {
    }
  }
  return groups;
}

// src/utils/config.ts
var EXCHANGE_ENV_REQUIREMENTS = {
  // EIP-712 signature based
  hyperliquid: ["HYPERLIQUID_PRIVATE_KEY"],
  nado: ["NADO_PRIVATE_KEY"],
  // API Key + HMAC signature based
  lighter: ["LIGHTER_API_KEY", "LIGHTER_API_SECRET"],
  // StarkEx/L2 signature based (Pedersen hash + ECDSA)
  edgex: ["EDGEX_STARK_PRIVATE_KEY"],
  // API Key + optional StarkNet signing
  extended: ["EXTENDED_API_KEY"],
  // HMAC signature based (API in development)
  variational: ["VARIATIONAL_API_KEY", "VARIATIONAL_API_SECRET"],
  // Existing exchanges
  grvt: ["GRVT_PRIVATE_KEY", "GRVT_API_KEY"],
  paradex: ["PARADEX_STARK_PRIVATE_KEY"],
  backpack: ["BACKPACK_API_KEY", "BACKPACK_SECRET_KEY"],
  // Cosmos SDK based (dYdX v4)
  dydx: ["DYDX_MNEMONIC"],
  // Solana based (Jupiter Perps)
  jupiter: ["JUPITER_WALLET_ADDRESS"],
  // Read-only; for trading add JUPITER_PRIVATE_KEY
  // Solana based (Drift Protocol)
  drift: ["DRIFT_WALLET_ADDRESS"],
  // Read-only; for trading add DRIFT_PRIVATE_KEY
  // EVM based on-chain DEX (GMX v2 on Arbitrum/Avalanche)
  gmx: ["GMX_CHAIN"]
  // Chain selection; add GMX_WALLET_ADDRESS for positions
};
var ConfigurationError = class _ConfigurationError extends Error {
  constructor(message, exchange, missingVars) {
    super(message);
    this.exchange = exchange;
    this.missingVars = missingVars;
    this.name = "ConfigurationError";
    Object.setPrototypeOf(this, _ConfigurationError.prototype);
  }
};
function validateConfig(exchange) {
  const required = EXCHANGE_ENV_REQUIREMENTS[exchange];
  const missing = required.filter((key) => {
    const value = process.env[key];
    return !value || value.trim() === "" || value === "your_private_key_here" || value === "your_api_key_here";
  });
  if (missing.length > 0) {
    throw new ConfigurationError(
      `Missing or invalid environment variables for ${exchange}:
` + missing.map((key) => `  \u274C ${key}`).join("\n") + `

\u{1F4DD} See .env.example for configuration template.
\u{1F4A1} Copy .env.example to .env and fill in your credentials.`,
      exchange,
      missing
    );
  }
}
function isValidPrivateKey(key, allowPrefix = true) {
  if (!key) return false;
  const trimmed = key.trim();
  if (allowPrefix && trimmed.startsWith("0x")) {
    return /^0x[a-fA-F0-9]{64}$/.test(trimmed);
  }
  return /^[a-fA-F0-9]{64}$/.test(trimmed);
}
function isValidApiKey(key) {
  if (!key) return false;
  const trimmed = key.trim();
  return trimmed.length >= 16 && trimmed !== "your_api_key_here" && trimmed !== "your_api_secret_here" && !/^x+$/i.test(trimmed);
}
function getConfigErrorMessage(exchange, missingVars) {
  const varList = missingVars.map((v) => `  - ${v}`).join("\n");
  const instructions = {
    hyperliquid: "Export your MetaMask private key or generate a new wallet",
    lighter: "Register at lighter.xyz and create API key + secret credentials",
    grvt: "Register at grvt.io, generate API key, and use your ETH wallet",
    paradex: "Generate a StarkNet wallet key (PARADEX_STARK_PRIVATE_KEY)",
    edgex: "Register at edgex.exchange and get your StarkEx L2 private key",
    backpack: "Register at backpack.exchange and create ED25519 API credentials",
    nado: "Export your MetaMask private key for Ink L2 trading on Nado",
    variational: "Register at variational.io and create HMAC API credentials",
    extended: "Register at extended.exchange and generate API key",
    dydx: "Generate a Cosmos wallet mnemonic (24 words) for dYdX v4 trading",
    jupiter: "Provide your Solana wallet address for Jupiter Perps (add private key for trading)",
    drift: "Provide your Solana wallet address for Drift Protocol (add private key for trading)",
    gmx: "Set GMX_CHAIN to arbitrum or avalanche (add GMX_WALLET_ADDRESS for position data)"
  };
  return `\u274C Missing environment variables for ${exchange}:

${varList}

\u{1F4DD} Setup Instructions:
1. Copy .env.example to .env
2. ${instructions[exchange]}
3. Fill in the credentials in .env file
4. Ensure .env is in .gitignore (NEVER commit credentials!)
`;
}
function hasEnvironmentSupport() {
  return typeof process !== "undefined" && typeof process.env === "object";
}
function validateMultipleConfigs(exchanges) {
  const results = {};
  for (const exchange of exchanges) {
    const required = EXCHANGE_ENV_REQUIREMENTS[exchange];
    const missing = required.filter((key) => {
      const value = process.env[key];
      return !value || value.trim() === "";
    });
    results[exchange] = {
      valid: missing.length === 0,
      missing
    };
  }
  return results;
}
function getRequiredEnvVars(exchange) {
  return [...EXCHANGE_ENV_REQUIREMENTS[exchange]];
}
function maskSensitive(value, showChars = 4) {
  if (!value || value.length <= showChars * 2) {
    return "***";
  }
  const start = value.slice(0, showChars);
  const end = value.slice(-showChars);
  return `${start}...${end}`;
}

// src/index.ts
var VERSION = "0.2.0";
// Annotate the CommonJS export names for ESM import in node:
0 && (module.exports = {
  BackpackAdapter,
  BalanceSchema,
  BaseAdapter,
  Bulkhead,
  CircuitBreaker,
  ConfigurationError,
  DriftAdapter,
  DriftAuth,
  DriftNormalizer,
  DydxAdapter,
  DydxAuth,
  DydxNormalizer,
  EdgeXAdapter,
  ExchangeUnavailableError,
  ExpiredAuthError,
  ExtendedAdapter,
  FundingRateSchema,
  GRVTAdapter,
  GRVTAuth,
  GmxAdapter,
  GmxNormalizer,
  HyperliquidAdapter,
  HyperliquidAuth,
  InsufficientMarginError,
  InsufficientPermissionsError,
  InvalidOrderError,
  InvalidSignatureError,
  JupiterAdapter,
  JupiterAuth,
  JupiterNormalizer,
  LighterAdapter,
  LiquidationError,
  LogLevel,
  Logger,
  MARGIN_MODES,
  MarketSchema,
  MetricsServer,
  NadoAdapter,
  ORDER_SIDES,
  ORDER_STATUSES,
  ORDER_TYPES,
  OrderBookSchema,
  OrderNotFoundError,
  OrderRequestSchema,
  OrderSchema,
  POSITION_SIDES,
  ParadexAdapter,
  ParadexAuth,
  PerpDEXError,
  PositionNotFoundError,
  PositionSchema,
  PrometheusMetrics,
  RateLimitError,
  RateLimiter,
  Resilient,
  RetryStats,
  SlippageExceededError,
  TIME_IN_FORCE,
  TickerSchema,
  TradeSchema,
  TransactionFailedError,
  VERSION,
  VariationalAdapter,
  WebSocketClient,
  WebSocketDisconnectedError,
  WebSocketManager,
  allocBuffer,
  buffersEqual,
  buildSymbol,
  bytesToHex,
  calculateAverageEntryPrice,
  calculateBreakEvenPrice,
  calculateEffectiveLeverage,
  calculateFundingPayment,
  calculateLiquidationPrice,
  calculateMarginRatio,
  calculateMarkToMarket,
  calculateMaxPositionSize,
  calculatePositionValue,
  calculateROE,
  calculateRequiredMargin,
  calculateUnrealizedPnl,
  compareSymbols,
  concatBuffers,
  copyBuffer,
  createChildLogger,
  createExchange,
  createHmacSha256,
  createRequestContext,
  createResilientExecutor,
  createSha256Hash,
  createSha256HashBuffer,
  createSha3Hash,
  createSha3HashBuffer,
  createSymbol,
  createValidator,
  determineHealthStatus,
  filterByBase,
  filterByQuote,
  formatLogEntry,
  fromBuffer,
  generateCorrelationId,
  getBaseCurrency,
  getConfigErrorMessage,
  getMetrics,
  getQuoteCurrency,
  getRequiredEnvVars,
  getSettleCurrency,
  getSupportedExchanges,
  groupByBase,
  hasEnvironmentSupport,
  hexToBytes,
  initializeMetrics,
  isAuthError,
  isCriticallyUnhealthy,
  isExchangeSupported,
  isHealthy,
  isMetricsInitialized,
  isPerpDEXError,
  isPerpetual,
  isRateLimitError,
  isValidApiKey,
  isValidPrivateKey,
  isValidSymbol,
  maskSensitive,
  normalizeSymbol,
  parseSymbol,
  readBigUInt64BE,
  readBigUInt64LE,
  sliceBuffer,
  startMetricsServer,
  toBuffer,
  validate,
  validateArray,
  validateArraySimple,
  validateConfig,
  validateData,
  validateMarketParams,
  validateMultipleConfigs,
  validateOrderBookParams,
  validateOrderRequest,
  validateResponse,
  validateSafe,
  validateTradeParams,
  withCache,
  withLinearRetry,
  withResilience,
  withRetry,
  withRetryStats,
  withRetryWrapper,
  withTimeout,
  writeBigUInt64BE,
  writeBigUInt64LE
});
/*! Bundled license information:

js-sha3/src/sha3.js:
  (**
   * [js-sha3]{@link https://github.com/emn178/js-sha3}
   *
   * @version 0.9.3
   * @author Chen, Yi-Cyuan [emn178@gmail.com]
   * @copyright Chen, Yi-Cyuan 2015-2023
   * @license MIT
   *)

@noble/ed25519/index.js:
  (*! noble-ed25519 - MIT License (c) 2019 Paul Miller (paulmillr.com) *)
*/
